JS介绍:
  - JavaScript遵循ECMAScript规范
  - 一个完成的JavaScript有3部分组成，ECMAScript、DOM、BOM
  - JavaScript是一门解析型语言，基于原型的面向对象语言
  - 参考文档https://www.w3cschool.cn/javascript/js-ex-objects.html
初级:
  JS五种数据类型:
    基本数据类型:
      - String
      - Boolean
      - Number
      - Undefined
      - Null
    引用数据类型:
      - Object
  JS二进制/八进制/十六进制赋值:
    - 八进制 0 或 0o 或 0O
    - 十六进制 0x 或 0X
    - 二进制 0b 或者 0B
  类型转换:
    显示类型转换:
      转换为String:
        - "
          //能调用toString()
          window.console.log('false |',false.toString(),typeof false.toString())
          window.console.log('NaN |',NaN.toString())
          window.console.log('"" |',"".toString())
          window.console.log('true |',true.toString())
          window.console.log('Infinity |',Infinity.toString())
          window.console.log('-Infinity |',-Infinity.toString())
          window.console.log('new Object |',new Object().toString())

          //不能调用toString()
          //window.console.log('null |',null.toString())
          //window.console.log('undefined |',undefined.toString())
          //window.console.log('数值 |',数值.toString())

          console.log('-------------------------------------------------')

          window.console.log('false |',new String(false))
          window.console.log('null |',new String(null))
          window.console.log('NaN |',new String(NaN))
          window.console.log('0 |',new String(0))
          window.console.log('"" |',new String(""))
          window.console.log('undefined |',new String(undefined))
          window.console.log('true |',new String(true))
          window.console.log('Infinity |',new String(Infinity))
          window.console.log('-Infinity |',new String(-Infinity))
          window.console.log('123 |',new String(123))
          window.console.log('-123 |',new String(-123))
          window.console.log('new Object |',new String(new Object))
          window.console.log('hello |',new String('hello'))
      "
      转换为Number: `
        //为0
        window.console.log('false |',new Number(false))
        window.console.log('null |',new Number(null))
        window.console.log('0 |',new Number(0))
        window.console.log('"" |',new Number(""))
        window.console.log('"0" |',new Number("0"))
        window.console.log('-----------------------------------')

        //为1
        window.console.log('true |',new Number(true))
        window.console.log('-----------------------------------')
        //为NaN
        window.console.log('NaN |',new Number(NaN))
        window.console.log('undefined |',new Number(undefined))
        window.console.log('new Object |',new Number(new Object))
        window.console.log('123hello123 |',new Number('123hello123'))
        window.console.log('"true" |',new Number("true"))
        window.console.log('"false" |',new Number("false"))
        window.console.log('-----------------------------------')
        //为Infinity
        window.console.log('Infinity |',new Number(Infinity))
        window.console.log('Infinity |',new Number(-Infinity))
        window.console.log('-----------------------------------')
        //方式2
        //将参数转换为字符串以后进行逐个转换，遇到非数字就停止转换，并10进制方式转换
        window.console.log('parseInt(123.584px)  |',parseInt('123.584px',10))
        window.console.log('parseFloat(123.584px)  |',parseFloat('123.584px',10))
        //返回NaN
        window.console.log('""  |',parseFloat('',10))
      转换为Boolean:
        - "
            //为false
            window.console.log('false |',new Boolean(false))
            window.console.log('null |',new Boolean(null))
            window.console.log('NaN |',new Boolean(NaN))
            window.console.log('0 |',new Boolean(0))
            window.console.log('"" |',new Boolean(""))
            window.console.log('undefined |',new Boolean(undefined))

            //为true
            window.console.log('true |',new Boolean(true))
            window.console.log('Infinity |',new Boolean(Infinity))
            window.console.log('-Infinity |',new Boolean(-Infinity))
            window.console.log('123 |',new Boolean(123))
            window.console.log('-123 |',new Boolean(-123))
            window.console.log('new Object |',new Boolean(new Object))
            window.console.log('hello |',new Boolean('hello'))
      "
    隐式类型转换(运算符):
      先转换为Number类型在运算:
        - 具体如何转，查看类型转换
        - `
          (加+、减-、乘*、除/、取余%)
            正常情况
              会先把非数值型转换为数值型在运算
            特殊情况
              (加+)如果遇到字符串，会将其他非字符串的转换为字符串，然后进行拼接操作
          `
        - (负号-、正号+)
        - `
          (> < ≥ ≤)
          情况1
            将左右两边字面量转化为数值，然后比较，返回true/false，
          情况2
            如果转有任意一边转换为NaN值，则直接返回false
          情况3
            如果两边都为字符串，则比较的是Unicode编码，逐个字符串进行比较，如果第一位比别人的第一位小，则返回，如果相同，则继续比较。
        - `
           (==，!=)
            正常情况1
              通过Number()进行转换后成为数值，则可以进行比较，结果为true/false
              如果两边都为字符串，则比较的是Unicode编码，逐个字符串进行比较
              比较基本数据类型是比较值是否一样，比较引用类型是比较地址值是否一样
            特殊情况2
              null==undefined，相等
              NaN==任何值，不相等
              NaN==NaN，不相等，可以通过isNaN()函数进行判断
          `
        - `
          (===，!==) 次比较不会做类型转换，直接返回true/false
            正常情况
              比较类型，如果类型不等直接就不相等，如果类型相等，在比较字面量
            特殊情况
            null===undefined，不相等
            NaN===任何值，不相等
            NaN===NaN，不相等，可以通过isNaN()函数进行判断
          `
      先转换为Boolean类型在运算:
        - 具体如何转，查看类型转换
        - (非!、或||、与&&)
        - (三目运算符?:)
  运算符:
    短路与(短路与的true是返回右边):
      - 只拿左边第一个进行boolean转换，如果true，返回右边的，右边是啥类型返回啥类型
      - 只拿左边第一个进行boolean转换，如果false，返回左边的，左边是啥类型返回啥类型
      - `
        //只拿左边第一个进行boolean转换，如果true，返回右边的，右边是啥类型返回啥类型
        console.log('true&&false |',true&&false,'| ',typeof (true&&false))
        console.log('true&&11 |',true&&11,'| ',typeof (true&&11))
        console.log('true&&NaN |',true&&NaN,'| ',typeof (true&&NaN))
        console.log('true&&undefined |',true&&undefined,'| ',typeof (true&&undefined))
        console.log('true&&Infinity |',true&&Infinity,'| ',typeof (true&&Infinity))
        console.log('true&&`hello" |',true&&"hello",'| ',typeof (true&&"11"))
        console.log('true&&new Object() |',true&&new Object(),'| ',typeof (true&&new Object()))
        //console.log('true&&alert(1)" |',true&&alert(1),'| ',typeof (true&&alert(1)))

        console.log('-------------------------------------------')
        //为true
        /* window.console.log('true |',Boolean(true))
        window.console.log('Infinity |',Boolean(Infinity))
        window.console.log('-Infinity |',Boolean(-Infinity))
        window.console.log('123 |',Boolean(123))
        window.console.log('-123 |',Boolean(-123))
        window.console.log('new Object |',Boolean(new Object))
        window.console.log('hello |',Boolean('hello')) */
        console.log('Infinity&&返回我 |',Infinity&&'返回我','| ',typeof (Infinity&&'返回我'))
        console.log('-Infinity&&返回我 |',-Infinity&&'返回我','| ',typeof (-Infinity&&'返回我'))
        console.log('123&&返回我 |',123&&'返回我','| ',typeof (123&&'返回我'))
        console.log('-123&&返回我 |',-123&&'返回我','| ',typeof (-123&&'返回我'))
        console.log('new Object()&&返回我 |',new Object()&&'返回我','| ',typeof (new Object()&&'返回我'))
        console.log('"hello"&&返回我 |',"hello"&&'返回我','| ',typeof ("hello"&&'返回我'))

        console.log('-------------------------------------------')
        /* //为false
        window.console.log('false |',Boolean(false))
        window.console.log('null |',Boolean(null))
        window.console.log('NaN |',Boolean(NaN))
        window.console.log('0 |',Boolean(0))
        window.console.log('"" |',Boolean(""))
        window.console.log('undefined |',Boolean(undefined)) */
        //只拿左边第一个进行boolean转换，如果false，返回左边的，左边是啥类型返回啥类型
        console.log('false&&返回我 |',false&&'返回我','| ',typeof (false&&'返回我'))
        console.log('null&&返回我 |',null&&'返回我','| ',typeof (null&&'返回我'))
        console.log('NaN&&返回我 |',NaN&&'返回我','| ',typeof (NaN&&'返回我'))
        console.log('""&&返回我 |',""&&'返回我','| ',typeof (""&&'返回我'))
        console.log('undefined&&返回我 |',undefined&&'返回我','| ',typeof (undefined&&'返回我'))
        `
    短路或:
      - 只拿左边第一个进行boolean转换，如果true，返回左边的，左边是啥类型返回啥类型
      - 只拿左边第一个进行boolean转换，如果false，返回右边的，右边是啥类型返回啥类型
      - `
        //只拿左边第一个进行boolean转换，如果true，返回左边的，左边是啥类型返回啥类型
        //为true
        /* window.console.log('true |',Boolean(true))
        window.console.log('Infinity |',Boolean(Infinity))
        window.console.log('-Infinity |',Boolean(-Infinity))
        window.console.log('123 |',Boolean(123))
        window.console.log('-123 |',Boolean(-123))
        window.console.log('new Object |',Boolean(new Object))
        window.console.log('hello |',Boolean('hello')) */
        console.log('true||返回我 |',true||'返回我','| ',typeof (true||'返回我'))
        console.log('Infinity||返回我 |',Infinity||'返回我','| ',typeof (Infinity||'返回我'))
        console.log('-Infinity||返回我 |',-Infinity||'返回我','| ',typeof (-Infinity||'返回我'))
        console.log('123||返回我 |',123||'返回我','| ',typeof (123||'返回我'))
        console.log('-123||返回我 |',-123||'返回我','| ',typeof (-123||'返回我'))
        console.log('new Object()||返回我 |',new Object()||'返回我','| ',typeof (new Object()||'返回我'))
        console.log('"hello"||返回我 |',"hello"||'返回我','| ',typeof ("hello"||'返回我'))

        console.log('-------------------------------------------')

        //只拿左边第一个进行boolean转换，如果false，返回右边的，右边是啥类型返回啥类型
        console.log('false||false |',false||false,'| ',typeof (false||false))
        console.log('false||11 |',false||11,'| ',typeof (false||11))
        console.log('false||NaN |',false||NaN,'| ',typeof (false||NaN))
        console.log('false||undefined |',false||undefined,'| ',typeof (false||undefined))
        console.log('false||Infinity |',false||Infinity,'| ',typeof (false||Infinity))
        console.log('false||"hello" |',false||"hello",'| ',typeof (false||"11"))
        console.log('false||new Object() |',false||new Object(),'| ',typeof (false||new Object()))
        //console.log('false||alert(1)" |',false||alert(1),'| ',typeof (false||alert(1)))
        console.log('-------------------------------------------')
        /* //为false
        window.console.log('false |',Boolean(false))
        window.console.log('null |',Boolean(null))
        window.console.log('NaN |',Boolean(NaN))
        window.console.log('0 |',Boolean(0))
        window.console.log('"" |',Boolean(""))
        window.console.log('undefined |',Boolean(undefined)) */
        console.log('false||返回我 |',false||'返回我','| ',typeof (false||'返回我'))
        console.log('null||null |',null||'返回我','| ',typeof (null||null))
        console.log('NaN||返回我 |',NaN||'返回我','| ',typeof (NaN||'返回我'))
        console.log('""||返回我 |',""||'返回我','| ',typeof (""||'返回我'))
        console.log('undefined||返回我 |',undefined||'返回我','| ',typeof (undefined||'返回我'))
        `
    非:
      - 将某个类型数据进行boolean转换，如果为true返回true，如果为false返回false
      - `
        /*
        //为false
        window.console.log('false |',Boolean(false))
        window.console.log('null |',Boolean(null))
        window.console.log('NaN |',Boolean(NaN))
        window.console.log('0 |',Boolean(0))
        window.console.log('"" |',Boolean(""))
        window.console.log('undefined |',Boolean(undefined))
        */
        console.log('!false |',!false,'| ',typeof (!false))
        console.log('!null |',!null,'| ',typeof (!null))
        console.log('!NaN |',!NaN,'| ',typeof (!NaN))
        console.log('!0 |',!0,'| ',typeof (!0))
        console.log('!"" |',!"",'| ',typeof (!""))
        console.log('!undefined |',!undefined,'| ',typeof (!undefined))

        console.log("------------------------------------------")
        /*
        //为true
        window.console.log('true |',Boolean(true))
        window.console.log('Infinity |',Boolean(Infinity))
        window.console.log('-Infinity |',Boolean(-Infinity))
        window.console.log('123 |',Boolean(123))
        window.console.log('-123 |',Boolean(-123))
        window.console.log('new Object |',Boolean(new Object))
        window.console.log('hello |',Boolean('hello'))  */

        console.log('!true |',!true,'| ',typeof (!true))
        console.log('!Infinity |',!Infinity,'| ',typeof (!Infinity))
        console.log('!-Infinity |',!-Infinity,'| ',typeof (!-Infinity))
        console.log('!123 |',!123,'| ',typeof (!123))
        console.log('!-123 |',!-123,'| ',typeof (!-123))
        console.log('!new Object() |',!new Object(),'| ',typeof (!new Object()))
        console.log('!"hello" |',!'hello','| ',typeof (!'hello'))
        `
  单纯代码块: 在js中单纯的代码块{}只具有分组的作用，没有其他的用途，在代码块中的代码，在外部是完全可见的
  条件语句:
    if:
      - if表达式的值，只能是【布尔类型】，也就是说不管是什么类型，但最后都会隐式转换为布尔类型
    switch:
      - switch和case表达式的值可以为【任意类型值】
      - js的switch语句支持双表达式写法
      - switch语句，会拿表达式的值和case(字面量、表达式的值)进行[全等(===)比较]
  循环语句:
    whlie:
      - whlie表达式的值，只能是【布尔类型】，也就是说不管是什么类型，但最后都会隐式转换为布尔类型
    do-while:
      - do-while表达式的值，只能是【布尔类型】，也就是说不管是什么类型，但最后都会隐式转换为布尔类型
    for:
      方式1:
        - for(var i;i<10;i++){}
        - for(初始表达式;条件表达式;更新表达式)
        - 条件表达式的值，只能是【布尔类型】，也就是说不管是什么类型，但最后都会隐式转换为布尔类型
      方式2:
        - for(var attr in obj){}
        - 枚举对象中的属性
  break和continue关键字:
    break:
      - 只能用在swtich和循环语句
      - 用法1 break 默认情况下终止当前循环体
      - 用法2 break forName 可以终止该循环体以及外层所有循环体，并且终止
      - "
          //给循环起名字
          forName:
          for(var i=0;i<3;i++){
              console.log(i)
              forName1:
              for(var c=0;c<3;c++){
                  console.log(c)
                  for(var j=0;j<3;j++){
                      console.log(j)
                      break forName;
                  }
              }
              console.log('----------------------')
          }

          whileName:
          while(true){
              console.log(1)
              whileName1:
              while(true){
                  console.log(2)
                  break whileName;
              }
          }
      "
    continue:
      - 只能用在循环语句
      - 用法1 continue 默认情况下终止当前循环体
      - 用法2 continue forName 可以跳过该循环体以及外层所有循环体，进行下一次执行。
      - "
        //给循环起名字
        forName:
        for(var i=0;i<3;i++){
            console.log(i)
            forName1:
            for(var c=0;c<3;c++){
                console.log(c)
                for(var j=0;j<3;j++){
                    console.log(j)
                    continue forName;
                }
            }
            console.log('----------------------')
        }
      "
中级:
  对象:
    对象分类:
      内建对象:
        - 由ECMAScript标准中定义的对象，在任何的ECMAScript的实现中都可以使用
        - 比如 Array Math Date String Number Boolean Function Object..
      宿主对象:
        - 由JS的运行环境提供的对象，目前来讲主要指浏览器提供的对象
        - 比如 BOM DOM
      自定义对象:
        - 由开发人员自己创建的对象
    对象的创建:
      方式1:
        - 利用构造函数来创建对象
        - `
          function MyObject(){
          this.age = 18,
          this.sex = '男',
          this["tip"] = 'hello-world',
          this[1<2] = 'true'
          }
          obj = new MyObject()
          obj.name = 'eric'
          console.log(obj,typeof obj)
          `
      方式2:
        - 利用【{}】来创建
        - "
            var tip = 'hello-world'
            obj = {
                age:18,
                'sex': '男',
                tip
            }
            obj.name = 'eric'
            obj[1<2] = 'false'
            console.log(obj,typeof obj)
          "
    对象的属性:
      功能:
        - 对象的属性可以是任意的命名方式，不需要遵守标识符规范，例如obj.null ,obj.undefine
        - 操作对象的属性可以使用【点方式或者['']方式】进行操作
      检查属性:
        - console.log("attr" in obj/Object) 可以检查一个对象(对象本身+原型对象)是否含有该属性，有则返回true，没有返回false
        - obj/Object.hasOwnProperty('attr') 可以检查一个对象(对象本身)是否含有该属性，有则返回true，没有返回false
        - for(var attr in obj/Object){} 枚举对象中的属性或方法
      对象的属性值:
        - 对象的属性值可以是(基本数据类型、对象类型、函数类型)的值
        - 如果一个对象的属性值是函数，那么这个属性称为【方法】
      属性操作:
        功能:
          - 访问一个对象中的属性，如果不存在不会报错，而且会返回undefined。
        方式1:
          - 增 obj.name = 18
          - 删 delete obj.name
          - 改 obj.name = 19
          - 查 obj.name
        方式2(非常灵活):
          - [ '' ]方式，
          - 可以定义一些另类的属性，比如 obj['123'] = 1000
          - 可以存放，任意类型变量、字符串、表达式，但最终都会隐式转换为字符串类型
          - 增 obj['sex'] = '男'
          - 删 delete obj['sex']
          - 改 obj['sex'] = 20
          - 查 obj['sex']
  函数:
    功能:
      - 函数也是一个对象，而且它是一个特殊对象，可以保存代码块和属性
      - 调用函数语法 = 函数对象()
      - 在调用函数时，解析器不会检查实际参数的类型以及实际参数的个数
      - 函数的(形参、实参、返回值)可以是(基本数据类型、对象类型、函数类型)
    创建函数:
      方式1:
        - 通过函数对象创建函数，并将想要封装的代码以字符串的方式传递给构造函数
        - `
          写法1
          new Function("console.log('我的第1个函数')")();
          写法2
          //存放函数引用地址的变量fun，调用函数fun()
          var fun = new Function("console.log('我的第2个函数');");
          fun()
          console.log(fun,typeof fun)
          `
      方式2:
        - 通过function来创建函数
        - `
          写法1-声明式
          //存放函数引用地址的变量fun1，调用函数fun1()
          function fun1(){
          console.log('我的第3个函数');
          }
          fun1();
          //console.log(fun1,typeof fun1)
          写法2-表达式
          //存放函数引用地址的变量fun2，调用函数fun2()
          var fun2 = function(){
          console.log('我的第4个函数');
          }
          fun2();
          //console.log(fun2,typeof fun2)
          写法3
          //创建立即执行函数
          (function(name){
          console.log(name,'我的第5个函数');
          })('eric')
          `
    构造函数:
      功能:
        - 构造函数和普通函数的一模一样，唯独就是取名方式不一样，普通函数首字母为小写，构造函数首字母为大写
        - 构造函数需要使用new关键字来调用
        - 使用同一个构造函数创建的对象，我们成为一类对象，也将一个构造函数成为一个类，该构造函数创建出来的对象，我们成为该类的实例对象
        - 通过 instanceof  来判断一个类实例是否属于该类
      构造函数执行流程:
        - 1.立刻创建一个新的对象
        - 2.将新的对象设置为函数中的this，在构造函数中可以使用this来引用新建对象
        - 3.逐行执行函数中的代码
        - 4.将新建的对象作为返回值返回
      构造函数之java转换:
        - 其实构造函数可以看成一个java类
        - Demefun.attr  为一个类添加方法
        - new Demefun().attr 为一个对象添加方法
    函数中this对象:
      - 解析器会为每个函数隐式传递一个this对象
      - 根据函数的调用方式不同this指向不同
      - "
         以方法方式调用，this指向的是当前对象  obj.fun()
         以new方式调用，this指向的是当前对象  new fun()
         以函数方式调用，this指向window对象  fun()
         调用函数对象的call方法，this为传入的对象，testFun.call(obj,'arg1','arg2')
         调用函数对象的apply方法，this为传入的对象 testFun.apply(obj,['arg1','arg2'])
      "
    函数中arguments对象:
      - 解析器会为每个函数隐式传递一个arguments对象
      - "
          function fun1(){
              console.log('@@@@',arguments)
              console.log('传入参数的实际大小',arguments.length)
              console.log('当前函数对象',arguments.callee)
              return arguments.callee
          }

          var fun2 = fun1('eric1','eric2')
          console.log(fun2 === fun1) "
    函数的调用方式:
      - fun(arg1,arg2)
      - fun.call(obj,arg1,arg2)
      - fun.apply(obj,[arg1,arg2])
  作用域:
    功能:
      - 作用域指一个变量或函数变量的作用范围
      - 在函数作用域中可以访问到全局作用域的变量或函数变量，相反则不同
    a=100:
      - 声明变量形式，当全局作用域或者函数作用域不存在变量a，那么等同于 window.a = 100
      - 修改形式，当全局作用域或者函数作用域存在变量a，则是修改函数作用域或者全局作用域的变量a的值
    全局作用域:
      - 编写在<script>标签体内的变量或者函数变量都属于全局作用域
      - 全局作用域在页面开打时候创建，在页面关闭时候销毁
      - 全局作用域中有一个window对象，它代表的是一个浏览器创建，它由浏览器创建，我们可以直接使用
      - 在全局作用域中，用var修饰的变量，会作为window对象的属性保存
      - 在全局作用域中，创建的函数变量，会作为window对象的方法保存
      - 在全局作用域中，声明的变量或者函数变量，在整个页面都可以访问的到
    函数作用域:
      - 在【函数代码块中、函数形参中】声明的【变量、函数变量】属于函数作用域
      - 函数作用域是在函数调用时创建，函数执行完以后销毁
      - 每调用一次函数就会创建一个全新的函数作用域，它们之间是相互独立的。
      - 因为作用域链的存在，很多时候如果想访问全局的变量或变量函数，可以直接通过window对象访问
    作用域链:
      - 当在函数作用域操作一个变量或者函数变量时，它会先在自身的作用域中寻找，如果有就直接使用，如果没有则往上一级函数作用域寻找，直到找到全局作用域位置，如果全局还没找到则报错。
    声明提前:
      功能:
        - 声明提前可以是在函数作用域，或者全局作用域中提前
      变量声明提前:
        - 被var修饰的变量可以声明提前
        - `
          //var修饰的变量会声明提前
          console.log('b 该变量会提前声明到window对象中',b)
          var b = 'eric'; // 等同于window.b，但是该变量会提前声明到window对象中
          `
      函数声明提前:
        - 声明式函数可以声明提前
        - `
          fun2() //由于函数被提前声明，所以可以正常调用
          //正常定义的函数会声明提前
          function fun2(){
          console.log('我是一个函数，而且我会被提前声明')
          }
        `

  原型对象:
    功能:
      - 原型对象可以复用方法或者属性，减少方法或者属性直接绑定到对象实例上。
      - 对象实例会先从对象本身去访问方法或者属性，如果访问不到会去原型上去访问，直到访问到Object类的原型为止
    创建对象方式1:
      - new构造函数
      - "
        此方式可以通过2种方式拿到原型对象
          1. var obj = new MyObject()
             obj.__proto__

             var obj1 = new MyObject()
             obj1.__proto__

          2. MyObject.prototype
        并且它们是同一个原型对象 obj.__proto__ === obj1.__proto__ == MyObject.prototype
      "
      - 此方法创建的原型实际上有2层原型，第一层是类的原型，第二层原型是Object类的原型
    创建对象方式2:
      - var obj = {} 等同于 new Object()
      - "
        此方式只有1种方式拿到原型对象
        var obj = {}
        var obj1 = {}
        var obj2 = {}
        并且它们是同一个原型对象 obj.__proto__ === obj1.__proto__ === obj2.__proto__
      "
      - 此方式创建的原型实际上是在Object类的原型上创建方法或属性
    往Object类原型上添加属性或方法:
      - "
        //方式1
        Object.prototype.name1 = 'eric1'
        //方式2
        new Object().__proto__.name2 = 'eric2'
        //方式3
        var obj1 = {}
        obj1.__proto__.name3 = 'eric3'
        //方式4
        function MyObject(){}
        new MyObject().__proto__.__proto__.name4 = 'eric4'
        //方式5
        MyObject.prototype.__proto__.name5 = 'eric5'

        console.log(Object.prototype)
      "
