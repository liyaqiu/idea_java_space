JS介绍:
  - JavaScript遵循ECMAScript规范
  - 一个完成的JavaScript有3部分组成，ECMAScript、DOM、BOM
  - JavaScript是一门解析型语言，基于原型的面向对象语言
  - js下载 https://www.bootcdn.cn/jquery/
  - 参考文档 https://www.w3cschool.cn/javascript/js-ex-objects.html
  - 参考文档 https://www.w3cschool.cn/jsref/jsref-obj-number.html
初级:
  JS六种数据类型:
    基本(值)数据类型:
      - String
      - Boolean
      - Number
      - Undefined
      - Null
    对象(引用)数据类型:
      - Object
  JS二进制/八进制/十六进制赋值:
    - 八进制 0 或 0o 或 0O
    - 十六进制 0x 或 0X
    - 二进制 0b 或者 0B
  类型转换:
    显示类型转换:
      转换为String:
        - "
          //能调用toString()
          window.console.log('false |',false.toString(),typeof false.toString())
          window.console.log('NaN |',NaN.toString())
          window.console.log('"" |',"".toString())
          window.console.log('true |',true.toString())
          window.console.log('Infinity |',Infinity.toString())
          window.console.log('-Infinity |',-Infinity.toString())
          window.console.log('new Object |',new Object().toString())

          //不能调用toString()
          //window.console.log('null |',null.toString())
          //window.console.log('undefined |',undefined.toString())
          //window.console.log('数值 |',数值.toString())

          console.log('-------------------------------------------------')

          window.console.log('false |',new String(false))
          window.console.log('null |',new String(null))
          window.console.log('NaN |',new String(NaN))
          window.console.log('0 |',new String(0))
          window.console.log('"" |',new String(""))
          window.console.log('undefined |',new String(undefined))
          window.console.log('true |',new String(true))
          window.console.log('Infinity |',new String(Infinity))
          window.console.log('-Infinity |',new String(-Infinity))
          window.console.log('123 |',new String(123))
          window.console.log('-123 |',new String(-123))
          window.console.log('new Object |',new String(new Object))
          window.console.log('hello |',new String('hello'))
      "
      转换为Number: `
        //为0
        window.console.log('false |',new Number(false))
        window.console.log('null |',new Number(null))
        window.console.log('0 |',new Number(0))
        window.console.log('"" |',new Number(""))
        window.console.log('"0" |',new Number("0"))
        window.console.log('-----------------------------------')

        //为1
        window.console.log('true |',new Number(true))
        window.console.log('-----------------------------------')
        //为NaN
        window.console.log('NaN |',new Number(NaN))
        window.console.log('undefined |',new Number(undefined))
        window.console.log('new Object |',new Number(new Object))
        window.console.log('123hello123 |',new Number('123hello123'))
        window.console.log('"true" |',new Number("true"))
        window.console.log('"false" |',new Number("false"))
        window.console.log('-----------------------------------')
        //为Infinity
        window.console.log('Infinity |',new Number(Infinity))
        window.console.log('Infinity |',new Number(-Infinity))
        window.console.log('-----------------------------------')
        //方式2
        //将参数转换为字符串以后进行逐个转换，遇到非数字就停止转换，并10进制方式转换
        window.console.log('parseInt(123.584px)  |',parseInt('123.584px',10))
        window.console.log('parseFloat(123.584px)  |',parseFloat('123.584px',10))
        //返回NaN
        window.console.log('""  |',parseFloat('',10))
      转换为Boolean:
        - "
            //为false
            window.console.log('false |',new Boolean(false))
            window.console.log('null |',new Boolean(null))
            window.console.log('NaN |',new Boolean(NaN))
            window.console.log('0 |',new Boolean(0))
            window.console.log('"" |',new Boolean(""))
            window.console.log('undefined |',new Boolean(undefined))

            //为true
            window.console.log('true |',new Boolean(true))
            window.console.log('Infinity |',new Boolean(Infinity))
            window.console.log('-Infinity |',new Boolean(-Infinity))
            window.console.log('123 |',new Boolean(123))
            window.console.log('-123 |',new Boolean(-123))
            window.console.log('new Object |',new Boolean(new Object))
            window.console.log('hello |',new Boolean('hello'))
      "
    隐式类型转换(运算符):
      先转换为Number类型在运算:
        - 具体如何转，查看类型转换
        - `
          (加+、减-、乘*、除/、取余%)
            正常情况
              会先把非数值型转换为数值型在运算
            特殊情况
              (加+)如果遇到字符串，会将其他非字符串的转换为字符串，然后进行拼接操作
          `
        - (负号-、正号+)
        - `
          (> < ≥ ≤)
          情况1
            将左右两边字面量转化为数值，然后比较，返回true/false，
          情况2
            如果转有任意一边转换为NaN值，则直接返回false
          情况3
            如果两边都为字符串，则比较的是Unicode编码，逐个字符串进行比较，如果第一位比别人的第一位小，则返回，如果相同，则继续比较。
        - `
           (==，!=)
            正常情况
              情况1 数值==数值  数值==字符串 数值==对象
                通过Number()进行转换后成为数值，则可以进行比较，结果为true/false
              情况2 字符串==字符串
                如果两边都为字符串，则比较的是Unicode编码，逐个字符串进行比较
              情况3 对象==对象
                比较基本数据类型是比较值是否一样，比较引用类型是比较地址值是否一样
            特殊情况
              null==undefined，相等
              NaN==任何值，不相等
              NaN==NaN，不相等，可以通过isNaN()函数进行判断
          `
        - `
          (===，!==) 次比较不会做类型转换，直接返回true/false
            正常情况
              比较类型，如果类型不等直接就不相等，如果类型相等，在比较字面量
            特殊情况
            null===undefined，不相等
            NaN===任何值，不相等
            NaN===NaN，不相等，可以通过isNaN()函数进行判断
          `
      先转换为Boolean类型在运算:
        - 具体如何转，查看类型转换
        - (非!、或||、与&&)
        - (三目运算符?:)
  运算符:
    短路与(短路与的true是返回右边):
      - 只拿左边第一个进行boolean转换，如果true，返回右边的，右边是啥类型返回啥类型
      - 只拿左边第一个进行boolean转换，如果false，返回左边的，左边是啥类型返回啥类型
      - `
        //只拿左边第一个进行boolean转换，如果true，返回右边的，右边是啥类型返回啥类型
        console.log('true&&false |',true&&false,'| ',typeof (true&&false))
        console.log('true&&11 |',true&&11,'| ',typeof (true&&11))
        console.log('true&&NaN |',true&&NaN,'| ',typeof (true&&NaN))
        console.log('true&&undefined |',true&&undefined,'| ',typeof (true&&undefined))
        console.log('true&&Infinity |',true&&Infinity,'| ',typeof (true&&Infinity))
        console.log('true&&`hello" |',true&&"hello",'| ',typeof (true&&"11"))
        console.log('true&&new Object() |',true&&new Object(),'| ',typeof (true&&new Object()))
        //console.log('true&&alert(1)" |',true&&alert(1),'| ',typeof (true&&alert(1)))

        console.log('-------------------------------------------')
        //为true
        /* window.console.log('true |',Boolean(true))
        window.console.log('Infinity |',Boolean(Infinity))
        window.console.log('-Infinity |',Boolean(-Infinity))
        window.console.log('123 |',Boolean(123))
        window.console.log('-123 |',Boolean(-123))
        window.console.log('new Object |',Boolean(new Object))
        window.console.log('hello |',Boolean('hello')) */
        console.log('Infinity&&返回我 |',Infinity&&'返回我','| ',typeof (Infinity&&'返回我'))
        console.log('-Infinity&&返回我 |',-Infinity&&'返回我','| ',typeof (-Infinity&&'返回我'))
        console.log('123&&返回我 |',123&&'返回我','| ',typeof (123&&'返回我'))
        console.log('-123&&返回我 |',-123&&'返回我','| ',typeof (-123&&'返回我'))
        console.log('new Object()&&返回我 |',new Object()&&'返回我','| ',typeof (new Object()&&'返回我'))
        console.log('"hello"&&返回我 |',"hello"&&'返回我','| ',typeof ("hello"&&'返回我'))

        console.log('-------------------------------------------')
        /* //为false
        window.console.log('false |',Boolean(false))
        window.console.log('null |',Boolean(null))
        window.console.log('NaN |',Boolean(NaN))
        window.console.log('0 |',Boolean(0))
        window.console.log('"" |',Boolean(""))
        window.console.log('undefined |',Boolean(undefined)) */
        //只拿左边第一个进行boolean转换，如果false，返回左边的，左边是啥类型返回啥类型
        console.log('false&&返回我 |',false&&'返回我','| ',typeof (false&&'返回我'))
        console.log('null&&返回我 |',null&&'返回我','| ',typeof (null&&'返回我'))
        console.log('NaN&&返回我 |',NaN&&'返回我','| ',typeof (NaN&&'返回我'))
        console.log('""&&返回我 |',""&&'返回我','| ',typeof (""&&'返回我'))
        console.log('undefined&&返回我 |',undefined&&'返回我','| ',typeof (undefined&&'返回我'))
        `
    短路或:
      - 只拿左边第一个进行boolean转换，如果true，返回左边的，左边是啥类型返回啥类型
      - 只拿左边第一个进行boolean转换，如果false，返回右边的，右边是啥类型返回啥类型
      - `
        //只拿左边第一个进行boolean转换，如果true，返回左边的，左边是啥类型返回啥类型
        //为true
        /* window.console.log('true |',Boolean(true))
        window.console.log('Infinity |',Boolean(Infinity))
        window.console.log('-Infinity |',Boolean(-Infinity))
        window.console.log('123 |',Boolean(123))
        window.console.log('-123 |',Boolean(-123))
        window.console.log('new Object |',Boolean(new Object))
        window.console.log('hello |',Boolean('hello')) */
        console.log('true||返回我 |',true||'返回我','| ',typeof (true||'返回我'))
        console.log('Infinity||返回我 |',Infinity||'返回我','| ',typeof (Infinity||'返回我'))
        console.log('-Infinity||返回我 |',-Infinity||'返回我','| ',typeof (-Infinity||'返回我'))
        console.log('123||返回我 |',123||'返回我','| ',typeof (123||'返回我'))
        console.log('-123||返回我 |',-123||'返回我','| ',typeof (-123||'返回我'))
        console.log('new Object()||返回我 |',new Object()||'返回我','| ',typeof (new Object()||'返回我'))
        console.log('"hello"||返回我 |',"hello"||'返回我','| ',typeof ("hello"||'返回我'))

        console.log('-------------------------------------------')

        //只拿左边第一个进行boolean转换，如果false，返回右边的，右边是啥类型返回啥类型
        console.log('false||false |',false||false,'| ',typeof (false||false))
        console.log('false||11 |',false||11,'| ',typeof (false||11))
        console.log('false||NaN |',false||NaN,'| ',typeof (false||NaN))
        console.log('false||undefined |',false||undefined,'| ',typeof (false||undefined))
        console.log('false||Infinity |',false||Infinity,'| ',typeof (false||Infinity))
        console.log('false||"hello" |',false||"hello",'| ',typeof (false||"11"))
        console.log('false||new Object() |',false||new Object(),'| ',typeof (false||new Object()))
        //console.log('false||alert(1)" |',false||alert(1),'| ',typeof (false||alert(1)))
        console.log('-------------------------------------------')
        /* //为false
        window.console.log('false |',Boolean(false))
        window.console.log('null |',Boolean(null))
        window.console.log('NaN |',Boolean(NaN))
        window.console.log('0 |',Boolean(0))
        window.console.log('"" |',Boolean(""))
        window.console.log('undefined |',Boolean(undefined)) */
        console.log('false||返回我 |',false||'返回我','| ',typeof (false||'返回我'))
        console.log('null||null |',null||'返回我','| ',typeof (null||null))
        console.log('NaN||返回我 |',NaN||'返回我','| ',typeof (NaN||'返回我'))
        console.log('""||返回我 |',""||'返回我','| ',typeof (""||'返回我'))
        console.log('undefined||返回我 |',undefined||'返回我','| ',typeof (undefined||'返回我'))
        `
    非:
      - 将某个类型数据进行boolean转换，如果为true返回true，如果为false返回false
      - `
        /*
        //为false
        window.console.log('false |',Boolean(false))
        window.console.log('null |',Boolean(null))
        window.console.log('NaN |',Boolean(NaN))
        window.console.log('0 |',Boolean(0))
        window.console.log('"" |',Boolean(""))
        window.console.log('undefined |',Boolean(undefined))
        */
        console.log('!false |',!false,'| ',typeof (!false))
        console.log('!null |',!null,'| ',typeof (!null))
        console.log('!NaN |',!NaN,'| ',typeof (!NaN))
        console.log('!0 |',!0,'| ',typeof (!0))
        console.log('!"" |',!"",'| ',typeof (!""))
        console.log('!undefined |',!undefined,'| ',typeof (!undefined))

        console.log("------------------------------------------")
        /*
        //为true
        window.console.log('true |',Boolean(true))
        window.console.log('Infinity |',Boolean(Infinity))
        window.console.log('-Infinity |',Boolean(-Infinity))
        window.console.log('123 |',Boolean(123))
        window.console.log('-123 |',Boolean(-123))
        window.console.log('new Object |',Boolean(new Object))
        window.console.log('hello |',Boolean('hello'))  */

        console.log('!true |',!true,'| ',typeof (!true))
        console.log('!Infinity |',!Infinity,'| ',typeof (!Infinity))
        console.log('!-Infinity |',!-Infinity,'| ',typeof (!-Infinity))
        console.log('!123 |',!123,'| ',typeof (!123))
        console.log('!-123 |',!-123,'| ',typeof (!-123))
        console.log('!new Object() |',!new Object(),'| ',typeof (!new Object()))
        console.log('!"hello" |',!'hello','| ',typeof (!'hello'))
        `
  单纯代码块: 在js中单纯的代码块{}只具有分组的作用，没有其他的用途，在代码块中的代码，在外部是完全可见的
  条件语句:
    if:
      - if表达式的值，只能是【布尔类型】，也就是说不管是什么类型，但最后都会隐式转换为布尔类型
    switch:
      - switch和case表达式的值可以为【任意类型值】
      - js的switch语句支持双表达式写法
      - switch语句，会拿表达式的值和case(字面量、表达式的值)进行[全等(===)比较]
  循环语句:
    whlie:
      - whlie表达式的值，只能是【布尔类型】，也就是说不管是什么类型，但最后都会隐式转换为布尔类型
    do-while:
      - do-while表达式的值，只能是【布尔类型】，也就是说不管是什么类型，但最后都会隐式转换为布尔类型
    for:
      方式1:
        - for(var i;i<10;i++){}
        - for(初始表达式;条件表达式;更新表达式)
        - 条件表达式的值，只能是【布尔类型】，也就是说不管是什么类型，但最后都会隐式转换为布尔类型
      方式2:
        - for(var attr in obj){}
        - 枚举对象中的属性
  break和continue关键字:
    break:
      - 只能用在swtich和循环语句
      - 用法1 break 默认情况下终止当前循环体
      - 用法2 break forName 可以终止该循环体以及外层所有循环体，并且终止
      - "
          //给循环起名字
          forName:
          for(var i=0;i<3;i++){
              console.log(i)
              forName1:
              for(var c=0;c<3;c++){
                  console.log(c)
                  for(var j=0;j<3;j++){
                      console.log(j)
                      break forName;
                  }
              }
              console.log('----------------------')
          }

          whileName:
          while(true){
              console.log(1)
              whileName1:
              while(true){
                  console.log(2)
                  break whileName;
              }
          }
      "
    continue:
      - 只能用在循环语句
      - 用法1 continue 默认情况下终止当前循环体
      - 用法2 continue forName 可以跳过该循环体以及外层所有循环体，进行下一次执行。
      - "
        //给循环起名字
        forName:
        for(var i=0;i<3;i++){
            console.log(i)
            forName1:
            for(var c=0;c<3;c++){
                console.log(c)
                for(var j=0;j<3;j++){
                    console.log(j)
                    continue forName;
                }
            }
            console.log('----------------------')
        }
      "
  3个快捷方式创建对象:
    - var a = {} 创建普通对象
    - var a = [] 创建数组对象
    - var a = /正则表达式/匹配模式 创建正则表达式对象
中级:
  对象:
    对象分类:
      内建对象:
        - 由ECMAScript标准中定义的对象，在任何的ECMAScript的实现中都可以使用
        - 比如 Array Math Date String Number Boolean Function RegExp Object..
      宿主对象:
        - 由JS的运行环境提供的对象，目前来讲主要指浏览器提供的对象
        - DOM(文档对象模型)，主要操作标签元素,document
        - BOM(浏览器对象模型)，主要操作浏览器，Window、Navigator、Location、History、Screen
      自定义对象:
        - 由开发人员自己创建的对象
    对象的创建:
      方式1:
        - 利用构造函数来创建对象
        - `
          function MyObject(){
          this.age = 18,
          this.sex = '男',
          this["tip"] = 'hello-world',
          this[1<2] = 'true'
          }
          obj = new MyObject()
          obj.name = 'eric'
          console.log(obj,typeof obj)
          `
      方式2:
        - 利用【{}】来创建
        - "
            var tip = 'hello-world'
            obj = {
                age:18,
                'sex': '男',
                tip
            }
            obj.name = 'eric'
            obj[1<2] = 'false'
            console.log(obj,typeof obj)
          "
    对象的属性:
      功能:
        - 对象的属性可以是任意的命名方式，不需要遵守标识符规范，例如obj.null ,obj.undefine
        - 操作对象的属性可以使用【点方式或者['']方式】进行操作
      检查属性:
        - console.log("attr" in obj/Object) 可以检查一个对象(对象本身+原型对象)是否含有该属性，有则返回true，没有返回false
        - obj/Object.hasOwnProperty('attr') 可以检查一个对象(对象本身)是否含有该属性，有则返回true，没有返回false
        - for(var attr in obj/Object){} 枚举对象中的属性或方法
      对象的属性值:
        - 对象的属性值可以是(基本数据类型、对象类型、函数类型)的值
        - 如果一个对象的属性值是函数，那么这个属性称为【方法】
      属性操作:
        功能:
          - 访问一个对象中的属性，如果不存在不会报错，而且会返回undefined。
        方式1:
          - 增 obj.name = 18
          - 删 delete obj.name
          - 改 obj.name = 19
          - 查 obj.name
        方式2(非常灵活):
          - [ '' ]方式，
          - 可以定义一些另类的属性，比如 obj['123'] = 1000
          - 可以存放，任意类型变量、字符串、表达式，但最终都会隐式转换为字符串类型
          - 增 obj['sex'] = '男'
          - 删 delete obj['sex']
          - 改 obj['sex'] = 20
          - 查 obj['sex']
  函数:
    功能:
      - 函数也是一个对象，而且它是一个特殊对象，可以保存代码块和属性
      - 调用函数语法 = 函数对象()
      - 在调用函数时，解析器不会检查实际参数的类型以及实际参数的个数
      - 函数的(形参、实参、返回值)可以是(基本数据类型、对象类型、函数类型)
    创建函数:
      方式1:
        - 通过函数对象创建函数，并将想要封装的代码以字符串的方式传递给构造函数
        - `
          写法1
            new Function("console.log('我的第1个函数')")();
          写法2
            //存放函数引用地址的变量fun，调用函数fun()
            var fun = new Function("console.log('我的第2个函数');");
            fun()
            console.log(fun,typeof fun)
          `
      方式2:
        - `
          通过eval函数执行js字符串代码
            function hello(){console.log('我的第3个函数');}
            var result = window.eval("hello()")
          `
      方式3:
        - 通过function来创建函数
        - `
          写法1-声明式
          //存放函数引用地址的变量fun1，调用函数fun1()
            function fun1(){
            console.log('我的第3个函数');
            }
            fun1();
            //console.log(fun1,typeof fun1)
          写法2-表达式
          //存放函数引用地址的变量fun2，调用函数fun2()
            var fun2 = function(){
            console.log('我的第4个函数');
            }
            fun2();
            //console.log(fun2,typeof fun2)
          `
      方式4:
        - `
          //创建立即执行函数，匿名函数自调用，IIFE(Immediately-Invoked Function Expression)
          //需要注意的是加上分号【;】，防止被解析时，误以为是跟前面代码连接起来
            ;(function(name){
            console.log(name,'我的第5个函数');
            })('eric')
          `
    构造函数:
      功能:
        - 构造函数和普通函数的一模一样，唯独就是取名方式不一样，普通函数首字母为小写，构造函数首字母为大写
        - 构造函数需要使用new关键字来调用
        - 使用同一个构造函数创建的对象，我们成为一类对象，也将一个构造函数成为一个类，该构造函数创建出来的对象，我们成为该类的实例对象
        - 通过 instanceof  来判断一个类实例是否属于该类
      构造函数执行流程:
        - 1.立刻创建一个新的对象
        - 2.将新的对象设置为函数中的this，在构造函数中可以使用this来引用新建对象
        - 3.逐行执行函数中的代码
        - 4.将新建的对象作为返回值返回
      构造函数之java转换:
        - 其实构造函数可以看成一个java类
        - Demefun.attr  为一个类添加方法
        - new Demefun().attr 为一个对象添加方法
    函数中this对象:
      - 解析器会为每个函数隐式传递一个this对象
      - 根据函数的调用方式不同this指向不同
      - "
         以方法方式调用，this指向的是当前对象  obj.fun()
         以new方式调用，this指向的是当前对象  new fun()
         以函数方式调用，this指向window对象  fun()
         调用函数对象的call方法，this为传入的对象，testFun.call(obj,'arg1','arg2')
         调用函数对象的apply方法，this为传入的对象 testFun.apply(obj,['arg1','arg2'])
      "
    函数中的this对象之调用者改变:
      - "
        //假设如下代码为框架代码，我们不能去修改
         function Vue(fun){
              fun()
         }

         //用户使用框架代码
         //方式1
           /* function myFun(){
                console.log(this) //window
           }
            new Vue(myFun) */
         //方式2
           function myFun(){
                console.log(this) //当前对象
           }

           var obj = {}
           new Vue(function(){
                myFun.apply(obj) //改变了myFun函数的调用方式
           })
      "
    函数中arguments对象:
      - 解析器会为每个函数隐式传递一个arguments对象
      - "
          function fun1(){
              console.log('@@@@',arguments)
              console.log('传入参数的实际大小',arguments.length)
              console.log('当前函数对象',arguments.callee)
              return arguments.callee
          }

          var fun2 = fun1('eric1','eric2')
          console.log(fun2 === fun1) "
    函数的调用方式:
      - fun(arg1,arg2)
      - fun.call(obj,arg1,arg2)
      - fun.apply(obj,[arg1,arg2])
  作用域:
    功能:
      - 作用域指一个变量或函数变量的作用范围
      - 在函数作用域中可以访问到全局作用域的变量或函数变量，相反则不同
    a=100:
      - 声明变量形式，当全局作用域或者函数作用域不存在变量a，那么等同于 window.a = 100
      - 修改形式，当全局作用域或者函数作用域存在变量a，则是修改函数作用域或者全局作用域的变量a的值
    全局作用域:
      - 编写在<script>标签体内的变量或者函数变量都属于全局作用域
      - 全局作用域在页面开打时候创建，在页面关闭时候销毁
      - 全局作用域中有一个window对象，它代表的是一个浏览器创建，它由浏览器创建，我们可以直接使用
      - 在全局作用域中，用var修饰的变量，会作为window对象的属性保存
      - 在全局作用域中，创建的函数变量，会作为window对象的方法保存
      - 在全局作用域中，声明的变量或者函数变量，在整个页面都可以访问的到
    函数作用域:
      - 在【函数代码块中、函数形参中】声明的【变量、函数变量】属于函数作用域
      - 函数作用域是在函数调用时创建，函数执行完以后销毁
      - 每调用一次函数就会创建一个全新的函数作用域，它们之间是相互独立的。
      - 因为作用域链的存在，很多时候如果想访问全局的变量或变量函数，可以直接通过window对象访问
    作用域链:
      - 当在函数作用域操作一个变量或者函数变量时，它会先在自身的作用域中寻找，如果有就直接使用，如果没有则往上一级函数作用域寻找，直到找到全局作用域位置，如果全局还没找到则报错。
    声明提前:
      功能:
        - 声明提前可以是在函数作用域，或者全局作用域中提前
      变量声明提前:
        - 被var修饰的变量可以声明提前
        - `
          //var修饰的变量会声明提前
          console.log('b 该变量会提前声明到window对象中',b)
          var b = 'eric'; // 等同于window.b，但是该变量会提前声明到window对象中
          `
      函数声明提前:
        - 声明式函数可以声明提前
        - `
          fun2() //由于函数被提前声明，所以可以正常调用
          //正常定义的函数会声明提前
          function fun2(){
          console.log('我是一个函数，而且我会被提前声明')
          }
        `
  原型对象:
    功能:
      - 原型对象可以复用方法或者属性，减少方法或者属性直接绑定到对象实例上。
    原型链(隐式原型链):
      - 实例对象会先从对象本身去访问方法或者属性，如果访问不到会去原型上去访问，直到访问到Object类的原型为止
    创建对象方式1:
      - new构造函数
      - "
        此方式可以通过2种方式拿到原型对象
          1. var obj = new MyObject()
             obj.__proto__

             var obj1 = new MyObject()
             obj1.__proto__

          2. MyObject.prototype
        并且它们是同一个原型对象 obj.__proto__ === obj1.__proto__ == MyObject.prototype
      "
      - 此方法创建的原型实际上有2层原型，第一层是类的原型，第二层原型是Object类的原型
    创建对象方式2:
      - var obj = {} 等同于 new Object()
      - "
        此方式只有1种方式拿到原型对象
        var obj = {}
        var obj1 = {}
        var obj2 = {}
        并且它们是同一个原型对象 obj.__proto__ === obj1.__proto__ === obj2.__proto__
      "
      - 此方式创建的原型实际上是在Object类的原型上创建方法或属性
    往Object类原型上添加属性或方法:
      - "
        //方式1
        Object.prototype.name1 = 'eric1'
        //方式2
        new Object().__proto__.name2 = 'eric2'
        //方式3
        var obj1 = {}
        obj1.__proto__.name3 = 'eric3'
        //方式4
        function MyObject(){}
        new MyObject().__proto__.__proto__.name4 = 'eric4'
        //方式5
        MyObject.prototype.__proto__.name5 = 'eric5'

        console.log(Object.prototype)
      "
  自动装箱和拆箱:
    - 3个包装类型 String Number Boolean
    - 基本数据类型一旦调用了方法，解析器会自动帮我们做自动装箱工作，然后调用方法
    - "
      例如装箱
        var a = 123
        a.toString() 实际上是先进行装箱然后在嗲用new Number(123).toString()
      例如拆箱
        var a = 123
        var b = new Number(456)
        var c = a+b  实际上这里会对b进行拆箱操作。b.valueOf()，然后在进行运算
    "
  正则表达式:
    - 写正则表达式的时候记得拆分来写，最后在合并起来即可。
    - "
      例如 361234567@qq.com
      可以拆分为
       361234567 正则表达式 \w+
       @         正则表达式 @
       qq        正则表达式 [a-z]{2}
       .         正则表达式 \.
       com       正则表达式 [a-z]{2,3}
      合并正则表达式 /\w+@[a-z]{2}\.[a-z]{2,3}/
      最后在把完全匹配写上即可 /^\w+@[a-z]{2}\.[a-z]{2,3}$/
    "
    - "
         https://www.w3cschool.cn/jsref/jsref-obj-regexp.html
         https://www.bilibili.com/video/BV1p4411u7TT?p=90
         i(ignore) - 修饰符是用来执行不区分大小写的匹配。
         g(global) - 修饰符是用于执行全文的搜索（而不是在找到第一个就停止查找,而是找到所有的匹配）。

        //检查一个字符串是否含有3个a
        //console.log('/aaa/ ',/aaa/.test('111aaa2222'))


        //检查一个字符串是否含有3个a
        //console.log('/aaa/ ',/aaa/.test('111aaa2222'))


        //  /a{3}/         a出现3次
        //  /ab{3}/        a出现1次，b出现3次
        //  /(ab){3}/      ab出现3次
        //  /ab{3}c/       a出现1次，b出现3次，c出现1次
        //  /ab{1,3}c/     a出现1次，b出现1-3次，c出现1次
        //  /ab{3,}c/      a出现1次，b出现3次及以上，c出现1次

        //  /ab+c/         a出现1次，b出现1次及以上，c出现1次
        //  /ab*c/         a出现1次，b出现0次及以上，c出现1次
        //  /ab?c/         a出现1次，b出现0次或1次，c出现1次

        //  /^abc/         a开头，并且a出现1次，b出现1次，c出现1次
        //  /^a+bc/        a开头，并且a出现1次及以上，b出现1次，c出现1次

        //  /abc$/         a出现1次，b出现1次，c出现1次并且c结尾
        //  /abc+$/        a出现1次，b出现1次，c出现1次并且c结尾

        //  /a|b|c/        有a。或有b，或有c
        //  /^a|b|c$/      有a开头。或有b，或有c结尾
        //  /^a|b|c{3,}$/  有a开头，或者有b，或者有c结尾，并且c出现3次及以上

        //  /a.{1}b/        a出现1次，任意字符出现1次，b出现一次

        //  \. 代表.   /a\.{1}b/   a出现1次，.出现1次，b出现一次
        //  \\ 代表\
        //  \/ 代表/
        //  \d 代表[0-9]
        //  \D 代表[^0-9]
        //  \w 代表[A-z0-9_]
        //  \W 代表[^A-z0-9_]
        //  \s 空格
        //  \S 除了空格
        //  \b 单词边界 /\bhello\b/  //console.log(/\bhello\b/.test('qweqwe%@#￥@%……&hello!qweq'))

        //  /^[^abc]{3}&/  出现非abc的字符3次

        // 去除前面所有空格以及后面所有空间
        // /^\s*|\s*$/g
        //console.log('         hello  world          '.replace(/^\s*|\s*$/g,''))

        // 手机号
        // /^1[3-8][0-9]{9}$/  (1位)1开头，(2位)3-8之间，(3-9位)任意数字
        //console.log(/^1[3-8][0-9]{9}$/.test('18813664703'))

        //检查一个邮箱是否合法
        // 36123456@qq.com
        // /^[0-9A-z]{5,9}@[a-z]{2}\.com$/  //默认情况下 .代表任意字符
        //console.log(/^[0-9A-z]{5,9}@[a-z]{2}\.com$/.test('12345@qq.com'))
    "
  取消默认行为: 一般可以用return false
  DOM对象:
    功能:
      - DOM Document Object Model 文档对象模型
      - window.document对象
    节点对象:
      - 文档节点对象(nodeName=#document  nodeType=9 nodeVaule=null)
      - 元素节点对象(nodeName=标签名      nodeType=1 nodeVaule=null)
      - 属性节点对象(nodeName=属性名      nodeType=2 nodeVaule=属性值)
      - 文本节点对象(nodeName=#text      nodeType=3 nodeVaule=文本内容)
    修改和读取元素样式:
      - "
        //修改样式方式1，根据元素属性来更改样式
        //document.getElementById('addbt').className = 'btclass1'

        //修改样式方式2，修改元素内联样式
        //document.getElementById('addbt').style.fontSize = '20px'

        //读取样式方式1，根据内联样式读取
        //console.log(document.getElementById('addbt').style.fontSize)

        //读取样式方式2，获取该元素最终生效的样式，该对象是只读的，不允许修改
        //console.log(document.getElementById('addbt').currentStyle.width) 只有ie浏览器支持
        //console.log(window.getComputedStyle(document.getElementById('addbt'),null).width) 非ie都支持
      "
    事件:
      事件对象:
        - 每元素绑定事件以后，当浏览器调用改事件函数的时候会传递事件对象到函数里面(event)
      事件冒泡:
        功能:
          - 每个元素都会有默认事件函数，所以当对某个函数触发相应的事件时，都会有冒泡的产生。如果需要该元素不支持冒泡，可以使用event.cancelBubble = true; 停止冒泡
          - 所谓的冒泡值的就是事件的向上传导，当后代元素上的时间被触发时，其所有的父元素相同的事件都会被触发。
        事件委派:
          - 利用冒泡原理来实现事件的委派
          - 当很多子元素需要绑定事件时，可以考虑把时间绑定在它的父元素标签中。
      事件传播:
        捕获阶段:
          - 在捕获阶段时，从最外层的祖先元素开始(document|window)，向目标元素进行事件的捕获
          - 使用document.getElementById('div1').addEventListener('click',function(event){},true)
        冒泡阶段:
          - 时间从目标元素向祖先元素传递，依次触发祖先元素上的事件
          - 使用document.getElementById('div1').onclick
          - 使用document.getElementById('div1').addEventListener('click',function(event){},false)
        ie8及以前:
          - 冒泡阶段(由目标元素向祖先元素传递事件)
        ie9及以后+其他浏览器:
          - 捕获阶段(由祖先元素向目标元素触发事件)
          - 冒泡阶段(由目标元素向祖先元素传递事件)
    元素绑定事件方式:
      - "
        方式1
          document.getElementById('div1').onclick = function(event){
                if(!event){
                    event = window.event //ie8及以下的event对象是在window身上
                }
                console.log(000)
           }
         方式2
           document.getElementById('div1').addEventListener('click',function(event){
                if(!event){
                    event = window.event //ie8及以下的event对象是在window身上
                }
                console.log(111)
           },false)

           //参数1 不要写onclick
           //参数2 回调函数
           //参数3 true捕获阶段触发，false冒泡阶段触发
           document.getElementById('div1').addEventListener('click',function(event){
                if(!event){
                    event = window.event //ie8及以下的event对象是在window身上
                }
                console.log(222)
           },false)
           //document.getElementById('div1').attachEvent('onclick',function(){})   ie8及以前
      "
  BOM对象:
    Window:
      - 代表的是整个浏览器的窗口，同时window也是网页中的全局对象
      - 获取对象方式 window
    Navigator:
      - 代表的是当前浏览器的信息，通过该对象可以识别不同的浏览器
      - 获取对象方式 window.navigator
    Location:
      - 代表当前浏览器的地址栏信息，可以通过location对象获取地址栏信息，或者操作浏览器跳转页面
      - 获取对象方式 window.location
    History:
      - 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录
      - 由于隐私原因，该对象不能获取到具体的历史记录，只能是操作浏览器向前或者向后翻页，并且历史记录只有在当次访问有效
      - 获取对象方式 window.history
    Screen:
      - 代表用户的屏幕信息，通过该多少可以获取到用户的显示器相关信息
      - 获取对象方式 window.screen
  JSON对象: `
        JSON(JavaScript Object Notation) JS对象表示法
        JSON和JS对象的格式一样，只不过JSON的属性名必须是加【双引号】

        JSON分类
          1.对象{}字符串
          2.数组[]字符串
        JSON属性值
          1.字符串
          2.数值
          3.布尔值
          4.null
          5.普通对象
          6.数组对象

        //分类1
          var jsonStrObj = '{"name":"eric","age":16,"isMen":true,"hobbies":["打球","打游戏","踢球"],"friends":[{"name":"jerry","age":16,"family":null},{"name":"tom","age":18,"family":null}]}'
          var jsObj = JSON.parse(jsonStrObj)
          console.log(jsObj)
          var jsonStr = JSON.stringify(jsObj)
          console.log(jsonStr)
        //分类2
          /* var jsonStrArr = '["eric",{"hobbies":["打球","打游戏","踢球"]}]'
          var jsArr = JSON.parse(jsonStrArr)
          console.log(jsArr) */

        //ie7及以下没有JSON对象，可以引入json2.js，eval函数有安全隐患
          var jsonStrObj = '{"name":"eric","age":16,"isMen":true,"hobbies":["打球","打游戏","踢球"],"friends":[{"name":"jerry","age":16,"family":null},{"name":"tom","age":18,"family":null}]}'
          /* //JSON 转换 JS对象
          var jsObj = window.eval("("+jsonStrObj+")")
          console.log(jsObj)
          //JS对象转JSON
          var jsonStr = JSON.stringify(jsObj)
          console.log(jsonStr) */
      `
高级:
  强制加分号的情况:
    - `
      /*
      情况1 不加分号会被误认为
        var a = 12(function(){consloe.log(1)})
        */
        var a = 12
        ;(function (){
        console.log(1)
        })()
      /*
      情况2  不加分号会被误认为
        var b = 12[1,3].forEach(element => {console.log(1)});
        */
        var b = 12
        ;[1,3].forEach(element => {
        console.log(1)
      })
      `
  获取类模版实例对象: `
      总结，
        1.函数中的arguments中的callee
        2.原型对象上的constructor属性
        3.函数名
    function Person(){
      //方式1 arguments.callee
        console.log(Person === arguments.callee)
    }
    Person()

    //方式2 Person.prototype.constructor
      console.log(Person === Person.prototype.constructor)

    //方式3 Person
      console.log(Person === Person.prototype.constructor)

    //方式4
      console.log(Person === new Person().__proto__.constructor) `
