块作用域:
  - 比如{},for{},while{},if{},switch{}
  - let和const定义的变量都有块作用域
let:
  - let在同一作用域(包括快作用域)下不能重复定义
  - let在全局作用域下定义变量不会作为window的属性存在，并且不会污染window全局变量
  - let对块作用域有效
  - let不存在变量提升
const:
  - const在同一作用域(包括快作用域)下不能重复定义
  - const在全局作用域下定义变量不会作为window的属性存在，并且不会污染window全局变量
  - const对块作用域有效
  - const不存在变量提升
  - const需要赋予初始值,并且不允许修改
解构赋值:
  功能:
    - 与声明关键字无关(var const let)，任何定义变量的关键字都可以使用来进行解构
    - 对象可以使用{}进行解构，数组可以使用[]进行解构
  数组解构赋值:
    - "
      //案例1
      /* var arr = ['eric','Tom','Jerry']
      let [name1,name2,name3,name4] = arr */
      //案例2
      /* var arr = ['eric','Tom','Jerry']
      const [name1,name2,name3,name4] = arr */
      //案例3
      /* let arr = ['eric','Tom','Jerry']
      const [name1,name2,name3,name4] = arr */
      //案例4
      const arr = ['eric','Tom','Jerry']
      let [name1,name2,name3,name4] = arr
      console.log(name1,name2,name4)
    "
  对象解构赋值:
    - "
      //案例1
      /* var obj = {
          name:'eric',
          age:16,
          fun:function(){}
      }
      var {name,age,fun,hello} = obj
      console.log(name,age,fun,hello) */
      //案例2
      /* const obj = {
          name:'eric',
          age:16,
          fun:function(){}
      }
      let {name,age,fun,hello} = obj
      console.log(name,age,fun,hello) */
      //案例3
      /* let obj = {
          name:'eric',
          age:16,
          fun:function(){}
      }
      var {name,age,fun,hello} = obj
      console.log(name,age,fun,hello) */
      //案例4
        function fun({name,age,sex}){
            console.log(name,age,sex)
        }
        fun({
            name:'eric',
            age:16,
            sex:'男'
        })
      //案例5
       function fun([el0,el1,el2=10]){
           console.log(el0,el1,el2)
       }
       fun([1,2])
    "
模版字符串:
  - 支持换行拼接
  - 支持表达式拼接，使用${}
  - "
    var name = 'eric'
    var age = 18
    var obj = {
        sex:'男'
    }
    const str = `
        名字是:${name},年龄:${age},性别:${obj.sex}
    `
    console.log(str)
  "
简化对象赋值和对象方法声明:
  - "
    let name = 'eric'
    let fun = function(){}

    //写法1
    const obj1 = {
        'name':name,
        'fun':fun,
        'fun1':function(){}
    }
    console.log(obj1)

    //写法2
    const obj2 = {
        name:name,
        fun:fun,
        fun1:function(){}
    }
    console.log(obj2)

    //写法3
    const obj3 = {
        name,
        fun,
        fun1(){}
    }
    console.log(obj3)
  "
箭头函数:
  功能:
    - 箭头函数没有this，使用任何方式都不能改变this指向
    - 在箭头函数中使用this,这个this始终指向作用域链的this
    - 不能使用new实例化
    - 箭头函数没有arguments
  案例:
    - "
        //案例1
        /* const fun = () =>{
            console.log(1)
        }
        console.log(fun.__proto__ === fun.__proto__.constructor.prototype)
        console.log(fun.__proto__.constructor.__proto__ == Function.prototype) */

        //案例2
        /* var obj = {
            fun:()=>{
                console.log(this)
            },
            fun1(){
                return ()=>{
                    console.log(this)
                }
            }
        }
        obj.fun()
        obj.fun1()() */

        //案例3，简写方式，和Java很像
        /* var fun1 = x => x+x;
        var fun2 = (x,y) => x+y;
        var fun2 = (x,y) => {
            console.log(x,y)
            return x+y;
        }; */
    "
给参赋默认值:
  - "
    //案例1，给解构对象赋默认值
     /* var obj={
      name:'eric',
      age:28
     }

     var {name,age=19,sex='男'} = obj
     console.log(name,age,sex) */

     //案例2，函数形参赋默认值
     /* function fun(name,age,sex='男'){
      console.log(name,age,sex)
     }
     fun('eric',30) */

     //案例3，函数形参的解构对象赋默认值
     /* function fun1({name,age,sex='男'}){
      console.log(name,age,sex)
     }
     fun1({
      name:'eric',
      age:31
      }) */

      //案例4
      function fun2([el0,el1,el2=10]){
          console.log(el0,el1,el2)
      }
      fun2([1,2])
  "
可变参数:
  - "
    function fun(x,y,{name,age,sex='男'},... args){
        console.log(arguments)
        console.log(x,y,name,age,sex,args)
    }

    fun(1,2,{name:'eric',age:29},3,4)
  "
数组参数拆分:
  - "
    //案例1，对数组进行拆分
    function fun(){
        console.log(arguments)
    }

    const arr = [0,1,2]
    fun(...arr)

    //案例2,实现浅拷贝
    const arr1 = [0,1,2]
    const arr2 = [3,4,5]
    const arr3 = [...arr1,...arr2]
    console.log(arr3)

    //案例3，维数组转换为真数组
    function fun4(){
        let arr = [...arguments]
        console.log(arr)
    }
    fun4(arr,1,2,3)
  "