对象分类:
  内建对象:
    - 由ECMAScript标准中定义的对象，在任何的ECMAScript的实现中都可以使用
    - 比如 Math String Number Boolean Function Object..
  宿主对象:
    - 由JS的运行环境提供的对象，目前来讲主要指浏览器提供的对象
    - 比如 BOM DOM
  自定义对象:
    - 由开发人员自己创建的对象
对象:
  对象的创建:
    方式1:
      - 利用构造函数来创建对象
      - `
          function MyObject(){
            this.age = 18,
            this.sex = '男',
            this["tip"] = 'hello-world',
            this[1<2] = 'true'
          }
          obj = new MyObject()
          obj.name = 'eric'
          console.log(obj,typeof obj)
        `
    方式2:
      - 利用【{}】来创建
      - "
          var tip = 'hello-world'
          obj = {
              age:18,
              'sex': '男',
              tip
          }
          obj.name = 'eric'
          obj[1<2] = 'false'
          console.log(obj,typeof obj)
        "
  对象的属性:
    功能:
      - 对象的属性可以是任意的命名方式，不需要遵守标识符规范，例如obj.null ,obj.undefine
      - 操作对象的属性可以使用【点方式或者['']方式】进行操作
    检查属性:
      - 可以检查一个对象是否含有该属性，有则返回true，没有返回false
      - console.log("age" in obj)
    对象的属性值:
      - 对象的属性值可以是(基本数据类型、对象类型、函数类型)的值
      - 如果一个对象的属性值是函数，那么这个属性称为【方法】
    属性操作:
      功能:
        - 访问一个对象中的属性，如果不存在不会报错，而且会返回undefined。
      方式1:
        - 增 obj.name = 18
        - 删 delete obj.name
        - 改 obj.name = 19
        - 查 obj.name
      方式2(非常灵活):
        - ['']方式，
        - 可以定义一些另类的属性，比如 obj['123'] = 1000
        - 可以存放，任意类型变量、字符串、表达式，但最终都会隐式转换为字符串类型
        - 增 obj['sex'] = '男'
        - 删 delete obj['sex']
        - 改 obj['sex'] = 20
        - 查 obj['sex']
函数:
  功能:
    - 函数也是一个对象,而且它是一个特殊对象，可以保存代码块和属性
    - 调用函数语法 = 函数对象()
    - 在调用函数时，解析器不会检查实际参数的类型以及实际参数的个数
    - 函数的(形参、实参、返回值)可以是(基本数据类型、对象类型、函数类型)
  方式1:
    - 通过函数对象创建函数，并将想要封装的代码以字符串的方式传递给构造函数
    - `
        写法1
        new Function("console.log('我的第1个函数')")();
        写法2
        //存放函数引用地址的变量fun，调用函数fun()
        var fun = new Function("console.log('我的第2个函数');");
        fun()
        console.log(fun,typeof fun)
      `
  方式2:
    - 通过function来创建函数
    - `
        写法1-声明式
        //存放函数引用地址的变量fun1，调用函数fun1()
        function fun1(){
          console.log('我的第3个函数');
        }
        fun1();
        //console.log(fun1,typeof fun1)
        写法2-表达式
        //存放函数引用地址的变量fun2，调用函数fun2()
        var fun2 = function(){
          console.log('我的第4个函数');
        }
        fun2();
        //console.log(fun2,typeof fun2)
        写法3
        //创建立即执行函数
        (function(name){
        console.log(name,'我的第5个函数');
        })('eric')
      `
作用域:
  功能:
    - 作用域指一个变量或函数变量的作用范围
    - 在函数作用域中可以访问到全局作用域的变量或函数变量，相反则不同
  a=100:
    - 声明变量形式，当全局作用域或者函数作用域不存在变量a，那么等同于 window.a = 100
    - 修改形式，当全局作用域或者函数作用域存在变量a，则是修改函数作用域或者全局作用域的变量a的值
  全局作用域:
    - 编写在<script>标签体内的变量或者函数变量都属于全局作用域
    - 全局作用域在页面开打时候创建，在页面关闭时候销毁
    - 全局作用域中有一个window对象，它代表的是一个浏览器创建，它由浏览器创建，我们可以直接使用
    - 在全局作用域中，用var修饰的变量，会作为window对象的属性保存
    - 在全局作用域中，创建的函数变量，会作为window对象的方法保存
    - 在全局作用域中，声明的变量或者函数变量，在整个页面都可以访问的到
  函数作用域:
    - 在【函数代码块中、函数形参中】声明的【变量、函数变量】属于函数作用域
    - 函数作用域是在函数调用时创建，函数执行完以后销毁
    - 每调用一次函数就会创建一个全新的函数作用域，它们之间是相互独立的。
    - 因为作用域链的存在，很多时候如果想访问全局的变量或变量函数，可以直接通过window对象访问
  作用域链:
    - 当在函数作用域操作一个变量或者函数变量时，它会先在自身的作用域中寻找，如果有就直接使用，如果没有则往上一级函数作用域寻找，直到找到全局作用域位置，如果全局还没找到则报错。
  声明提前:
    功能:
      - 声明提前可以是在函数作用域，或者全局作用域中提前
    变量声明提前:
      - 被var修饰的变量可以声明提前
      - `
        //var修饰的变量会声明提前
        console.log('b 该变量会提前声明到window对象中',b)
        var b = 'eric'; // 等同于window.b，但是该变量会提前声明到window对象中
        `
    函数声明提前:
      - 声明式函数可以声明提前
      - `
          fun2() //由于函数被提前声明，所以可以正常调用
          //正常定义的函数会声明提前
          function fun2(){
            console.log('我是一个函数，而且我会被提前声明')
          }
      `
this:
  - 解析器在调用函数时，会隐式传递一个this参数
  - "
    根据函数的调用方式不同this指向不同
      以方法方式调用，this指向的是当前对象  obj.fun()
      以new方式调用，this指向的是当前对象  new fun()
      以函数方式调用，this指向window对象  fun()
  "
构造函数:
  功能:
    - 构造函数和普通函数的一模一样，唯独就是取名方式不一样，普通函数首字母为小写，构造函数首字母为大写
    - 构造函数需要使用new关键字来调用
    - 使用同一个构造函数创建的对象，我们成为一类对象，也将一个构造函数成为一个类，该构造函数创建出来的对象，我们成为该类的实例对象
    - 通过 instanceof  来判断一个类实例是否属于该类
  构造函数执行流程:
    - 1.立刻创建一个新的对象
    - 2.将新的对象设置为函数中的this，在构造函数中可以使用this来引用新建对象
    - 3.逐行执行函数中的代码
    - 4.将新建的对象作为返回值返回
原型对象:
  功能:
    - 原型对象可以复用方法或者属性，减少方法或者属性直接绑定到对象实例上。
    - 对象实例会先从对象本身去访问方法或者属性，如果访问不到会去原型上去访问
  创建对象方式1:
    - new构造函数
    - "
      此方式可以通过2种方式拿到原型对象
        1. var obj = new MyObject()
           obj.__proto__

           var obj1 = new MyObject()
           obj1.__proto__

        2. MyObject.prototype
      并且它们是同一个原型对象 obj.__proto__ === obj1.__proto__ == MyObject.prototype
    "
  创建对象方式2:
    - var obj = {}
    - "
      此方式只有1种方式拿到原型对象
      var obj = {}
      var obj1 = {}
      var obj2 = {}
      并且它们是同一个原型对象 obj.__proto__ === obj1.__proto__ === obj2.__proto__
    "