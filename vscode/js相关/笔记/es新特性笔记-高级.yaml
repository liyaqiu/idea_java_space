try-catch:
  - "
      function PersonError([appName,code,error]){
        this.appName = appName
        this.code = code
        this.msg = error.message
        this.stack = error.stack
        this.print = function(){
          console.error(this.appName,'@@@@',this.code,'@@@@',this.msg,'@@@@',this.stack)
        }
      }

      try {
        throw new PersonError(['服务1',408,new Error('id不存在')])
        console.log('eric')
      } catch (e) {
        /* const {appName,code,msg,stack} = e
        console.error(e.appName,e.code,e.msg,e.stack) */
          e.print()
      }
  "
回调地狱问题:
  - 回调地狱是指，内部函数依赖外部函数的结果，形成的多层嵌套
Promise:
  功能:
    - Promise是JS中进行异步编程新的解决方案
    - Promise是用来封装一个异步操作并可以获取其结果
    - Promise可以灵活编写回调，可以任何时间去获取结果
    - Promise链接操作可以解决回调地狱问题
  状态:
    - pending(初始化) -> resolved (成功)
    - pending(初始化) -> rejected (失败)
  入门案例:
    案例1:
      - "
      var executor = (resolve,reject) =>{
          console.log(0)
          //因为执行器函数是同步函数，所以利用setTimeout设置异步函数
          setTimeout(()=>{
              for(let i=0;i<1000000000;i++){}
              console.log(3)
              //resolve('执行结果为123456789')
              reject('执行结果为123456789')
          },1000)

      }

      const p = new Promise(executor)

      console.log(1)

      setTimeout(()=>{
          p.then((result)=>{ //给Promise管理器声明了取结果的函数，一旦有结果，Promise管理器就会将结果以及该函数对象一并存入回调队列中。
              console.log('onResolved',result)
          })
          p.catch((reason) =>{
              console.log('onRejected',reason)
          })
      },0)

      console.log(2)
    "
    案例2:
      - "
        //先改状态，后指定回调函数
        new Promise((resolve,reject) =>{
            resolve('1')
        }).then(
            value => {
                console.log(value)
            },
            reason =>{
                console.log(reason)
            }
        )

        //先指定回调函数，后改状态
        new Promise((resolve,reject) =>{
            setTimeout(()=>{
                resolve('2')
            },1000)
        }).then(
            value => {
                console.log(value)
            },
            reason =>{
                console.log(reason)
            }
        )
      "
  执行器的返回结果:
    - "
      var executor = (resolve,reject) =>{
          //resolve('成功')
          //reject('失败')
          //throw '失败1'
      }

      const p = new Promise(executor)

      p.then((result)=>{
              console.log('onResolved1',result)
      })
      p.then((result)=>{
              console.log('onResolved2',result)
      })
      p.catch((reason) =>{
          console.log('onRejected1',reason)
      })
      p.catch((reason) =>{
          console.log('onRejected2',reason)
      })

    "
  then返回结果:
    - "
        let executor = (resolve,reject) =>{
            //resolve('成功1')
            reject('失败1')
            //throw '失败11'
        }

        let p1 = new Promise(executor)

        let p2 = p1.then(
            value => {
                console.log('p1-onResolved',value)
            },
            reason =>{
                console.log('p1-onRejected',reason)
                    //return '正常返回'
                    //throw '抛异常返回'

                    //返回Promise对象
                    return new Promise((resolve,reject) =>{
                        resolve('成功2')
                        //reject('失败2')
                        //throw '失败22'
                    })

            }
        )

        p2.then(
            value => {
                console.log('p2-onResolved',value)
            },
            reason =>{
                console.log('p2-onRejected',reason)
            }
        )
    "
  总结then+执行器返回结果:
    - then支持，正常返回(return)，异常返回(throw)，执行器返回
    - 执行器返回支持，成功返回(resolve)，失败返回(reject)，异常返回(throw)
  catch和then传透:
    功能:
      - "
        因为需要逐个往下传递的原因，成功回调函数默认不写则为。
          return 1
          return Promise.resovle(1)
      因为需要逐个往下传递的原因，失败回调函数默认不写则为。
          throw 1
          return Promise.reject(1)
      "
    then传透:
      - "
        //案例1
        /* new Promise((resovle,reject)=>{
            resovle(1)
        }).catch(reason =>{
          console.log('reason1',reason)
        }).catch(reason =>{
          console.log('reason2',reason)
        }).catch(reason =>{
          console.log('reason3',reason)
        }).catch(reason =>{
          console.log('reason4',reason)
        }).then(value => {
            console.log('value',value)
        }) */
      "
    catch穿透:
      - "
        /* new Promise((resovle,reject)=>{
            reject(1)
        }).then(value =>{
          console.log('value1',value)
        }).then(value =>{
          console.log('value2',value)
        }).then(value =>{
          console.log('value3',value)
        }).then(value =>{
          console.log('value4',value)
        }).catch(reason => {
            console.log('reason',reason)
        }) */
      "
  终止Promise链操作:
    - "
      new Promise((resovle,reject)=>{
        resovle(1)
      }).then(value =>{
        console.log('value1',value)
        return new Promise(()=>{})
      }).then(value =>{
        console.log('value2',value)
      }).then(value =>{
        console.log('value3',value)
      }).then(value =>{
        console.log('value4',value)
      }).catch(reason => {
          console.log('reason',reason)
      })
    "
  语法糖resolve和reject:
    - "
        const p1 = new Promise((resolve,reject)=>{
            resolve('成功结果为1')
        })

        p1.then(value =>{
            console.log(value)
        })

        const p2 = Promise.resolve('成功结果2')
        p2.then(value =>{
            console.log(value)
        })

        const p3 = Promise.reject('失败结果3')
        p3.catch(reason =>{
            console.log(reason)
        })
    "
  语法糖all和race:
    - "
      const p1 = Promise.resolve(1)
      const p2 = Promise.resolve(2)
      const p3 = Promise.resolve(Promise.reject(3))


      const pAll = Promise.all([p1,p2,p3])
      pAll.then(values =>{
          console.log('values',values)//需要全部成功才返回，并且会按照预先顺序返回
      },reason =>{
          console.log('reason',reason)//返回第一个最先修改Promise状态的值
      })


      const pRace = Promise.race([p1,p2,p3])
      pRace.then(value =>{
          console.log('value',value)//返回第一个最先修改Promise状态的成功值
      },reason =>{
          console.log('reason',reason)//返回第一个最先修改Promise状态的失败值
      })
    "
