官方:
  - https://cn.vuejs.org/
  - bootcdn.cn 可以下载一些常用的js库文件
  - JavaScript遵循ECMAScript规范
  - 一个完成的JavaScript有3部分组成，ECMAScript、DOM、BOM
  - JavaScript是一门解析型语言，基于原型的面向对象语言
  - js下载 https://www.bootcdn.cn/
  - mdn文档 https://developer.mozilla.org/en-US/
  - babeljs 语法转换 https://babeljs.io/
  - 参考文档 https://www.w3cschool.cn/javascript/js-ex-objects.html
  - 参考文档 https://www.w3cschool.cn/jsref/jsref-obj-number.html
  - 包查找地址 https://www.npmjs.com/
Vue安装:
  安装vue:
    - 开发版本(有警告，有提示) 下载vue.js文件 https://cn.vuejs.org/js/vue.js
    - 生产版本(无警告，无提示) 下载vue.js文件 https://cn.vuejs.org/js/vue.min.js
  安装google浏览器插件:
    - 方式1 打开开发者窗口chrome://extensions/，然后直接拖拽Vue.crx到google开发者窗口
    - 方式2 在plugins包目录下，将Vue.crx改名为Vue.zip，解压即可
  VScode初始化设置:
    - "
      设置目录树的缩进 = 19
        英文版：File --> Preformences --> Settings
        中文版：文件 --> 首选项 --> 设置
        搜索 Workbench › Tree: Indent

      设置参考线 = none
        Workbench › Tree: Render Indent Guides

      设置双击点开目录 = doubleClick
        Workbench › Tree: Expand Mode

      设置字体大小 = 14
        Editor: Font Size

    "
  vscode插件安装:
    - 插件[Vue 3 Snippets]，安装代码提示
    - 插件[JetBrains Icon Theme],显示文件夹管理图标
    - 插件[Auto Close Tag]，自动补全html标签
    - 插件[Auto Rename Tag]，自动改名标签
    - 插件[Chinese]，汉化vscode
    - 插件[Live Server]，网页服务器
    - 插件[open in browser]，从vscode选项打开浏览器
    - 插件[Vetur]作者Pine Wu，可以用来显示Vue文件高亮
    - 插件[CSS Peek] 追踪CSS样式
    - 插件[ESLint] 代码检查
    - "
        插件[Easy LESS] less预处理插件
        'less.compile': {
            'out': '../css/' 配置输出路径
        }
    "
    - "
      插件[cssrem] 相对单位转换神器

      设置rem相对单位转换基准值
      Cssrem: Root Font Size = 75

      设置vm相对单位转换基准值
      cssrem.vw 设置vm转换，默认是不开启的
      Cssrem: Vw Design 设置 375
    "
Vue基础:
  功能:
    - 一个容器只能对应一个vue实例对象
  MVVM:
    - M代表模型，是data中的数据
    - V代表视频，是模版代码
    - VM代表模型视图，代表Vue实例，data中所有的属性都在VM身上，VM身上的所有属性都可以在Vue模版中直接使用。
  监视数据原理:
    功能:
      - vue会监视data中所有层次的数据
    数据代理:
      - "Object.defineProperty(person,'age',{}"
  元素属性:
    插值语法:
      功能:
        - 给【标签体】使用
      使用:
        - {{xxx}} 调用data的属性
        - {{xxx()}} 调用methods的方法
    数据绑定:
      单向绑定:
        功能:
          - v-bind:xx，单向数据绑定，可简写为【:xx】
      双向绑定:
        功能:
          - v-model:value，双向数据绑定，可以简写为【v-model】一般用在交互标签，文本框，单选框，多选框，它们都有一个value属性可以绑定。
        修饰符:
          - number 将字符串转换为数字，v-model.number
          - lazy 失去焦段后触发，v-model.lazy
          - trim 去头尾空格,v-model.trim
    事件处理:
      点击事件:
        功能:
          - v-on:click="showInfo" 为标签绑定一个showInfo函数，可简写为 【@click="showInfo"】，传参的写法@click="showInfo($event,'hello',128)
        修饰符:
          - prevent 阻止默认时间(常用) v-on:click.prevent、@click.prevent
          - stop 阻止事件冒泡(常用) v-on:click.stop、@click.stop
          - once 事件只触发一次(常用) v-on:click.once、@click.once
          - capture 使用事件的捕获模式
          - self 只有event.target是当前操作的元素时才触发时间
          - passive 时间的默认行为立即执行，无需等待事件回调执行完毕
        修饰符组合使用:
          - 假设需要阻止冒泡和阻止默认时间 @click.stop.prevent="showInfo"
      键盘事件:
        功能:
          - v-on:keyup="showInfo"，简写为【@keyup="showInfo"】 按下键盘弹起触发
          - v-on:keydown 按下键盘触发，简写为【@keydown="showInfo"】 按下键盘弹起触发
        修饰符:
          - enter 回车键 @keyup.enter
          - delete 退格键 @keyup.delete
          - esc 退出键
          - space 空格键
          - tab 换行键，需要配合@keydown使用才出效果
          - up 上键
          - down 下键
          - left 左键
          - right 右键
        特殊修饰符:
          - ctrl
          - alt
          - shift
          - meta window键
          - 以上按键配合keyup使用，需要加上其他键组合才能触发
          - 以上按键配合keydown使用，可以正常使用
        修饰符组合使用:
          - 假设需要ctrl+y才能触发事件 @keyup.ctrl.y="showInfo"
      表单提交事件:
        功能:
          - v-on:submit 可以简写为@submit
        修饰符:
          - prevent 阻止默认时间(常用) v-on:click.prevent、@click.prevent
          - stop 阻止事件冒泡(常用) v-on:click.stop、@click.stop
          - once 事件只触发一次(常用) v-on:click.once、@click.once
          - capture 使用事件的捕获模式
          - self 只有event.target是当前操作的元素时才触发时间
          - passive 时间的默认行为立即执行，无需等待事件回调执行完毕
    控制指令:
      if:
        功能:
          - 直接移除标签
          - 可以结合templete标签使用
        使用:
          - v-if="布尔表达式"
          - v-else-if="布尔表达式"
          - v-else="布尔表达式"
      show:
        功能:
          - 不移除标签，使用样式隐藏方式
        使用:
          - v-show="布尔表达式"
    循环指令:
      功能:
        - 遍历列表<li>
        - 可以遍历数组，遍历对象，遍历字符串，遍历具体次数
      使用:
        - v-for="(car,index) in cars" :key="index+1"
        - v-for="(car,index) of cars" :key="index+1"
      注意:
        - 一般:key不要用index，除非你能保证新生成的数据不会对原来的数据进行打乱(逆序添加或者删除)。否则当vue在进行虚拟dom节点对比的时候会出问题，并且执行效率低下
        - 为了保险起见尽量用到数据的我唯一ID
    插入标签体内容指令:
      v-text:
        - 不支持标签解析，并且会替换标签体内容
      v-html:
        - 支持标签解析，并且会替换标签体内容
        - 存在安全隐患
    网速慢延迟解析指令:
      功能:
        - 它是一个特殊属性，Vue实例创建完并接管容器后会删掉v-cloak属性，需要配合css样式使用
      使用:
        - v-cloak，这个指令没有值
    解析指令:
      v-once:
        功能:
          - 它只被Vue解析一次
        使用:
          - v-once，这个指令没有值
      v-pre:
        功能:
          - Vue不解析该节点所有模版
          - 可利用它跳过没有使用指令语法，没有使用差值语法的节点，会加快编译性能
        使用:
          - v-pre，这个指令没有值
    自定义指令:
      功能:
        - bind，指令与元素绑定时会执行
        - inserted，指令所在元素被插入页面时执行
        - update，指令所在的模版被重新解释时会执行
      使用:
        - v-demo1
        - v-demo2
    元素的ref属性:
      - ref属性用来给元素或者子组件注册引用信息到VC身上(id的代替者)
      - 如果是元素，则返回元素对象，如果是组件，则返回VueComponent实例对象
      - 配置方式 <Person ref="person"/>
      - 获取方式 this.$refs
    样式绑定-class属性:
      - "
        10样式-class样式.html
      "
    样式绑定-style属性:
      - "
        10样式-style样式.html
      "
    单文件组件样式属性:
      功能: 因为Vue最后会将所有组件样式进行合并，在同名的情况下可能会导致样式覆盖，所以需要用到scoped属性
      less的使用:
        - "
              <style scoped lang='less'>
              /* npm i less-loader */
              .box {
                width: 500px;
                height: 500px;
                border: 1px solid red;
                margin: 0 auto;
                a {
                  text-decoration: none;
                  margin: 0 10px;
                  &:hover{
                    color: gray;
                    text-decoration:underline;
                  }
                }
              }
              </style>
            "
      动画与过渡:
        - "
            1.准备好样式
              元素进入的样式:
                v-enter: 进入的起点
                v-enter-active: 进入的过程中
                v-enter-to:进入的终点
              元素离开的样式
                v-leave: 离开的起点
                v-leave-active: 离开的过程中
                v-leave-to:离开的终点
            2.使用<transition>元素包裹，多个元素使用<transition-group>元素包裹,并且每个元素需要配置key
          "
    插槽属性:
      - 可以实现组件之间的传递参数
      - 插槽分为:默认插槽，具名插槽，作用域插槽
  配置对象属性:
    el属性:
      - 方式1 el:'#box'
      - 方式2 vm.$mount('#box')
    data属性:
      - "
          方式1,对象式
            data: {
               name: 'eric'
            }
        "
      - "
          方式2，函数式，函数必须返回一个对象
            data:function() {
                return{
                    name:'eric'
                }
            }
        "
      - "
          方式3，函数式，函数必须返回一个对象
            data() {
                return{
                    name:'eric'
                }
            }
        "
    methods属性:
      - "
        //创建Vue实例
        new Vue({
            el: '#box',  //绑定容器，等同于el: document.getElementById('box')
            data: {
                name: 'eric'
            },
            methods:{
                showInfo(event,data1,data2){
                    console.log(event,data1,data2)
                }
            }
        })
        "
    生命周期钩子属性:
      功能:
        - 官方生命周期图 https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA
      beforeCreate:
        - 初始化，生命周期、事件，但数据代理还未开始
        - 此时，无法通过VM访问到data中的数据、methods中的方法。
      created:
        - 初始化，数据监测，数据代理
        - 此时，可以通过VM访问到data中的数据、methods中的方法。
      beforeMount:
        - 此阶段之前Vue开始解析模版，在内存中生成虚拟DOM，页面还不能显示解析号的内容
        - 页面呈现的是未经过Vue编译的DOM结构。
        - 所有对DOM的操作，最终都不生效，意思是就算你用原生操作了DOM，最后会被Vue解析后把之前内容覆盖
      mounted(常用):
        - 此阶段之前，Vue将内存中的虚拟DOM转为真实DOM插入页面。
        - 此时，页面中呈现的是经过Vue编译的DOM，对DOM的操作是有效的。
        - 至此初始化过程结束，一般在此进行开启定时器，发送网络请求，订阅消息，绑定自定义事件等初始化操作
      beforeUpdate:
        - 此时，数据是新的，但是页面是旧的，即，页面尚未和数据保持同步。
      updated:
        - 在此阶段之前，Vue根据新数据，生成的虚拟DOM与旧的虚拟DOM进行比较，最终完成页面更新，即完成了Model->View的更新
        - 此时，数据是新的，页面也是新的，即，页面和数据保持同步。
      beforeDestroy(常用):
        - 此时，VM中所有的，data、methods、指令等等，都处于可用状态，马上要执行销毁的过程。
        - 一般在此阶段，关闭定时器，取消订阅消息，解绑自定义事件等收尾操作。
        - "
          注意事项
            销毁后借助Vue开发者工具看不到任何信息。
            销毁后自定义事件会失效，但原生DOM事件依然有效。
            一般不会在beforeDestroy操作数据，因为即便操作数据，也不会在触发更新流程了。
        "
      destroyed:
      $nextTick:
        - 此钩子用于下次渲染执行，比如，一个元素隐藏了，突然需要显式并且获取焦点，那么获取焦点的操作就需要等下一次渲染在执行
      路由器专有的钩子:
        - acticated  当组件被路由回来的时候触发
        - deacticated 当组件被路由走的时候触发
    computed属性:
      - 实现原理借助了数据代理方法实现。
      - get函数只执行第一次，后续如果在获取就会从缓存中获取，执行效率高。
    watch属性:
      功能:
        - 可以监视data中的属性，当属性发生变化时，触发handler函数的执行
        - 可以监视computed中的计算属性，当属性发生变化时，触发handler函数的执行
      监视对象:
        - 利用数据代理方式生成getter setter函数，实现监视。
        - 如果需要对VM对象增加属性，需要使用Vue.set()/vm.$set()进行追加
      监视数组:
        - 通过包装原有数组的7个函数进行功能增强。
        - 如果需要对VM对象增加属性，需要使用push/pop/shift/unshift/splice/sort/reverse或者使用Vue.set()/vm.$set()进行追加
    filters属性:
      - "
        //定义全局过滤器
        Vue.filter('filterDemo2',function(value,splitSymbol){
            return value.replaceAll(splitSymbol,'-')
        })
        //创建Vue实例
       const vm = new Vue({
            el: '#box',  //绑定容器，等同于el: document.getElementById('box')
            data: {
                person:{
                    name:'eric',
                    birthday: Date.now()
                }
            },
            //定义局部过滤器
            filters:{
                filterDemo1(val,foramtStr='YYYY/MM/DD HH:mm:ss'){
                    return dayjs(val).format(foramtStr)
                }
            }
        })
      "
    render属性:
      - 如果Vue模块是一些阉割版的，不支持templete属性的话，需要用到此属性来创建元素
      - "
        //创建Vue实例
        new Vue({
            el: '#box',  //绑定容器，等同于el: document.getElementById('box')
            data: {
                name: 'eric'
            },
            render: elfun=>{
                return elfun('h1','hello')
            }
        })
      "
    组件相关属性:
      - "
        <div id='box'>
            <!-- 第三步，使用组件 -->
            <demo1></demo1>
            <hr>
            <demo2></demo2>
            <demo2></demo2>
        </div>

        <script>
            Vue.config.productionTip = false;

            //第一步，创建组件
            const demo1 = Vue.extend({
                name: 'component-demo1', //这里会替换默认的组件名字
                data(){
                    return {
                        name:'demo1'
                    }
                },
                template:`
                    <div>
                        <h1>hello {{name}}</h1>
                    </div>
                `
            })
            //第一步，创建组件
            const demo2 = Vue.extend({
                data(){
                    return {
                        name:'demo2'
                    }
                },
                template:`
                    <div>
                        <h1>hello {{name}}</h1>
                    </div>
                `
            })

            const demo3 = Vue.extend({
                data(){
                    return {
                        name:'demo2'
                    }
                },
                template:`
                    <div>
                        <h1>hello {{name}}</h1>
                    </div>
                `
            })

            //第二步，全局注册组件
            Vue.component('demo2',demo2);

            const vm = new Vue({
                el: '#box',
                //第二步，局部注册组件
                components:{
                    demo1, //简写，等于 demo1:demo1
                }
            })

        </script>
      "
    directives属性:
      - 自定义标签
      - "
        //创建Vue实例
        new Vue({
            el: '#box',  //绑定容器，等同于el: document.getElementById('box')
            data: {
                num:1,
                num1:1
            },
            directives:{
                demo2:{
                    //指令与元素绑定时会执行
                    bind(element,binding){
                        console.log('bind',element,binding)
                        element.innerText = binding.value*10
                    },
                    //指令所在元素被插入页面时执行
                    inserted(element,binding){
                        console.log('inserted',element,binding)
                    },
                    //指令所在的模版被重新解释时会执行
                    update(element,binding){
                        console.log('update',element,binding)
                        element.innerText = binding.value*10
                    }
                }
            }
        })
      "
    props属性:
      - props属性，可以进行标签传参(字面量，函数，对象)，props属性不允许修改，如果需要修改，请复制一份到data中，对data数据进行修改
      - "
            export default {
            name:'Person',
            data(){
              console.log(this)
              return {
                introduction:'如下是今年优秀的人',
                myAge:this.age ////如果修改传递参数，必须复制一份进行修改
              }
            },
            methods: {
              addAge(){
                this.myAge++
              }
            },
            //方式1
            //props:['name','age','sex'],
            //方式2
            /* props:{
              name:String,
              age:Number,
              sex:String
            } */
            //方式3
            props:{
              name:{
                type:String,
                require:true
              },
              age:{
                type:Number,
                default:100
              },
              sex:String //可以组合方式写
            }
          }
          "
    mixins属性:
      - "
        /*
          混合属性注册了，可以和data一样直接使用。
              混合属性全局注册，所有的VC都可以获取到该配置对象
                  Vue.mixin(globalConfig)
              局部注册，当前VC可以获取到该配置对象
                  mixins:[localConfig]
         */
      "
    use&install属性:
      - 通过插件的方式注册对象到Vue原型对象上，共享给VC实例对象使用
      - 可以定义全局配置，一般用于插件注册
      - "
                //定义插件
                import {globalConfig,localConfig} from '../mixinjs/common-mixin.js'
                export default {
                    install(Vue,[x,y]){
                        console.log(x,y)

                        //注册全局混合属性
                        Vue.mixin(globalConfig)
                    }
                }
                Vue.use(myplugins,['参数1','参数2'])//使用插件
              "
  API:
    动态添加Vue对象属性:
      - Vue.set()、this.$set、VM.$set 给Vue配置对象中的对象增长属性，对象不能是Vue实例或者Vue实例的根数据对象
    创建一个VueComponent函数对象:
      - const demo3 = Vue.extend({})，该方法返回一个VueComponent函数对象
      - new demo3() 获得VC实例对象
    给组件绑定事件，实现参数传递:
      给子组件绑定自定义事件:
        - 通过@myClick为组件标签绑定事件，通过this.$emit触发事件
        - "
             <!-- <Person @myClick.once='myMthod'/> 给子组件绑定事件，只能触发一次-->
              <Person @myClick='myMthod'/>
              this.$emit('myclick','hello-world')//触发事件
            "
      通过$on或者$once给(父或者子)组件绑定自定义事件:
        - 通过$on或者$once为组件绑定事件，通过this.$emit触发事件
        - "
            this.$refs.personRef.$on('myclick',function(msg){
                console.log(msg)
            }) //给子组件绑定事件
            this.$emit('myclick','hello-world')//触发事件
            "
    组件使用默认事件:
      - "
          <Person ref='personRef' @click.native='fun'/>  默认会认为使用自定义事件，只有加上native修饰才可以
        "
    全局事件总线传输信息:
      - 一般用来实现夸组件之间通讯，或者兄弟组件之间的通讯，减少不必要的多层传递
      - 接收者绑定事件，发送者触发事件
      - "
            第一步，在跟VM上注册
            new Vue({
              el:'#app',
              render: h => h(App),
              beforeCreate() {
                Vue.prototype.$bus = this
              },
            })
            第二步，谁注册谁销毁
            mounted() {
              this.$bus.$on('personTransNameToStudent',(value)=>{
                this.name = value
              })
            },
            beforeDestroy() {
              this.$bus.$off(['personTransNameToStudent'])
            },
            第三步，需要传递参数的VC
            this.$bus.$emit('personTransNameToStudent',this.name)
          "
    下次渲染执行$nextTick:
      - $nextTick
      - "
            inputOnfocus(){
              console.log(this)
              this.isshow = !this.isshow
              this.$nextTick(()=>{ //等渲染以后在执行
                this.$refs.input1.focus()
              })
            }
          "
Vue组件化与JS模块化:
  模块与模块化:
    - 向外提供特定功能的js程序，一般就是一个js文件，将一个js拆分成多少个js成为模块化
    - js代码复用
  组件与组件化:
    - 实现应用中局部功能代码和资源的集合(html、css、js、mp3、image)
    - 功能复用
  单文件组件:
    - 一个vue文件中有且只有1个组件
  非单文件组件:
    - 一个html文件中包含N个组件
    - 诟病，样式不能跟着组件走
  组件使用:
    - 创建组件 Vue.extend
    - 局部注册组件components/全局注册 Vue.component
    - 使用组件<demo1></demo1>
  关于VueCompnent(简称VC实例对象):
    - school组件本质是一个名为VueComponent的构造函数，而且不是程序员定义的，是Vue.extend生成的。
    - 我们只需要写<school/>或<school></school>，Vue解析时会帮我们创建school组件的实例对象，即Vue帮我们执行的 new VueComponent(options)
    - 特别注意，每次调用Vue.extend，返回的都是一个全新的VueComponent
    - new Vue的this指向Vue实例对象，组件配置中的this指向VueComponent实例对象
  VC和VM区别:
    - VC(VueComponent)不可以绑定el，而且VC的data属性必须要返回一个对象的函数
    - VM(Vue)可以绑定el,data可以写返回一个对象的函数，或者直接是对象形式
    - "
      console.log(demo2.prototype.__proto__ == Vue.prototype)
      console.log(demo2.prototype.__proto__ == vm.__proto__)
      console.log(new demo2().__proto__.__proto__ == vm.__proto__)
      正是因为原型链的关系(VueComponent.prototype.__proto__ === Vue.prototype)，所以vm能访问的，vc也能访问
      Vue.prototype.attr = 100
      new VueComponent().attr
    "
Vue-cli(脚手架):
  功能:
    - https://cli.vuejs.org/zh/
  安装1:
    - npm config set registry https://registry.npm.taobao.org 设置镜像
    - npm i -g @vue/cli 安装vue脚手架
  安装2:
    - npm install -g cnpm --registry=https://registry.npmmirror.com
    - cnpm i -g @vue/cli 安装vue脚手架
  使用:
    - vue create vue-project-test 利用Vue脚手架创建项目
    - cd vue-project-test 进入目录
    - npm run serve 启动脚手架项目
    - npm run build 构建项目
  配置:
    - vue inspect > test.json //查看脚手架默认配置
    - 修改配置参考文档 https://cli.vuejs.org/zh/config/
    - 在vue.config.js文件中修改，lintOnSave=false可以关闭语法检查
Vuex:
  功能:
    - 专门在Vue中实现集中式状态管理的一个Vue插件，对Vue应用中多个组件的共享状态进行集中式管理，也是一种组件间通讯的方式，而且适用于任意组件间通讯。
    - https://github.com/vuejs/vuex
  好处: 可以利用vuex插件进行调试
  什么时候使用Vuex:
    - 多个组件依赖同一状态
    - 来自不同组件的行为需要改变同一状态
  vue使用对应vuex版本:
    - vue2使用vuex3版本  npm i vuex@3
    - vue3使用vuex4版本  npm i vuex@4
  vuex使用:
    - "
        参考vuex环境搭建
        参考vuex入门案例
        参考vuex mapState,mapGetters,mapActions,mapMutations
        参加vuex模块化案例
      "
Vue-router:
  功能:
    - 单页Web应用，简称(SPA)，全名(single page web application)
    - 单页面应用整个应用只有一个页面，点击页面中的导航链接不会刷新页面，只会做页面的局部更新，数据需要通过ajax请求获取
    - "
      路由可以实现前端(浏览器)以及后端(nodejs)路由
        前端路由，当浏览器的路径发生改变时，对应的组件就会显示
        后端路由，服务器接收到一个请求时，根据请求路径匹配到对应的函数来处理请求，并且返回响应数据
    "
  vue使用对应router版本:
    - vue2使用vuex3版本  npm i vue-router@3
    - vue3使用vuex4版本  npm i vue-router@4
  router注意事项:
    - 用来做页面跳转的组件，成为路由组件，反之则为一般组件
    - 路由组件放在pages文件夹中，一般组件放在components文件夹中
    - 路由组件的切换，默认是销毁的，需要用的时候重新在挂载
    - 每个路由组件都有$route属性和$router属性，$route属性存储的自己独有的路由信息，而$router属性整个应用只有一份
  router使用:
    - "
        19.1router-入门使用
        19.2router-嵌套使用
        19.3router-多级嵌套
        19.4router-query传参
        19.5router-命名路由
        19.6router-params传参
        19.7router-props传递给组件的props
        19.8router-replace属性(历史记录push和replace)
        19.9router--编程式路由导航
        19.10router--缓存路由组件
        19.11router--生命周期钩子
        19.12router--全局路由守卫(前置和后置)
        19.13router-独享守卫和组件守卫(调试执行顺序)
        19.14router-hash问题(脚手架的2种工作模式)
    "
  路由守卫的执行顺序:
    - "
      全局路由守卫-前置路由守卫(beforeEach,next)
        独享路由守卫(beforeEnter,next)
          组件路由守卫Enter(beforeRouteEnter,next)
            全局路由守卫-后置路由守卫(afterEach)
              HaiXian组件创建
              HaiXian组件挂载
                组件路由守卫Leave(beforeRouteLeave,next)
                  全局路由守卫-前置路由守卫(beforeEach,next)
                    全局路由守卫-后置路由守卫(afterEach)
                      YiFu组件创建
                      HaiXian组件销毁
                      YiFu组件挂载
    "
Vue第三方库:
  动画库:
    功能:
      - https://animate.style/
    使用:
      - npm install animate.css --save
      - import 'animate.css';
  发ajax请求:
    - "
        1安装axios库，并且导入第三方库
          npm i axios
          import axios from 'axios'
        2使用axios发ajax请求
          getMessage(){
            axios.get('http://192.168.0.109:8899/test1')
            .then(
                response =>{
                  console.log(response.data)
                },
                error =>{
                  console.log(error.message)
                }
            )
          }
        利用脚手架开启代理服务器解决跨域问题 https://cli.vuejs.org/zh/config/#devserver-proxy
          脚手架配置
            /*
              方式1
              开启代理服务器，解决跨域问题
              会现在自己身上找资源，找不到在去服务器找
             */
            /* devServer: {
              proxy: 'http://cookie2.aaa.com:8899'
            }, */
            /* 方式2 */
            devServer: {
              proxy: {
                '/server1': {
                  target: 'http://cookie1.aaa.com:8899',
                  pathRewrite:{'^/server1':''},
                  //ws: true, //websocket使用
                  /*
                    changeOrigin: true
                        x-forwarded-host : 192.168.0.109:8080
                        x-forwarded-proto : http
                        x-forwarded-port : 8080
                        x-forwarded-for : 192.168.0.109
                        accept-language : zh-CN,zh;q=0.9
                        accept-encoding : gzip, deflate
                        referer : http://192.168.0.109:8080/index.html
                        user-agent : Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36
                        accept : application/json, text/plain
                        connection : close
                        host : cookie2.aaa.com:8899
                    changeOrigin: false
                        x-forwarded-host : 192.168.0.109:8080
                        x-forwarded-proto : http
                        x-forwarded-port : 8080
                        x-forwarded-for : 192.168.0.109
                        accept-language : zh-CN,zh;q=0.9
                        accept-encoding : gzip, deflate
                        referer : http://192.168.0.109:8080/index.html
                        user-agent : Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36
                        accept : application/json, text/plain
                        connection : close
                        host : 192.168.0.109:8080
                  */
                  changeOrigin: true  //是否改变请求头的host属性的值
                },
                '/server2': {
                  target: 'http://cookie2.aaa.com:8899',
                  pathRewrite:{'^/server2':''},
                  //ws: true, //websocket使用
                  changeOrigin: true  //是否改变请求头的host属性的值
                },
              }
            }

      "
  消息订阅与发布:
    - 建议使用全局事件总线来处理，可以在开发者工具看到事件的触发
    - "
              第一步
              npm i pubsub-js
              第二步
              mounted() {

              this.id = pubsub.subscribe('personTransNameToStudent',(queueName,value)=>{
                  this.name = value
                  console.log(queueName,value)
              })
              console.log(this.id)
            },
              beforeDestroy() {
                //this.$bus.$off(['personTransNameToStudent'])
                pubsub.unsubscribe(this.id)
              },
              第三步
              personTransNameToStudent(){
                //this.$bus.$emit('personTransNameToStudent',this.name) //触发事件
                pubsub.publish('personTransNameToStudent',this.name)
              }
            "
Vue第三方UI库:
  移动端UI库:
    - 京东移动端nutui（nutui.jd.com）
    - Vant (https://youzan.github.io/vant)
    - Cube UI (https://didi.github.io/cube-ui)
    - Mint UI (http://mint-ui.github.io)
  PC端UI库:
    - 饿了么团队Element UI (https://element.eleme.cn)
    - IView UI (https://www.iviewui.com)
Vue-elementUI使用:
  - "
    20.1elementUI-入门使用(全量引入)
    20.2elementUI-入门使用(按需引入)
  "
Vue3:
  - https://www.bilibili.com/video/BV1Zy4y1K7SH?p=136&spm_id_from=pageDriver&vd_source=cc17fab1d456bc3958dcb51e2fdd520b