#https://blog.csdn.net/qq_37759376/article/details/132844483
#生成私钥文件.key：
#	openssl genrsa -out server.key 2048
#	openssl req -new -key server.key -out server.csr
#	openssl x509 -req -days 3650 -in server.csr -signkey server.key -out server.crt
#	cat server.key server.crt > server.pem


master_process on;#默认为on off
user  root; #使用root来启动work进程
worker_processes  1;
error_log  logs/error.log  debug;
events {
    #accept_mutex on;#是否开启work队列机制
    #multi_accept on;#允许一个wrok接受多个请求
    use epoll; #使用多路复用io
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    log_format  myformat  '[1]$remote_addr - [2]$remote_user [$time_local] "[3]$request" '
                      '[4]$status $body_bytes_sent "$http_referer" '
                      '"[5]$http_user_agent" "[6]$http_x_forwarded_for"';
    access_log  logs/access.log  myformat;

    sendfile        on; #功能：减少copy次数，以及减少用户态和内核态的切换
    #tcp_nopush tcp_nodelay 两者互斥，在内核2.5.9以后兼容，当tcp_nopush未满并且达到阈值，nginx会强制tcp_nodelay发送数据包
    tcp_nopush on; #需要sendfile打开才能用，功能：将数据放缓存区装满以后一起发送
    tcp_nodelay on; #功能：不需要等待延迟，直接发送
    keepalive_timeout  65;
    server {
        listen       8080 ssl;

        ssl_certificate      cert.pem;
        ssl_certificate_key  cert.key;
        ssl_session_cache    shared:SSL:1m;
        ssl_session_timeout  5m;
        ssl_ciphers  HIGH:!aNULL:!MD5;
        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
        ssl_prefer_server_ciphers  on; #是否开启work进程共享

        server_name  localhost;
        location / {
            root   /root/html;
            index  1index.html;
        }
    }
}
