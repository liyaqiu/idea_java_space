批量创建数据: "
    CREATE TABLE IF NOT EXISTS empoyees(
      id int,
      salary DECIMAL(10,2),
      last_name VARCHAR
  )

  DROP PROCEDURE IF EXISTS batch_insert;
  DELIMITER $
  CREATE PROCEDURE batch_insert()
  BEGIN
      DECLARE count INT DEFAULT 0;
      loop_label:LOOP

          SELECT 1;

          IF count > 10 THEN LEAVE loop_label;
          ELSE INSERT INTO empoyees(id,salary,last_name) VALUES(count,count*10,CONCAT('eric',count));
          END IF;
          SET count = count + 1;

      END LOOP loop_label;

  END $

  DELIMITER ;
"
架构篇:
  字符集&比较规则操作:
    概述: "
          与创建数据库有关
          character_set_server	    utf8    服务器级别的字符集(修改这里直接影响character_set_database)
          character_set_database	utf8    当前数据库的字符集
          与客服端和服务器之间传输有关
          character_set_client	    utf8    服务器解码请求时用的字符集(必须和客户端编码一直，需要做解码)
          character_set_connection	utf8    放服务器处理请求时会把请求字符串从character_set_client转为character_set_connection(必须和表的编码一直，需要做转码，因为涉及到查表)
          character_set_results	    utf8    服务器向客户端返回数据时使用的字符集(必须和客户端编码一直，需要做编码)

          character_set_filesystem	binary
          character_set_system	    utf8
          character_sets_dir	    /usr/share/mysql/charsets/
        "
    查看系统全部字符集: "
      查看数据库支持的所有字符集
        SHOW CHARACTER SET
        SHOW CHARSET
        SHOW CHARACTER SET LIKE 'utf8%'
        SHOW CHARACTER SET WHERE Charset = 'utf8'
      查看当前使用的字符集
        SHOW GLOBAL VARIABLES LIKE 'character%';
        SHOW SESSION VARIABLES LIKE 'character%';
    "
    临时修改修改字符集: "
      全局系统变量
      SHOW GLOBAL VARIABLES LIKE 'char%'

      SET @@global.character_set_client = utf8mb4;
      SET @@global.character_set_connection = utf8mb4;
      SET @@global.character_set_results = utf8mb4;

      会话系统变量
      SHOW SESSION VARIABLES LIKE 'char%'
      #方式1
      SET @@session.character_set_client = utf8mb4;
      SET @@session.character_set_connection = utf8mb4;
      SET @@session.character_set_results = utf8mb4;
      #方式2
      SET NAMES utf8mb4;
      #方式3
      SET character_set_client = utf8;
      SET character_set_connection = utf8;
      SET character_set_results = utf8;
    "
    查看比较规则: "
      SHOW COLLATION
      SHOW COLLATION LIKE 'utf8%'
      SHOW COLLATION WHERE Collation = 'utf8_general_ci'
    "
    修改字符集(my.cnf): "
      [client]
      default-character-set=utf8
        character_set_client	    utf8    服务器解码请求时用的字符集(必须和客户端编码一直，需要做解码)
        character_set_connection	utf8    放服务器处理请求时会把请求字符串从character_set_client转为character_set_connection(必须和表的编码一直，需要做转码，因为涉及到查表)
        character_set_results	    utf8    服务器向客户端返回数据时使用的字符集(必须和客户端编码一直，需要做编码)
      [mysqld]
      character_set_server=utf8
        character_set_server	    utf8    服务器级别的字符集(修改这里直接影响character_set_database)
        character_set_database	    utf8    当前数据库的字符集
    "
  SQL大小写敏感问题:
    概述:
      - SHOW VARIABLES LIKE '%lower_case_table_names%'
      - 设置0大小写敏感(Linux)，数据库、表名、表的别名、变量名是严格区分大小写，其他则不区分。
      - 设置1大小写不敏感(Window)，创建的表、数据库都是以小写形式存放在磁盘上，对于SQL语句都是转换为小写对表和数据库进行查找
    修改:
      MYSQL5.7: 在my.cnf文件中的[mysqld]中加入 lower_case_table_names = 1 然后重启数据库
      MYSQL8.0: "
        1.停止Mysql服务
        2.删除数据库目录 /var/lib/mysql（禁止删除，严重）
        3.在my.cnf文件中的[mysqld]中加入 lower_case_table_names = 1
        4.启动Mysql服务
      "
    SQL编写规则: 关键字和函数名称全部大写，其他则为小写
  严格模式vs轻松模式(sql_mode):
    概述:
      - 查看 SHOW SESSION VARIABLES LIKE '%sql_mode%' / SHOW GLOBAL VARIABLES LIKE '%sql_mode%'
      - 临时修改 SET SESSION sql_mode = 'ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION'
      - 永久修改 在my.cnf文件[mysqlId]中添加 sql_mode = ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION
    模式介绍:
      默认:
        ONLY_FULL_GROUP_BY: 对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不和方法的，因为列不在GROUP BY语句中
        STRICT_TRANS_TABLES: 在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制。
        NO_ZERO_IN_DATE: 不允许日期和月份为零
        NO_ZERO_DATE: MYSQL数据库不允许插入零日期，插入零日期会抛出错误而不是警告
        ERROR_FOR_DIVISION_BY_ZERO: 在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如果未给出该模式，那么数据被零除时MYSQL返回NULL
        NO_ENGINE_SUBSTITUTION: 如果需要的存储引擎被禁用或未编译，那么抛出错误，不设置此值时，用默认的存储引擎替代，并抛出一个异常
      非默认:
        NO_AUTO_VALUE_ON_ZERO: 该值影响自增长列的插入。默认设置下，插入0或者NULL代表生成下一个自增长值。如果用户希望插入的值为0，而该列又是自增长的，那么这个选项就有用了。
        NO_AUTO_CREATE_USER: 禁止GTANT创建密码为空的用户
        PIPES_AS_CONCAT: 将 '||' 视为字符串的连接操作符而非运算符，这和ORACLE数据库是一样的，也和字符串的拼接函数CONCAT相类似
        ANSI_QUOTES: 不能用双引号来引用字符串，因为它被编译为识别符
  数据目录:
    概述:
      - 查看数据目录(/var/lib/mysql/)存放位置 SHOW VARIABLES LIKE '%datadir%'
    核心数据库介绍:
      mysql: 它存储了MYSQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。
      information_schema: 它存储了MYSQL服务器维护的所有其他数据库的信息，比如有哪些表，哪些视图，哪些触发器，哪些列，哪些索引。这些信息并不是真实的用户数据，而是一些描述信息，有时候也称为元数据。有一部分以innodb_sys开头的表，用于表示内部系统表
      performance_schema: 它存储了MYSQL服务器运行过程的一些状态信息，可以用来监控MYSQL服务的各类性能指标。包括统计最近执行了哪些语句，在执行过程的每个阶段花费了多长时间，内存的使用情况等信息。
      sys: 这个数据库主要是通过视图的形式把information_schema和performance_schema结合起来，帮助系统管理员和开发人员监控MYSQL的性能
    表空间:
      概述:
        - 常见的表空有，系统表空间(ibdata1文件)和独立表空间(ibd文件)
        - 表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。
        - 表空间是一个逻辑容器，表空间存储的对象是段，在一个表空间可以有一个或多个段，但是一个段只能属于一个表空间
        - 表空间数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间(System Tablespace)、独立表空间(File-per-table Tablespace)、撤销表空间(Undo Tablespace)、临时表空间(Temporary Tablespace)等
      独立表空间:
        - 独立表空间，即每张表有一个独立的表空间，也就是数据数据和索引信息都会保存在自己的表空间中。
        - 独立表空间可以在不同的数据之间进行迁移。
        - DROP TABLE指令可以回收表空间。
        - 如果对于统计分析或者是日志表，删除大量数据后可以通过，ALTER TABLE t1 ENGIN = InnoDB来回收没有的表空间。
        - 多余使用独立表空间，不管怎么删除，表空间的碎片不会太严重的影响性能。
      系统表空间:
        - 系统表空间的结构和独立表空间基本类似，只不过由于整个MYSQL的进行只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，这部分是独立表空间中没有的。
      Innodb存储引擎下:
        概述:
          - 查看 SHOW GLOBAL VARIABLES LIKE '%innodb_file_per_table%'
          - (默认)值为1代表使用独立表空间(../数据目录/xxx数据库/.ibd文件中)
          - 值为0代表使用系统表空间(../数据目录/ibdata1文件中)
        永久修改: 在my.cnf文件的[server]中 innodb_file_per_table = 1
      MyISAM存储引擎下:
        - 结构则不同，更多细节查看，https://www.bilibili.com/video/BV1iq4y1u7vj?p=104&spm_id_from=pageDriver&vd_source=cc17fab1d456bc3958dcb51e2fdd520b
  配置文件的使用(my.cnf): "
    配置文件有如下常用组
      [server]
      [mysqld]
      [mysqld_safe]
      [mysql.server]
      [mysql]
      [client]
      [mysqladmin]
      [mysqldump]
    启动命令加载到的组
      mysqld         启动服务器  [server] [mysqld]
      mysqld_safe    启动服务器  [server] [mysqld]    [mysqld_safe]
      mysql.server   启动服务器  [server] [mysqld]    [mysql.server]
      mysql          启动客户端  [client] [mysql]
      mysqladmin     启动客户端  [client] [mysqladmin]
      mysqldump      启动客户端  [client] [mysqldump]
  "
  MYSQL逻辑架构:
    概述:
      - MYSQL语句底层执行流程(SQL语句 -> 解析器(语法分析、语义分析，得到语法分析树) -> 优化器(逻辑优化、物理优化、得到查询计划) -> 执行器 -> 查询结果并返回)
    连接层: 连接池
    服务层:
      概述:
        - 查询缓存、SQL接口、解析器、优化器
      MYSQL5.7查询缓存:
        概述:
          - 在mysql5.7有查询缓存，在mysql8.0已经移除
          - 查询缓存非常鸡肋，命中率极低(同样的sql多一个空格都不会被命中)
        使用: "
          #在my.cnf文件中的[mysqld]中设置query_cache_type = 1，默认为关闭，可以开启查询缓存0代表关闭OFF，1代表开启ON，2代表按需使用DEMAND(select SQL_CACHE * from mysql.db,select SQL_NO_CACHE * from mysql.db)
          #查看查询缓存是否开启
          SHOW VARIABLES LIKE '%query_cache_type%'

          SELECT * from mysql.db
          SELECT user from mysql.db

          #查看所有执行过的sql记录
          SHOW PROFILES

          #查询最近一次执行sql的情况
          SHOW PROFILE
          SHOW PROFILE CPU,BLOCK IO
          #查询指定某一次执行sql的情况
          SHOW PROFILE FOR QUERY 2
          SHOW PROFILE CPU,BLOCK IO FOR QUERY 58
        "
    引擎层:
      概述:
        - 可插拔存储引擎 Innodb、MyISAM
      数据库缓冲池:
        概述: 缓冲池装载着磁盘中的数据，避免每次加载磁盘数据过慢，会把热数据加载到缓冲池中
        设置: "
          #缓冲池大小
            #innodb存储引擎默认为128mb，MYISAM存储引擎为key_buffer_size
            SHOW GLOBAL VARIABLES LIKE '%innodb_buffer_pool_size%'

            #临时设置
            #SET @@GLOBAL.innodb_buffer_pool_size = 134217728

            #永久设置
            #在my.cnf文件中的[SERVER]中设置innodb_buffer_pool_size = 134217728


          #缓冲实例个数
            #在并发场景下，多线程访问缓冲池时都需要加锁处理，单一的缓冲池请求的处理速度会慢，所以在缓冲池特别大的时候，我们可以把他们拆分成若干戈小的缓冲池，每个缓冲池都称为一个实例
            #他们都是独立的，独立的去申请内存空间，独立的管理各种链表，在并发访问并不会相互影响，从而提高并发处理能力
            #每个缓冲池大小 = 总大小innodb_buffer_pool_size/实例数innodb_buffer_pool_instances
            #Innodb规定，当innodb_buffer_pool_size小于1GB的时候设置多个缓冲池实例是无效的，Innodb会把实例个数改为1

            #缓存池数量，默认为1个
            SHOW GLOBAL VARIABLES LIKE '%innodb_buffer_pool_instances%'

            #临时设置
            #SET @@GLOBAL.innodb_buffer_pool_instances = 2
            #永久设置
            #在my.cnf文件中的[SERVER]中设置innodb_buffer_pool_instances = 2
        "
      存储引擎:
        概述:
          - 存储引擎就是指标的类型，其实存储引擎以前叫表处理器，后面改名为存储引擎。
          - 存储引擎的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作。
        分类:
          InnoDB:
            概述:
              - mysql5.5之后默认使用
            优点:
              - 支持事务和外键约束
              - 除了insert和select，还有update和delete操作，那么优先选择InnoDB存储引擎
              - InnoDB是为处理巨大数量的最大性能设计的
              - 如果由于硬件或软件的原因导致服务器崩溃，在重启服务器之后不需要进行额外的操作，InnoDB崩溃恢复功能自动将之前提交的内容定型，然后撤销没有提交的进程，重启之后继续从崩溃点开始执行
              - InnoDB存储引擎在主内存中维护了缓冲池，高频率使用的数据将在内存中直接被处理。
            缺点:
              - 相比MYISAM存储引擎，InnoDB对写的处理效率差一些，并且占用更多的磁盘空间以保存数据和索引。
              - MYISAM只缓存索引，不缓存真实数据，InnoDB不仅缓存索引还缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响。
          MYISAM:
            概述:
              - mysql5.5之前默认使用
              - MYISAM提供了全文索引、压缩、空间函数(GIS)等
            优点:
              - 对insert和select效率高
            缺点:
              - 不支持事务和外键约束
              - 不支持行级锁
              - 如果出现宕机后可能导致数据无法恢复
          Archive:
            概述:
              - 归档引擎，仅仅支持insert和select，不支持update和delete
              - MYSQL5.5以后支持索引
              - 拥有很好的压缩机制，使用zlib压缩库。
              - 在记录请求的时候实时的进行压缩，经常被用来作为仓库使用。
              - 归档引擎才用了行级锁，支持AUTO_INCREMENT列属性，AUTO_INCREMENT列可以具有唯一索引或非唯一索引。尝试在任何其他列上创建索引会导致错误。
            优点:
              - 在相同数据量的情况下，相比MYISAM表要节约75%，相比InnoDB表要节约83%
              - 拥有很高的插入速度
            缺点:
              - 对查询的支持较差
            场景:
              - 归档引擎适合日志和数据归档类应用。适合存储大量的独立的作为历史记录的数据
            功能细节:
              B树索引: 不支持
              集群数据库支持: 不支持
              聚集索引: 不支持
              压缩数据: 支持
              数据缓存: 不支持
              加密数据: 支持
              外键: 不支持
              全文检索索引: 不支持
              地理空间数据类型: 支持
              地理空间索引: 不支持
              哈希索引: 不支持
              索引缓存: 不支持
              锁粒度: 行锁
              MVCC: 不支持
              存储限制: 没有任何限制
              交易: 不支持
              更新数据字段的统计信息: 支持
          Blackhole:
            概述:
              - 丢弃写操作，读操作会返回空内容
              - Blackhole存储没有实现任何存储机制，它会丢弃所有的insert插入的数据，不做任何保存。
              - 但服务器会记录Blackhole表的日志，所以它可以用于复制数据库到备库，或者简单的记录日志。但这种应用复方石会碰到很多问题，因为不推荐使用。
          CSV:
            概述:
              - CSV存储引擎存储数据时，以逗号分隔各个数据项。
              - CSV引擎可以将普通的CSV文件作为MYSQL的表来处理，但不支持索引。
              - CSV引擎可以作为一种数据交换的机制，非常有用(普通的CSV文件直接放到数据库文件中，或者拿出数据库文件直接可以打开使用)
          Memory:
            概述:
              - Memory存储引擎采用的逻辑介质是内存，响应速度很快，但是当mysqld守护京城崩溃的时候数据会丢失。
              - 要求数据类型是固定的，长度不固定的不可用(Blob和Text类型的不可用)
              - Memory存储引擎支持哈希索引和B+树索引，默认使用哈希索引。
              - 由于数据只存储在内存中，索引底层的只有一个元数据文件用于存储表结构。
              - Memory存储引擎表的大小是受限制的，取决于2个参数，max_rows和max_heap_table_size，其中max_rows可以在创建表指定，max_heap_table_size默认大小为16MB，可以按需进行扩容
            场景:
              - 目标数据比较小，而且非常频繁的进行访问，在内存中存放数据，如果太大的数据会造成内存溢出。
          Federated:
            概述:
              - Federated存储引擎是访问其他MYSQL服务器的一个代理，尽管改引擎看起来提供了一种很好的跨服务器的灵活性，但是也经常带来问题，因此默认是禁用的。
          Merge:
            概述:
              - Merge存储引擎是管理多个MYISAM表，构成的表集合
          NDB:
            概述:
              - NDB存储引擎是MYSQL集群专用的存储引擎，主要用于MYSQL Cluster分布式集群环境，类似于Oracle的RAC集群。
        InnoDB和MYISAM对比:
          引擎:      MYISAM                     InnoDB
          外键:      不支持                       支持
          事务:      不支持                       支持
          行锁:      不支持                       支持
          表锁:      支持                         支持
          并发:      不适合(操作1条记录导致整表锁住)   适合
          缓存:      只缓存索引                    缓存索引+真实数据
          内存:      内存使用小                    内存使用多
        设置: "
          #查看数据库所有的引擎
          SHOW ENGINES

          #查看默认的存储引擎
          SHOW GLOBAL VARIABLES LIKE '%default_storage_engine%'

          #设置存储引擎
          	#临时设置
          	SET GLOBAL default_storage_engine = InnoDB
          	#永久设置my.cnf
          	# default_storage_engine = InnoDB
        "
索引篇:
  概述:
    - 索引是存储引擎用于快速找到数据记录的一种数据结构
    - 索引的本质就是数据结构，可以理解为排好序的快速查找数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法。
    - 索引是在存储引擎中实现的，因此妹子存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有的索引类型。
    - 存储引擎可以定义每个表的最大索引数和最大索引长度。
    - 所以存储引擎支持每个表至少16个索引，总索引长度至少位256字节。有些存储引擎支持更多的索引数和更大的索引长度。
  优点:
    - 提高数据检索的效率，降低数据库的IO成本
    - 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性
    - 在实现数据的参考完整性方面，可以加速表和表之间的连接。换句话说，对有依赖关系的从表和主表联合查询时，可以提高查询速度
    - 在使用分组和排序子句进行数据查询时，可以显著减少查询中分钟和排序的时间，降低了CPU的消耗(因为索引的排序好的数据结构)
  缺点:
    - 创建索引和维护索引要消耗时间，并且随着数据量的增加，所耗费的时间也会增加
    - 索引需要占用磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间(存储在磁盘上)，如果有大量的索引，索引文件有可能比数据文件更快达到最大文件尺寸
    - 索然索引大大提高了查询速度，同时却会降低更新表的速度。当对表中的数据进行insert、delete、update的时候，索引也要动态维护，这样就降低了数据的维护速度
    - 从空间角度，每建立一个索引都要为它建立一颗b+树，每一颗数的每一个节点都是一个数据页，一个数据页默认会占用16kb的存储空间，一颗很大的树由许多数据页组成，那就是很大的一片存储空间
    - 从时间角度，每次对表的数据进行insert、delete、update，都需要去修改各个b+树索引。
  tips:
    - 如果是大批量的insert、delete、update操作，可以考虑先把索引删除，等把操作做完在从新添加索引。
  b+tree、索引、数据结构:
    b-tree与b+tree的对比:
      - https://www.bilibili.com/video/BV1iq4y1u7vj?p=120&vd_source=cc17fab1d456bc3958dcb51e2fdd520b
      - 在b+tree中，有k个儿子的节点就有k个关键字，也就是儿子数量 = 关键字数，而在b-tree中，儿子数量 = 关键字数量 + 1
      - 在b-tree中非叶子节点的关键字也会同时存在子节点中，并且是在子节点中所有关键字最大(或最小)
      - 在b+tree中，非叶子节点仅用于索引，不保存数据记录，跟记录相关的信息都存放在叶子节点中，而b-tree中，非叶子节点既保存索引，也保存数据记录。
      - 在b+tree中，所有关键字都在叶子节点出现，叶子节点构成一个有序单向链表，而且叶子节点本身按照关键字的大小从小到大顺序链接
    InnoDB存储引擎中的b+tree:
      聚集索引vs非聚集索引:
        概述:
          - 聚集索引也叫聚簇索引(只能1个)
          - 非聚集索引也叫二级索引，或者辅助索引(1个或多个)
        聚集索引:
          概述:
            - img_5聚集索引.png
            - 数据页与数据页之间用双向链表，并且有序
            - 数据与数据之间用单向链表，并且有序
            - 最底部叶子节点存储(完整数据)
          优点:
            - 数据访问更快，因为聚集索引将索引和数据保存在同一个B+树种，因次从聚集索引中获取数据比非聚集索引更快
            - 聚集索引对于主键的排序查询和范围查找速度非常快，因为(数据页和数据)都是按照顺序存放的
            - 按照聚集索引排序顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据页中提取数据，所以节省了大量IO操作
          缺点:
            - 插入速度严重依赖插入顺序，按照主键的顺序插入是最快的方式，否则有可能会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自动增长的主键列
            - 更新主键的代价很高，影响聚集索引和非聚集索引的更新。因此，对于InnoDB表，我们一般定义主键为不可更新
            - 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据
          表中聚集索引的产生:
            - 对于MYSQL数据库，目前只有InnoDB数据引擎支持聚集索引，而MYISAM并不支持聚集索引。
            - 由于数据物理存储排序方式只能有一种，所以每个表只能有一个聚集索引(一个表只能有一个主键)。
            - 如果没有定义主键，InnoDB会选择一个非空+唯一约束的列生成聚集索引。
            - 如果连非空+唯一约束的列都没有，InnoDB会隐式生成一个聚集索引。
            - 为了充分利用聚集索引，所以InnoDB表的主键列尽量选用有序的ID，不建议使用无需的ID，比如(UUID、MD5、HASH、字符串)，因为主键无分发保证数据的顺序增长(维护聚集索引困难)。
        非聚集索引:
          概述:
            - img_6非聚集索引.png
            - 数据页与数据页之间用双向链表，并且有序
            - 数据与数据之间用单向链表，并且有序
            - 最底部叶子节点存储(该列+主键列)
          回表操作:
            - select * from dept where f2 = 4 ，需要回表操作，先在非聚集索引中查找，拿到主键列的值，在去聚集索引中接着查找
            - select f2 from dept where f2 = 4 ，不需要回表操作
          联合索引:
            概述:
              - 参考图img_7非聚集索引(联合索引).png
              - 数据页与数据页之间用双向链表，并且有序
              - 数据与数据之间用单向链表，并且有序
              - 最底部叶子节点存储(联合列f1+联合列f2+主键列)
      b+tree是如何进行记录检索:
        - 如果通过b+tree的索引查询行记录，首先是从b+tree的根页开始，将数据页加载到内存中，页目录中的槽采用二分查找的方式先找到一个粗略的记录分组，然后在分组中通过链表遍历的方式查找到记录，逐层检索，直到找到叶子节点，也就是找到对应的数据为止。
      普通索引和唯一索引在查询效率上的不同:
        唯一索引: 唯一索引就是在普通索引上增加了约束性，也就是关键字唯一，找到了关键字就停止检索
        普通索引:
          - 普通索引可能会存在关键字相同的情况，根据页结构的原理，当我们读取一条记录的时候，不是单独将这条记录从磁盘中读出去，而是将这个记录所在的页加载到内存中进行读取。
          - InnoDB存储引擎的页大小为16KB，在一个页中可能存储着上千个记录，因此在普通索引的字段上进行查找也就是在内存中"多几次判断下一条记录的操作"，对于CPU来说，这些操作所小号的时间是可以忽略不计的。
          - 所以对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本没有差别。
      一般情况下不存在4层b+tree:
        - 一般情况下不存在4层b+tree，所以IO一般为1-3次，因为根层常驻内存
        - 一个数据页有16kb
        - 1层情况下，假设，100(数据页-真实数据) = 100(100条)
        - 2层情况下，假设，1000(数据页-目录) x 100(数据页-真实数据) = 100,000(10万条)
        - 3层情况下，假设，1000(数据页-目录) x 1000(数据页-目录) x 100(数据页-真实数据) = 100,000,000(1亿条)
        - 4层情况下，假设，1000(数据页-目录) x 1000(数据页-目录) x 1000(数据页-目录) x 100(数据页-真实数据) = 100,000,000,000(1千亿条)
      在InnoDB中b+树索引创建机制:
        - 自上而下的创建过程
        - 根节点位置保持不变
        - 内节点中目录项的记录是唯一的(针对非聚集索引产生的非唯一索引)
        - 一个数据页至少存储2条数据
      InnoDB数据存储结构:
        概述:
          - 详情可以参考图，img_9页结构.png
        表空间:
          - 表空间包含段（叶节点段，非叶节点段，回滚段）
          - 表空间是一个逻辑容器
          - 表空间从管理上可以华恩为系统表空间，独立表空间，用户表空间，撤销表空间，临时表空间等。
          - 系统表空间，/root/mysql/data/ibdata1
          - 独立表空间，/root/mysql/data/数据库名/表名.ibd
        段:
          - 段包含区
          - 段是数据库中分配的单位，不同类型的数据对象以不同的段形式存在，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段
          - "
            对于范围查询，其实是对B+tree树叶子节点中的记录进行顺序扫描，而如果不分区分叶子节点和非叶子节点，统统把节点代表的页放到申请区中的话，进行范围扫描的效果就大打折扣了。
            所以InnoDB对B+tree的叶子节点和非叶子节点进行了区别的对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独立的区。存放叶子节点的区的集合就算是一个段，存放非
            叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。

            除了索引的叶子节点段和非叶子节点段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段，所以，场景的段有数据段、索引段、回滚段。数据段即为B+tree的叶子节点，索引段即为B+tree的非叶子节点。

            在InnoDB存储引擎中，多段的管理都是由引擎自神所完成的，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。
            段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页以及一些完整的区组成。
          "
        区:
          - 区包含页
          - 在InnoDB存储引擎中，一个区会分配64个连续的页(目的是为了磁盘的顺序IO)。然而一个页默认的大小为16KB，那么一个区的大小为1MB = 64*16KB
          - "
            B+tree的每一层中的页都会形成一个双向链表，如果是以页为单位来分配存储空间的话，双向链表项链的两个页之间的物理位置可能离的非常远。
            我们介绍B+tree索引的适用场景的时候特别提到范围查询，只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了。
            而如果链表中项链的两个页物理位置离非常远，就是所谓的随机I/O。再一次强调，磁盘的速度和内存的速度差了好几个数量级，随机I/O是非常慢的，
            所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的顺序I/O。

            引入区的概念，一个区就是在物理位置上的连续的64个页。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB=1MB。
            在链表中数据量大的时候，为某个索引分配空间的时候就不在按照页为单位分配了，而是按照【区为单位分配】，甚至在表中的数据特别多的时候，
            可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费(数据不足以填充满整个区)，但是从性能角度看，可以消除很多的随机I/O，功大于过
          "
        碎片区: "
          默认情况下，一个使用InnoDB存储引擎的表只有一个聚集索引，一个索引会产生2个段，而段是以区为单位申请存储空间的，一个区默认占用1M=64*16KB存储空间，
          所以默认情况下一个只存了几条记录的小表也需要2M的存储空间，以后每次添加一个索引都要多申请2M的存储空间，多余存储记录比较少的表简直是有点过于浪费。
          这个问题的症结在于到现在为止我们介绍的区都是非常纯粹的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，
          即使段的数据填不满区中的所有页，那余下的页也不能挪给其他地方用。

          为了考虑完整的区为单位分配给某个段多于数据量较小的表太浪费存储空间的这种情况，InnoDB提出了一个碎片区的概念。在一个碎片区中，并不是所有的页都是为了存储
          同一个段的数据而存储在，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。【碎片区直属于表空间】，并不属于任何一个段
        "
        页:
          概述:
            - 页包含行
            - InnoDB将数据划分为若干个页，默认大小为16kb。
            - 查看innodb数据页的大小 SHOW VARIABLES LIKE '%innodb_page_size%'
            - 以页作为磁盘和内存之间交互的基本单位，也就是一次最少从磁盘中读取16KB的数据到内存中，一次最少把内存中的16KB数据刷到磁盘中
            - 在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。
            - 数据库管理存储空间的基本单位为页，数据库IO操作的最小单位是页，一个页中可以存储多个行记录。
            - 记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取只能处理一行数据，效率会非常低，IO次数也会变多。
            - 常见的页有，数据页(B+tree节点)，系统页，Undo页，事务数据页等
          数据页结构:
            文件头FileHeader(38字节):
              概述:
                - 描述各种页的通用信息，比如页的编号，上一页和下一页的信息等。
              结构:
                FIL_PAGE_TYPE(2字节):
                  概述:
                    - 该页的类型
                  如下类型:
                    FIL_PAGE_TYPE_ALLOCATED: 0x0000 最新分配，还没使用
                    FIL_PAGE_UNDO_LOG: 0x0002 Undo日志页
                    FIL_PAGE_INODE: 0x0003 段信息节点
                    FIL_PAGE_IBUFF_FREE_LIST: 0x0004 Insert Buffer空间列表
                    FIL_PAGE_IBUF_BITMAP: 0x0005 Insert Buffer位图
                    FIL_PAGE_TYPE_SYS: 0x0006 系统页
                    FIL_PAGE_TYPE_TRX_SYS: 0x0007 事务系统数据
                    FIL_PAGE_TYPE_FSP_HDR: 0x0008 表空间头部信息
                    FIL_PAGE_TYPE_XDES: 0x0009 扩展描述页
                    FIL_PAGE_TYPE_BLOB: 0x000A 溢出页
                    FIL_PAGE_INDEX: 0x45BF 索引页，也就是我们说的数据页
                File_PAGE_SPACE_OR_CHKSUM(4字节):
                  概述:
                   - 页的校验和checksum值
                   - 该校验和在文件头和文件尾都有，用于刷盘的时候做校验，判断是否全部刷盘完成，如何文件头和文件尾的校验和是一致，则代表完成，如果不一直，有可能是中途出现宕机等情况，则需要做相应的恢复操作。
                FIL_PAGE_LSN(8字节): 页面被最后修改时对应的日志序列位置（英文名是 Log Sequence Number）
                FIL_PAGE_OFFSET(4字节): 每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号可以唯一定位一个页
                FIL_PAGE_PREV(4字节): 上一个页的页号，实现页与页之间逻辑连接(双向链表)
                FIL_PAGE_NEXT(4字节): 下一个页的页号，实现页与页之间逻辑连接(双向链表)
                FIL_OAGE_FILE_FLUSH_LSN(8字节): 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值
                FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID(4字节): 页属于哪个表空
            文件尾FileTrailer(8字节):
              概述:
                - 文件尾，检验页是否完整，配合文件头FileHeader一起使用。
                - 前4字节代表页的校验和，和FileHeader中的File_PAGE_SPACE_OR_CHKSUM对应
                - 后4字节代表页面被最后修改时对应的日志序列位置（英文名是 Log Sequence Number），和FileHeader中的FIL_PAGE_LSN对应
            空闲空间FreeSpace(不确定):
              概述:
                - 空闲空间，页中还有多少可以使用的空间
                - 我们自己存储的记录会按照指定的行格式存储到UserRecords部分，但是在一开始生成页的时候，其实并没有UserRecords这个部分。
                - 当我们插入一条记录，都会从FreeSpace中申请一个记录大小的空间划分到UserRecords，当FreeSpace部分的空间全部被UserRecords申请完，如果有还记录插入，就需要去申请新的页了
            用户记录UserRecords(不确定):
              概述:
                - 用户记录，存储行记录内容
                - 记录按照指定的行格式，一条一条的记录在UserRecords部分，相互之间形成单链表。
              结构(以Compact格式为例):
                变长字段长度列表(2字节):
                  - 对变长的数据类型做记录，比如VARCHAR、TEXT、BLOB等。
                  - 在Compact行格式中，把所有边长字段的真实数据占用的字节长度哦度存放在记录的开头部位，从而形成一个边长字段长度列表
                NULL值列表(1字节):
                  - Compact行格式会把可以为NULL的列统一管理起来，存在一个标记为NULL值列表中。如果表中没有允许存储NULL的列，则NULL值列表也不存在了
                  - 之所以要存储NULL是因为数据都是需要对齐的，如果没有标注出来NULL值的位置，就有可能在查询数据的时候出现混乱，如果使用一个特定的符号放到响应的数据位表示的话，虽然能达到效果，但是这样很浪费空间，所以直接就在行数据头统一记录
                记录头信息(5字节):
                  结构:
                    预留位1(1bit): 没有使用
                    预留位2(1bit): 没有使用
                    DELETE_MASK(1bit):
                      概述:
                        - 标记该记录是否被删除，0代表没删除，1代表删除
                        - 这些被删除的记录不会立即从磁盘上移除，因为出一他们之后其他的记录在磁盘上需要重新排列和移动，导致性能消耗
                        - 被删除的记录只是标记而已，所有被删除掉的记录会利用(NEXT_RECORD)组成一个所谓的垃圾链表，在这个链表中的记录占用的空间称之为可重用空间，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。
                    MIN_REC_MASK(1bit):
                      概述:
                        - B+tree的每层非叶子节点中的最小记录都会添加该标记，MIN_REC_MASK = 1
                        - 我们自己插入的记录MIN_REC_MASK = 0 ，以为着他们都不是B+tree的非叶子节点中的最小记录
                    RECORD_TYPE(3bit):
                      概述:
                        - 表示当前记录的类型
                        - 0表示普通记录
                        - 1表示B+tree树非叶子节点记录
                        - 2表示最小记录
                        - 3表示最大记录
                    HEAP_NO(13bit):
                      - 表示当前记录在记录堆的位置信息
                      - 存储引擎会自动给每个页里面加了2个记录，由于这2个记录并不是我们这插入的，所以成为伪记录或者叫虚拟记录。
                      - 这两个虚拟记录一个代表最小记录(0)，一个代表最大记录(1)
                      - 用户插入的记录则标记为(2,3,4,5,6,.....)
                    N_OWNED(4bit):
                      概述:
                        - 页目录PageDirectory中每个组中最后一条记录的会利用该部分N_OWNED会记录该组一共有多少条记录，其他记录则用0表示
                    NEXT_RECORD(16bit):
                      概述:
                        - 该部分就是形成记录的单向链表，不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单向链表，链表中的各个节点是按照【索引列】的值由小到打的顺序连接起来
                        - 它表示从当前记录到下一条记录的地址偏移量，比如第一条记录的next_record的值为32，意味着从第一条记录的地址处向后找32个字节便是下一条记录
                        - 最小记录(Infimum)记录的下一条记录就是该数据页的中【索引列】最小的用户记录，该数据页中的【索引列】最大的用户记录的下一条记录就是最大记录(Supermum)
                        - 一条记录被删除的时候DELETE_MASK变为1，并且NEXT_RECORD为0，如果是多条记录，则NEXT_RECORD会形成一个垃圾链表，在这个链表中的记录占用的空间称之为可重用空间，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。
                f1列的值: 用户列
                DB_ROW_ID列的值(6字节):
                  - 隐藏列，行ID，唯一标识一条记录
                  - 当一个表创建时，没指定主键以及Unique，则默认会为表添加一个DB_ROW_ID列作为主键，所以DB_ROW_ID是在没有自定义主键以及Unique的情况下才存在
                DB_TRX_ID列的值(6字节): 隐藏列，事务ID
                DB_ROLL_PRT列的值(7字节): 隐藏列，回滚至臻
                fn列的值: 用户列
              行格式:
                概述:
                  - 查看默认的行格式 SHOW VARIABLES LIKE '%innodb_default_row_format%'
                  - 查看表的行格式 SHOW TABLE STATUS WHERE Name = 't1'
                  - 分别有Compact格式(MYSQL5.1默认)、Dynamic格式(MYSQL5.7-8.0默认)、Compressed格式、Redundant格式(MYSQL5.0之前默认)
                  - 不同的行格式存储结构数据的结构有所不同，以及对行溢出的处理方式也不同
                行溢出:
                  - 如果创建一个字节 varchar(60000) ，那么一个数据页的大小默认为16KB，这样可能出现一个页存放不了一条记录，这样现象称为行溢出。
                  - Dynamic格式和Compressed格式对于存放在BLOB中的数据采用了完全的行溢出方式，在行记录中只存放20个字节溢出页的偏移地址，实际的数据都存放在溢出页中(Off Page)
                  - Compressed格式的另一个功能就是，存储在其中的行数据会以zlib的算法进行压缩，因此对于BLOB、TEXT、VARCHAR这类大长度类型的数据能够进行非常有效的存储。
                  - Compact格式和Redundant格式会在记录真实数据处存储一部分真实数据(存放768个前缀字节)
            最小记录(Infimum)(13字节):
              概述:
                - 记录UserRecords中的最小记录，这是虚拟的行记录
              结构:
                记录头信息(5字节): 参考用户记录UserRecords的记录头
                记录体信息(8字节): Infimum(69 6E 66 69 6D 75 6D 00)
            最大记录(Supermum)(13字节):
              概述:
                - 记录UserRecords中的最大记录，这是虚拟的行记录
              结构:
                记录头信息(5字节): 参考用户记录UserRecords的记录头
                记录体信息(8字节): Supermum(73 75 70 72 65 6D 75 6D)
            页目录PageDirectory(不确定):
              概述:
                - 在数据页中，记录是以单向链表的形式进行存储的，单双链表的缺点就是查询慢，增删快。因此，在数据页中专门设计了页目录这个部分，专门给记录提供一个目录用于2分查找法进行检索定位,提升性能。
                - 将所有记录分组【最小记录(Infimum)+用户记录UserRecords+最大记录(Supermum)】，不包跨DELETE_MASK=1的记录
                - 页目录的基本单位为【槽】，用于存储每个分组中【最大值(索引列的值)记录的地址偏移量】
              分组规则:
                - 第一组，最小记录(Infimum)，1条记录，槽的偏移量为Infimum
                - 第二组，用户记录UserRecords+最大记录(Supermum)，1-8条记录，槽的偏移量为Supermum
                - 其余组，用户记录UserRecords，4-8条记录，槽的偏移量为最大值(索引列的值)记录的地址偏移量
            页头PageHeader(56字节):
              概述:
                - 这个页头记录着关于这个数据页的各项指标信息
              结构:
                PAGE_N_DIR_SLOTS(2字节): 在页目录中槽的数量
                PAGE_HEAP_TOP(2字节): 还未使用的空间最小地址，也就是说从该地址之后就是FreeSpace
                PAGE_N_HEAP(2字节): 本页中记录的数量(包括最小和最大记录以及标记为删除的记录)
                PAGE_FREE(2字节): 第一个已经标记为删除的记录地址(各个已删除的记录通过next_record也会组成一个单向链表，这个单向链表中的记录可以被重新利用)
                PAGE_GARBAGE(2字节): 已删除记录占用的字节数
                PAGE_LAST_INSERT(2字节): 最后插入记录的位置
                PAGE_DIRECTION(2字节): 记录插入的方向
                PAGE_N_DIRECTION(2字节): 一个昂新连续插入的记录数量
                PAGE_N_RECS(2字节): 该页中记录的数量(不包括最小和最大记录以及被标记为删除的记录)
                PAGE_MAX_TRX_ID(8字节): 修改当前页的最大事务ID，该值仅在非聚集索引中定义
                PAGE_LEVEL(2字节): 当前页在B+tree中所处的层级
                PAGE_INDEX_ID(8字节): 索引ID，表示当前页属于哪个索引
                PAGE_BTR_SEG_LEAF(10字节): B+tree叶子段的头部信息，仅在B+tree的Root页定义
                PAGE_BTR_SEG_TOP(10字节): B+tree非叶子段的头部信息，仅在B+tree的Root页定义
        行:
          - 行包含字段长度偏移列表，记录头信息，列1....列n
      数据页加载的三种方式:
        概述:
          - InnoDB从磁盘中读取数据的最小单位是页，而你想得到某一条具体的数据时，这时候就需要从诸多页中获取其中的一行。
          - 对于MYSQL存放的数据，逻辑概念上我们称之为表，在磁盘等物理层面是按数据页形式存放的，当其加载到MYSQL中我们称之为缓存页
          - 如果缓冲池中没有该页数据，那么缓冲池可以使用(内存读取、随机读取、顺序读取)，每种方式的读取效率都不同。
        内存读取: 如果该数据存在于内存中，基本上执行时候在1ms左右
        随机读取(随机IO): 如果数据没有在内存中，就需要在磁盘上对该页进行，整体时间预估在10ms左右 = 3ms排队 + 4ms寻道 + 2ms半圈旋转 + 1ms传输
        顺序读取(顺序IO): "
          顺序读取其实是一种批量读取方式，因为我们请求的数据在磁盘上往往都是相邻存储的，顺序读取可以帮我们批量读取页面，这样的话，一次性
          加载到缓冲池中就不需要再对其他页面单独进行磁盘IO操作了，如果一个磁盘的吞吐量是40MS/s，那么对一个16KB大小的页来说，一次可以
          顺序读取2560个页(40MB/16KB)，相当于一个页的读取时间约为0.4ms。采用批量读取的方式，即使是从磁盘上进行读取，效率也比从内存中
          单独读取一个页的效率要高
        "
      段分配存储空间策略: "
        在刚开始向表中插入数据的时候，段是从某个碎片区以单个页为单位来分配存储空间的。
        当某个段已经占用了32个碎片区页面之后，就会申请以完整的区为单位来分配存储空间。
        段应该是某个零散的页面的集合，以及一些完整的区的集合。
      "
      区的分类:
        直属于表空间的区:
          空闲区(FREE): 现在还没有用到这个区中中的任何页
          有剩余空间的碎片区(FREE_FRAG): 表示碎片区中还有可用的页
          没有剩余空间的碎片区(FULL_FRAG): 表示碎片区种方法的所有页都被使用，没有空闲的页
        直属于某个段的区:
          隶属于某个段的区(FSEG): 每一个索引都可以分为叶子节点段和非叶子节点段
    MYISAM存储引擎中的b+tree:
      概述:
        - img_8MYISAM存储引擎b-tree.png
        - MYISAM存储引擎中b-tree不分聚集和非聚集索引，但是可以理解为非聚集索引
        - MYISAM存储引擎中非聚集索引的数据页中的真实数据区域存储的是数据的偏移地址
        - MYISAM存储引擎中将索引和数据分别存储在不同文件中
        - 将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为数据文件。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。
        - 由于插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找
      回表:
        - 在MYISAM中查找到数据以后，由于叶子节点存储的是数据的偏移地址，所以还需要在去对应的文件中找到具体的数据
    InnoDB和MYISAM比对:
      - 在InnoDB存储引擎中，我们只需要根据主键值对聚集索引进行一次查找就能够找到对应的记录，而在MYISAM中却需要进行额外的一次回表操作，意味着MYISAM中建立的索引相当于全部都是非聚集索引。
      - InnoDB的数据文件本身就是索引文件，而MYISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址
      - InnoDB的非聚集索引data域存储相应的记录主键的值，而MYISAM索引记录的是地址。
      - 在非聚集索引中，MYISAM的回表操作十分快速的，因为是拿着地址偏移量直接到文件中取数据，InnoDB是通过获得主键之后在到聚集索引中查找记录，虽然说也不慢，但还是比不上直接用地址去访问
      - InnoDB要求表必须有主键(MYISAM可以没有)，在InnoDB中如果没有显示指定，则会自动选择一个非空+唯一约束的列作为主键，如果这样的列也不存在，则InnoDB表会自动生成一个隐藏列作为主键，这个列的长度为6个字节，类型为长整形
调优篇:
  - 满外连接(LEFT OUTER JOIN)的时候，尽量用UNION ALL(不需要去重)，少用UNION(需要去重)
事务篇:
日志与备份篇:
