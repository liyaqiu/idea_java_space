介绍:
  版本(8.0.26)&安装:
    - 社区版本（Mysql Community Server），开源免费
    - 集群版本（Mysql Cluster），开源免费，用户架设集群服务器，可以将几个MySQL Server封装成一个Server，需要在社区版或者企业版基础上使用
    - 企业版本 付费
    - 高级集群版 付费
  命令行:
    - mysql -uroot -p123456 -P3306 -h192.168.88.1
  查看字符集以及修改字符集:
    - "
      查看
        SHOW VARIABLES like 'character_%';
        SHOW VARIABLES like 'collation_%';
      修改，在my.cnf，在5.7版本中需要修改，8.0默认为utf8mb4
        [mysql]
        default-character-set = utf8
        [mysqld]
        character_set_server=utf8
        collation-server=utf8_general_ci
    "
  客户端工具:
    - navicat
    - dbeaver https://dbeaver.io/download/ ，需要依赖jre
  sql文件的导入方式:
    - source  /root/xxx.sql
    - 图形化界面导入 xxx.sql
SQL优化:
  - 满外连接(LEFT OUTER JOIN)的时候，尽量用UNION ALL(不需要去重)，少用UNION(需要去重)
重中之重:
  SQL92语法&SQL99语法: "
    SQL92
      SELECT ...,...,...(存在聚合函数)
      FROM ...,...,...
      WHERE 多表的连接条件 AND 不包含聚合函数的过滤条件
      GROUP BY ...,...
      HAVING 包含聚合函数的过滤条件
      ORDER BY ...,...(ASC/DESC)
      LIMIT ...,...
    SQL99
      SELECT ...,...,...(存在聚合函数)
      FROM ... (LEFT/RIGHT) JOIN ON 多表的连接条件
      WHERE 不包含聚合函数的过滤条件
      GROUP BY ...,...
      HAVING 包含聚合函数的过滤条件
      ORDER BY ...,...(ASC/DESC)
      LIMIT ...,...
  "
  SQL执行过程: "
    FROM ...
          (LEFT/RIGHT) JOIN ON
            WHERE 不包含聚合函数的过滤条件
              SELECT ...,...,...(存在聚合函数)
                GROUP BY ...,...
                  HAVING 包含聚合函数的过滤条件
                    ORDER BY ...,...(ASC/DESC)
                      LIMIT ...,...
    案例
    SELECT
      department_id DID,
      job_id JID,
      AVG( salary ) ,
      SUM( salary ) SUM_
    FROM
      employees
    WHERE department_id > 80
    GROUP BY
      DID, job_id
    HAVING
      SUM_ > 20000 AND AVG( salary ) > 5000
    ORDER BY SUM_
    LIMIT 2
  "
  子查询可以写的位置: "
    除了【GROUP BY】和【LIMIT】不允许写子查询，其他地方都可以写
    SQL99
      SELECT ...,...,...(存在聚合函数)
      FROM ... (LEFT/RIGHT) JOIN ON 多表的连接条件
      WHERE 不包含聚合函数的过滤条件
      GROUP BY ...,...
      HAVING 包含聚合函数的过滤条件
      ORDER BY ...,...(ASC/DESC)
      LIMIT ...,...
  "
MYSQL8.0新特性:
  DDL操作支持原子化: "
    drop table t1,t2 假设t1不存在，2存在，那么最后t1,t2都不会被删除
  "
  计算列: "
    类似于vue中的计算属性，5.7版本也是支持的
    CREATE TABLE if NOT EXISTS t1(
    	a int,
    	b int,
    	c int GENERATED ALWAYS as (a+b) VIRTUAL
    )
  "
  自增列: "
    MYSQL8.0中，会对自增列(AUTO_INCREMENT)做持久化处理，也就是重启服务器自动增长列的数据还是能找到最后的那个，在MYSQL5.7则不行
  "
  检查约束(check): "
    mysql5.7可以写检查约束，但实际不生效，但在mysql8.0则是生效的
  "
SQL分类:
  DDL(数据定义语言):
    概述:
      - 数据定义语言(Data Definition Language)
      - 定义了不同的数据库，表，视图，索引等数据库对象，还可以用来创建，删除，修改数据和数据库表的结构
      - create \ alert \ drop \ rename \ truncate
      - 所有的DDL操作会默认提交事务，并且不支持【手动】事务回滚
    操作数据库:
      创建/修改/删除数据库: "
        创建
          坑：数据库名一旦创建不允许修改
          CREATE DATABASE t1
          CREATE DATABASE t1 CHARACTER SET utf8mb4
          CREATE DATABASE t1 CHARSET=utf8
          CREATE DATABASE IF NOT EXISTS t1 CHARACTER SET utf8mb4 (推荐使用)
          CREATE DATABASE IF NOT EXISTS t1 CHARSET=utf8 (推荐使用)
        修改
          ALTER DATABASE t2 CHARACTER SET utf8
        删除
          DROP DATABASE t2
          DROP DATABASE IF EXISTS t2 (推荐使用)
    "
    操作表:
      创建表(CREATE TABLE):
        方式1: "
            CREATE TABLE IF NOT EXISTS t1 (

              f2 INT, # 定义有符号int
              f3 INT UNSIGNED, # 定义无符号int
              f4 INT(255) UNSIGNED ZEROFILL, # 指定宽度，不会影响实际的容量，表示位数不足时用0填充做显示，mysql8.0已经不推荐使用

              f5 DOUBLE, # 定义双精度浮点类型，使用实际容量
              f6 DOUBLE(8,3), # 指定容量，表示一共可以存储8位，整数位最多为5位，小数位最多为3位，mysql8.0不推荐这样使用了

              f8 DECIMAL(10,2), # 默认为decimal(10,0)，小数位会进行四舍五入

              f9 BIT(2), #默认为1位

              f10 DATETIME,

              f11 CHAR(255) CHARACTER SET utf8mb4,
              f12 VARCHAR(10000) CHARACTER SET utf8mb4, #指定字段字符集，不指定则使用表的字符集
              f13 ENUM('男','女') CHARACTER SET gbk,
              f14 SET('你好','hello','哈哈') CHARACTER SET gbk,

              f15 BINARY(1),
              f16 VARBINARY(3),

              f17 JSON
            )
            #指定表的字符集
            DEFAULT CHARACTER SET gbk;
        "
        方式2: "
          利用select(结构和数据)，注意主键和索引复制不了
            CREATE TABLE IF NOT EXISTS t1 SELECT * FROM employees
            CREATE TABLE IF NOT EXISTS t1 AS SELECT * FROM employees
        "
      修改表(ALTER TABLE):
        添加字段: "
          添加一个字段在最尾部
            ALTER TABLE t1
            ADD [COLUMN] salary DOUBLE(10,2)
          添加一个字段在最前面
            ALTER TABLE t1
            ADD [COLUMN] salary DOUBLE(10,2) FIRST
          添加一个字段在指定字段的后面
            ALTER TABLE t1
            ADD [COLUMN] salary_copy DOUBLE(10,2) AFTER salary
        "
        修改字段: "
          修改一个字段的类型
            ALTER TABLE t1
            MODIFY [COLUMN] salary DOUBLE(20,2) DEFAULT 0.00
          修改一个字段的类型+移动到最前面
            ALTER TABLE t1
            MODIFY [COLUMN] salary DOUBLE(20,2) DEFAULT 0.00 FIRST
          修改一个字段的类型+移动指定字段的后面
            ALTER TABLE t1
            MODIFY [COLUMN] salary DOUBLE(20,2) DEFAULT 0.00 AFTER salary
          重命名一个字段+修改类型
            ALTER TABLE t1
            CHANGE [COLUMN] salary new_salary DOUBLE(30,2) DEFAULT 0.00
        "
        删除字段: "
          ALTER TABLE t1
          DROP [COLUMN] salary
        "
        修改表名: "
          方式1
            ALTER TABLE t1
            RENAME to t2
          方式2
            RENAME TABLE t2
            TO t1
        "
      删除表(DROP TABLE): "
        DROP TABLE t1,t2
        DROP TABLE IF EXISTS t1,t2 (推荐)
      "
    其它操作: "
        查看当前连接都有哪些数据库
          SHOW DATABASES
        查看数据库的创建信息
          SHOW CREATE DATABASE t1
        切换数据库
          USE t1
        查看正在使用的是哪个数据库
          SELECT DATABASE()
        查看当前数据库都有哪些表、或视图
          SHOW TABLES
        查看某个数据库都有哪些表
          SHOW TABLES FROM dbname
        查看表结构
          DESC t1
        查看表的创建信息
          SHOW CREATE TABLE t1
        清空所有表数据（所有的DDL操作会默认提交事务，并且不支持【手动】事务回滚）
          TRUNCATE t1
          TRUNCATE TABLE t1
        查看表、视图的属性信息
          SHOW TABLE STATUS LIKE 'table_name'
      "
    字段类型:
      数值类型:
        整数类型:
          TINYINT:    字节1 无符号0-255                  有符号(-128~127)
          SMALLINT:   字节2 无符号0-65535                有符号(-32768~32767)
          MEDIUMINT:  字节3 无符号0-16777215             有符号(-8388608~8388607)
          INT/INTGER: 字节4 无符号0-4294967295           有符号(-2147483648~2147483647)
          BIGINT:     字节8 无符号0-18446744073709551615 有符号(-9223372036854775808~9223372036854775807)
        浮点类型&定点数类型:
          概述:
            - 浮点类型 FLOAT(4字节)、DOUBLE(8字节)，在算术运算时存在丢失精度问题，存在四舍五入，浮点数加了无符号(UNSIGNED)反而存储范围更小
            - 定点数类型 DECIMAL(M,D)/DEC(M,D)/NUMERIC(M,D)，M范围最大65 占用(M+2)字节，存在四舍五入
          区别:
            - 浮点类型，优点字节数占用小，缺点丢失精度问题
            - 定点数类型，优点不丢失精度，缺点字节数占用大
        位类型: BIT(M)约为(M+7)/8个字节
      日期时间类型:
        YEAR:         字节1 格式YYYY/YY               范围1901~2155
        TIME:         字节3 格式HH:MM:SS              范围-838:59:59~838:59:59
        DATE:         字节3 格式YYYY-MM-DD            范围1000-01-01~9999-12-03
        DATETIME:     字节8 格式YYYY-MM-DD HH:MM:SS   范围1000-01-01 00:00:00~9999-12-31 23:59:59
        TIMESTAMP:    字节4 格式YYYY-MM-DD HH:MM:SS   范围1970-01-01 00:00:00 UTC~2038-01-19 03:14:07UTC (底层存储的时间戳，会根据数据库时区配置进行转换显示)
      字符串类型:
        文本字符串类型:
          VARCHAR(M)&CHAR(M):
            概述:
              - CHAR(M) 最大可配置255字符  实际占用字节数看字符集编码，存储不足时会在尾部填充空格，检索时会去除尾部空格
              - VARCHAR(M) 最大可配置=65535字符/字符集  实际占用字节数看字符集编码+1
            区别:
              - MyISAM存储引擎，最好使用CHAR代替VARCHAR，使得整个表静态化，从而数据检索更快，用空间换时间
              - InnoDB存储引擎，使用VARCHAR比较好，因为内部的行存储格式并没有区分固定长度和可变长度列(所有数据行都使用指向数据列值的头指针)，而且主要影响性能的因素是数据行使用的存储总量
          可变TEXT:
            TINYTEXT:   不允许做主键 实际可存字符 = 范围0~255字节/字符编码，               总占用字节 = 实际可存字符+2
            TEXT:       不允许做主键 实际可存字符 = 范围0~65535字节(=64KB)/字符编码，      总占用字节 = 实际可存字符+2
            MEDIUMTEXT: 不允许做主键 实际可存字符 = 范围0~16777215字节(=16MB)/字符编码，   总占用字节 = 实际可存字符+3
            LONGTEXT:   不允许做主键 实际可存字符 = 范围0~4294967295字节(=4GB)/字符编码，  总占用字节 = 实际可存字符+4
          ENUM&SET:
            - ENUM('男','女') 实际可存字符 = 容量65535/字符编码 占用字节 = 字符编码
            - SET('你好','hello','哈哈')    占用字节 = 字符编码
        二进制字符串类型:
          BINARY(M)&VARBINARY(M):
            - BINARY(M) 最大可配置255 占用字节M个字节
            - VARBINARY(M) 最大可配置65535 占用字节M+1个字节
          可变BLOB:
            TINYBLOB:      范围0~255字节                 总占用字节 = 实际字节+1
            BLOB:          范围0~65535字节(=64KB)        总占用字节 = 实际字节+2
            MEDIUMBLOB:    范围0~16777215字节(=16MB)     总占用字节 = 实际字节+3
            LONGBLOB:      范围0~4294967295字节(=4GB)    总占用字节 = 实际字节+4
        JSON类型: "
            INSERT INTO '(f17) VALUES ('{
            	'name': 'eric',
            	'age': 18,
                                                             'hobbies': [
              '吃饭', '睡觉', '打豆豆'
              ]
            }')
            SELECT f17 -> '$.name' 名字 , f17 ->> '$.hobbies[2]' 爱好 FROM t1
          "
      空间数据类型:
        单值: GEOMETRY、POINT、LINESTRING、POLYGON
        集合: MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION
    约束:
      分类:
        - 单列约束(约束单个字段)和多列约束(约束多个字段)
        - 列级约束(跟字段在同一行声明的约束)和表级约束(不跟字段在同一行声明的约束)
      概述:
        - 约束是为了保证数据完整性，SQL规范以约束的方式对表数据进行额外的条件限制
        - 查看一个表的所有约束 SELECT * FROM information_schema.TABLE_CONSTRAINTS WHERE table_name = 't1'
        - 查看一个表的结构 desc t1
        - 更直接的可以查看sql语句 SHOW CREATE TABLE t1
        - 查看一个表的索引 SHOW INDEX FROM t1
      4个方面考虑完整性:
        - 实体完整性，例如，同一个表中，不能存在两条完全相同的记录
        - 域完整性，例如，年龄范围0-120，性别范围男/女
        - 引用完整性，例如，员工所在部门，在部门表中要能找到这个部门
        - 用户自定义完整性，例如，用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍
      非空约束(not null): "
        DROP TABLE IF EXISTS t1 ;
        CREATE TABLE if NOT EXISTS t1(
        	f1 VARCHAR(5) NOT NULL,
        	f2 VARCHAR(5)
        ) DEFAULT CHARACTER SET utf8mb4;


        SHOW CREATE TABLE t1;

        DESC t1;

        #将f2设置为不能为空
        ALTER TABLE t1
        MODIFY f2  VARCHAR(5) NOT NULL

        #添加一个新列，并且设置不能为空
        ALTER TABLE t1
        ADD f3  VARCHAR(5) NOT NULL

        #将f1设置可以为null
        ALTER TABLE t1
        MODIFY f1  VARCHAR(5) NULL

        #将f1设置可以为null
        ALTER TABLE t1
        MODIFY f1  VARCHAR(5) DEFAULT NULL

        #将f1设置可以为null
        ALTER TABLE t1
        MODIFY f1  VARCHAR(5)

      "
      默认值约束(default): "
        DROP TABLE IF EXISTS t1 ;
        CREATE TABLE if NOT EXISTS t1(
        	f1 VARCHAR(5) DEFAULT 'xxx',
        	f2 VARCHAR(5)
        ) DEFAULT CHARACTER SET utf8mb4;
        SHOW CREATE TABLE t1;

        DESC t1;

        #修改f1的默认值得为Null
        ALTER TABLE t1
        MODIFY f1  VARCHAR(5) DEFAULT NULL

        #为f2添加默认值为 hello
        ALTER TABLE t1
        MODIFY f2  VARCHAR(5) DEFAULT 'hello'

        #添加一个新列，并且设置默认值为 yyy
        ALTER TABLE t1
        ADD f3  VARCHAR(5) DEFAULT 'yyy'

        #删除默认值
        ALTER TABLE t1
        MODIFY f1  VARCHAR(5) DEFAULT NULL
        #MODIFY f1  VARCHAR(5)
      "
      唯一约束(unique):
        - 允许null值，每列数据不能重复
        - "
        DROP TABLE IF EXISTS t1 ;
        CREATE TABLE if NOT EXISTS t1(
        	f1 VARCHAR(5) UNIQUE ,

        	f2 VARCHAR(5) ,
        	UNIQUE  f2_name (f2),

        	f3 VARCHAR(5) ,
        	UNIQUE (f3),

        	f4 VARCHAR(5) ,
        	CONSTRAINT f4_name UNIQUE (f4) ,

        	f5 VARCHAR(5) ,
        	f6 VARCHAR(5) ,

        	f7 VARCHAR(5) ,
        	f8 VARCHAR(5) ,
        	UNIQUE f7_f8 (f7,f8)

        ) DEFAULT CHARACTER SET utf8mb4;

        DESC t1;

        SELECT * FROM information_schema.TABLE_CONSTRAINTS WHERE table_name = 't1';



        SHOW CREATE TABLE t1;



        #为f5添加唯一索引
        ALTER TABLE t1
        ADD UNIQUE (f5)
        #MODIFY f5  VARCHAR(5) UNIQUE

        #删除f5的唯一索引
        ALTER TABLE t1
        DROP INDEX f5


        #为f6添加唯一索引并且取名为uni_f6
        ALTER TABLE t1
        ADD UNIQUE uni_f6 (f6)
        #ADD UNIQUE KEY uni_f6 (f6)
        #ADD CONSTRAINT uni_f6  UNIQUE  (f6)
        #ADD CONSTRAINT uni_f6  UNIQUE KEY  (f6)

        #删除f6的唯一索引
        ALTER TABLE t1
        DROP INDEX uni_f6


        #为f5,f6添加唯一索引
        ALTER TABLE t1
        ADD UNIQUE (f5,f6)

        #删除f5,f6的唯一索引
        ALTER TABLE t1
        DROP INDEX f5

        #为f5和f6添加唯一索引并且取名为uni_f5_f6
        ALTER TABLE t1
        #ADD UNIQUE uni_f5_f6 (f5,f6)
        #ADD UNIQUE KEY uni_f5_f6 (f5,f6)
        ADD CONSTRAINT uni_f5_f6  UNIQUE  (f5,f6)
        #ADD CONSTRAINT uni_f5_f6  UNIQUE KEY  (f5,f6)

        #删除f5,f6的唯一索引
        ALTER TABLE t1
        DROP INDEX uni_f5_f6
      "
      主键约束(primary key):
        - 不允许null值，每列数据不能重复
        - 一个表只能有一个主键约束(底层数据结构需要根据主键创建B+tree)
        - 无需命名，就算命名也不生效，默认名字就叫(PRIMARY)
        - "
          DROP TABLE IF EXISTS t1 ;
          CREATE TABLE if NOT EXISTS t1(
          	#方式1,主键默认都会加上 NOT NULL
          	#f1 VARCHAR(5) PRIMARY KEY,

          	#方式2,主键默认都会加上 NOT NULL
          	#f1 VARCHAR(5) ,
          	#PRIMARY KEY (f1)
          	#CONSTRAINT PRIMARY KEY (f1)

          	#方式3,主键默认都会加上 NOT NULL，复合主键多列加NOT NULL
          	#f1 VARCHAR(5),
          	#f2 VARCHAR(5),
          	#PRIMARY KEY (f1,f2)
          	#CONSTRAINT PRIMARY KEY (f1,f2)

          	f1 VARCHAR(5)

          ) DEFAULT CHARACTER SET utf8mb4;

          SHOW CREATE TABLE t1;


          DESC t1;

          SELECT * FROM information_schema.TABLE_CONSTRAINTS WHERE table_name = 't1';

          #方式4
          #给已存在f1添加主键
          ALTER TABLE t1
          ADD PRIMARY KEY(f1)
          #ADD CONSTRAINT PRIMARY KEY(f1)

          #方式5
          #新增f2并且添加成主键
          ALTER TABLE t1
          ADD  COLUMN f2  VARCHAR(5),
          ADD PRIMARY KEY(f2)
          #ADD CONSTRAINT PRIMARY KEY(f2)

          #方式6
          #新增f2,f3并且添加成复合主键
          ALTER TABLE t1
          ADD  COLUMN f3  VARCHAR(5),
          ADD  COLUMN f4  VARCHAR(5),
          ADD  PRIMARY KEY(f3,f4)
          #ADD CONSTRAINT PRIMARY KEY(f3,f4)


          #删除主键约束
          ALTER TABLE t1
          DROP PRIMARY KEY

          #删除f3,f4主键约束，并且把默认的NOT NULL去掉(因为之前添加主键自动会添加位NOT NULL约束)
          ALTER TABLE t1
          DROP PRIMARY KEY,
          MODIFY COLUMN f3 varchar(5),
          MODIFY COLUMN f4 varchar(5)
        "
      自增列(AUTO_INCREMENT):
        - 一个表只能有一个
        - 必须是整形列+索引(主键索引[PRIMARY KEY]、唯一索引[UNIQUE KEY]、普通索引[KEY])
        - 自动增长列默认会设置为NOT NULL
        - 对自增列插入0或者null值时，则会获取计数器最大的值进行插入(而不是0或者null值进行插入)
        - "
          DROP TABLE IF EXISTS t1 ;
          CREATE TABLE if NOT EXISTS t1(

          	#方式1,自动增长列默认会设置为NOT NULL
          	#f1 INT PRIMARY KEY AUTO_INCREMENT

          	#方式2,自动增长列默认会设置为NOT NULL
          	#f1 INT UNIQUE KEY AUTO_INCREMENT

          	f1 INT,
          	f2 INT PRIMARY KEY

          ) DEFAULT CHARACTER SET utf8mb4;

          SHOW CREATE TABLE t1;


          DESC t1;

          SELECT * FROM information_schema.TABLE_CONSTRAINTS WHERE table_name = 't1';


          #给f1添加自动增长列
          ALTER TABLE t1
          MODIFY COLUMN f1 INT PRIMARY KEY AUTO_INCREMENT
          #MODIFY COLUMN f1 INT UNIQUE KEY AUTO_INCREMENT

          #给f2添加自动增长列
          ALTER TABLE t1
          MODIFY COLUMN f2 INT AUTO_INCREMENT


          #新增f3列，并且设置为自动增长列
          ALTER TABLE t1
          ADD COLUMN f3 INT UNIQUE KEY AUTO_INCREMENT

          #删除一个自动增长列
          ALTER TABLE t1
          MODIFY COLUMN f3 INT

        "
      外键约束(foreign key):
        概述:
          - 一个表可以有多个外键
          - 外键关联的主键必须是PRIMARY KEY或者是UNIQUE KEY
          - 外键关联的主键两者类型必须一致
          - "
            #主表
            DROP TABLE IF EXISTS masterT ;
            CREATE TABLE if NOT EXISTS masterT(

              d_id INT PRIMARY KEY
              #d_id INT UNIQUE KEY

            ) DEFAULT CHARACTER SET utf8mb4;
            SHOW CREATE TABLE masterT;

            #从表
            DROP TABLE IF EXISTS salaveT ;
            CREATE TABLE if NOT EXISTS salaveT(

              dept_id INT,
              #方式1，自动创建的普通索引名和外键名不一样，如果有唯一索引则不在创建普通索引
              #FOREIGN KEY(dept_id) REFERENCES masterT(d_id),

              #方式2，自动创建的普通索引名和外键名一样，如果有唯一索引则不在创建普通索引
              #CONSTRAINT fk_dept_id FOREIGN KEY (dept_id) REFERENCES masterT(d_id) ON UPDATE RESTRICT ON DELETE RESTRICT,
              # 默认 ON UPDATE RESTRICT ON DELETE RESTRICT
              # 推荐 ON UPDATE CASCADE ON DELETE RESTRICT


              f1 INT

            ) DEFAULT CHARACTER SET utf8mb4;
            SHOW CREATE TABLE salaveT;


            DESC t1;

            SELECT * FROM information_schema.TABLE_CONSTRAINTS WHERE table_name = 't1';


            #方式3，给f1添加外键
            ALTER TABLE salaveT
            ADD CONSTRAINT fk_f1 FOREIGN KEY (dept_id) REFERENCES masterT(d_id)

            #删除外键，并且删除索引(增加外键的时候会自动创建一个普通索引)
            ALTER TABLE salaveT
            DROP FOREIGN KEY fk_f1, #外键名
            DROP INDEX fk_f1 # 索引名（看情况删除，如果是自己创建的唯一索引，可以考虑不删除）
          "
        约束等级:
          - 默认 ON UPDATE RESTRICT ON DELETE RESTRICT
          - 推荐 ON UPDATE CASCADE ON DELETE RESTRICT
          - CASCADE，主表更新，则子表更新，主表删除，则子表删除
          - SET NULL，主表更新，则子表更新为null，主表删除，则子表更新为null，需要注意的是，字表这个列不能设置为NOT NULL约束
          - NO ACTION/RESTRICT，这2种方式一样，主表更新，如果子表存在则不允许，主表删除，如果子表存在则不允许
          - SET DEFFAULT，主表更新/删除，则子表设置成一个默认值，但在Innodb不能识别
        阿里公约总结:
          - 不得使用外键与级联，一切外键概念必须在应用层解决。
          - 外键与级联更新适用于单击低并发，不适合分布式、高并发集群。
          - 级联更新是强阻塞，存在数据库【更新风暴】的风险，外键影响数据库的插入速度。
      检查约束(check): "
        注意:mysql5.7是不支持，就算添加了，也会被过滤掉，具体可以用SHOW CREATE TABLE t1命令查看
        DROP TABLE IF EXISTS t1 ;
        CREATE TABLE if NOT EXISTS t1(


        	#f1 INT CONSTRAINT ck_name_1 CHECK (((f1 > 1000) and (f1 < 2000))),
        	#f1 CHAR(1) CONSTRAINT ck_name_2 CHECK (f2 in('男','女'))

        	f1 INT

        ) DEFAULT CHARACTER SET utf8mb4;

        SHOW CREATE TABLE t1;

        DESC t1

        SELECT * FROM information_schema.TABLE_CONSTRAINTS WHERE table_name = 't1'

        #给f1添加检查约束
        ALTER TABLE t1
        ADD CONSTRAINT ck_name CHECK (((f1 > 1000) and (f1 < 2000)))
        #MODIFY f1 INT CONSTRAINT ck_name CHECK (((f1 > 1000) and (f1 < 2000)))


        #删除f1检查约束
        ALTER TABLE t1
        DROP CONSTRAINT ck_name
      "
  DML(数据操作语言):
    概念:
      - 数据操作语言(Data Manipulation Language)
      - 用于添加，删除，更新，和查询数据记录，并检查数据的完整性
      - insert \ delete \ update \ select(DQL)
    查:
      select使用:
        基本使用:
          - select 1+1 as "总和1",2+2 "总和2"
          - select 1+1 from dual 伪表
          - 以下的所有查询，都忽略字符串的大小写
        去重（DISTINCT）:
          - select DISTINCT type from permission 去重
          - select DISTINCT type,parent_id from permission 等同于 select  type,parent_id from permission GROUP BY type,parent_id 没实际意义
        null:
          - null 不等于0，并且null参与运算结果为null，需要用到流程控制函数来配合使用
          - 计算员工月薪，以及员工年薪 select salary,salary*(1+IFNULL(commission_pct,0)) as "月薪",salary * (1+IFNULL(commission_pct,0)) * 12 as "年薪" from employees
        飘符号(``):
          - select * from `order`
        常量字段:
          - 如果某一些业务系统需要这个字段，但是表里面还未存在此字段，可以使用常数来顶替
          - SELECT '常量字段',s.* from employees s
        查询表结构:
          - DESCRIBE employees 或 DESC employees
        运算符:
          算术运算符:
            - + - * (/,div) (%,mod)
            - select employee_id+1 from employees where employee_id = 100+1
            - 查询员工id为基数的员工信息 SELECT * from employees where employee_id % 2 != 0
          比较运算符:
            概念:
              - 比较运算，返回结果为 0或1或null，而sql处理只要1的结果
            符号相关:
              其他:
                - =  (<>,!=) < <= > >=
                - 如果两边类型不同则进行隐式转换，字符串隐式转换失败则为0 select 1=1, 0='0a'
                - 如果任何一边比较有null参与，则结果为null，select null=1,null = null,null!=null
              <=>，安全等于号为null而生:
                - 安全等于号，功能跟=基本一样，只是<=>可以比较null，当两位为null则返回1，当一边为null则返回0
                - 查询等于null的数据 select null<=>null
                - 查询不等于null的数据 select NOT null <=> null，select * from employees where NOT commission_pct <=> NULL
            关键字和函数相关:
              比较null值关键字和函数:
                - IS NULL，ISNULL，IS NOT NULL
                - SELECT * from employees where commission_pct IS NULL
                - SELECT * from employees where ISNULL(commission_pct)
                - SELECT * from employees where commission_pct IS NOT NULL
              比较最大值和最小值函数:
                - LEAST，GREATEST
                - 数值+字符串，字符串会被隐式转换后在比较
                - 全为字符串，则按照字典排序进行比较
                - SELECT LEAST(1,2,'5'),GREATEST('a1b','a1aaaaa')
              范围查询:
                - SELECT * from employees where  salary BETWEEN 6000 AND 8000
                - SELECT employee_id NOT BETWEEN 100 AND 105 ,employee_id from employees where  salary NOT BETWEEN 6000 AND 8000
                - SELECT * from employees where  salary BETWEEN 6000 AND 8000 OR salary BETWEEN 1000 AND 3000
              选定值查询:
                - SELECT * from employees where  salary IN(6000,8000)
                - SELECT * from employees where  salary NOT IN(6000,8000)
              模糊查询:
                概念:
                  - %代表0个或多个不确定字符
                  - _代表1个不确定字符
                一般查询:
                  - SELECT * from employees WHERE first_name LIKE '%n%'  直要字符串中含有n即可
                  - SELECT * from employees WHERE first_name LIKE '%n' 字符串以n结尾
                  - SELECT * from employees WHERE first_name LIKE 'n%' 字符串以n开头
                  - SELECT * from employees WHERE first_name LIKE '%n%' AND  first_name LIKE 'n%' 包含n并且以n开头
                  - SELECT * from employees WHERE first_name LIKE '%n%' AND  first_name LIKE '%a%' 包含n并且包含a
                  - SELECT * from employees WHERE first_name LIKE '__a%' 查询第二个为a，后面可以任意
                  - SELECT * from employees WHERE first_name LIKE '___a%' 查询第三个为a，后面可以任意
                  - SELECT * from employees WHERE first_name LIKE '___a%__' 查询第三个为a，后面需要剩余2个字符
                转义查询:
                  默认转义字符/: SELECT * from employees WHERE last_name LIKE '_\_%'  第一个为占位，第二个位转义的_，意思就是，第一个和第二位必须满足，其他任意
                  ESCAPE自定义转义字符: SELECT * from employees WHERE last_name LIKE '_#_%' ESCAPE '#' 第一个为占位，第二个位转义的_，意思就是，第一个和第二位必须满足，其他任意
              正则表达式查询:
                - SELECT * from employees WHERE last_name REGEXP '^k'
                - SELECT * from employees WHERE last_name RLIKE '^k'
                - SELECT * from employees WHERE last_name NOT REGEXP '^k'
          逻辑运算:
            - "
              逻辑与&&(AND)
              逻辑或||(OR)
              逻辑非!(NOT)
              逻辑异或XOR，需要0和1组合才为1
              SELECT * from employees WHERE salary = 10000 XOR employee_id >100  只允许一个条件满足
            "
        排序:
          概念:
            - 如果没有使用排序操作，默认情况下，查询返回的数据是按照添加数据的顺序进行显示的
          多列排序:
            - 在多列进行排序时，首先排序第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中的所有值都是唯一的，将不再对第二列进行排序
            - SELECT employee_id,first_name,salary from employees  ORDER BY salary DESC , employee_id DESC
          使用列的别名进行排序:
            - SELECT employee_id as abc from employees ORDER BY abc DESC
            - SELECT employee_id as id,first_name,salary as s from employees  ORDER BY s DESC , id DESC
        分页:
          - LIMIT 第一个参数为偏移量，第二个参数为条数，也可以只填写1个参数，那么偏移量默认为0
          - SELECT * FROM employees LIMIT 10  查询前10条数据
          - SELECT * FROM employees LIMIT 21,2  查询第22和23的数据
          - "
            分页详解
              (pageNum-1) * pageSize, pageSize
              -- 查询第1页
              SELECT * FROM employees LIMIT 0,10
              -- 查询第2页
              SELECT * FROM employees LIMIT 10,10
              -- 查询第3页
              SELECT * FROM employees LIMIT 20,10
          "
        多表查询:
          为什么要有多表的操作:
            - 多表的拆分，可以降低字段的冗余，从而减少磁盘IO，还可以满足高并发对不同表的读写
          表与表的关联关系:
            - 一对一关联
            - 一对多关联
            - 多对对关联
            - 自我关联
          笛卡尔积:
            - 在N表查询中，至少需要N-1个连接条件成立才能消除笛卡尔积
            - "
              以下是笛卡尔积查询，并且利用连接条件消除了笛卡尔积

              SELECT
                  t1.first_name,
                  t2.department_name
              FROM
                  employees t1 CROSS JOIN
                  departments t2
              WHERE
                  t1.department_id = t2.department_id

              SELECT
                  t1.first_name,
                  t2.department_name
              FROM
                  employees t1,
                  departments t2
              WHERE
                  t1.department_id = t2.department_id
            "
          分类:
            内连接:
              - 只显示左边和右边满足条件的数据，其他不满足条件的则不显示
              - "
                如下是非等值连接（内连接）
                SELECT t1.last_name,t1.salary,t2.grade_level,t2.lowest_sal,t2.highest_sal from employees t1,job_grades t2
                where t1.salary >= t2.lowest_sal and t1.salary <= t2.highest_sal

                SELECT t1.last_name,t1.salary,t2.grade_level,t2.lowest_sal,t2.highest_sal from employees t1,job_grades t2
                where t1.salary BETWEEN t2.lowest_sal AND t2.highest_sal

                如下是自连接（内连接）
                select t1.first_name as self,t2.first_name as parent from employees t1,employees t2 where t1.employee_id = t2.manager_id
              "
              - SELECT * from a,b where a.id = b.id
              - SELECT * from a JOIN b ON a.id = b.id
              - SELECT * from a INNER JOIN b ON a.id = b.id
            外连接:
              左外连接:
                - 内连接满足条件的结果+左表不满足条件的结果
                - SELECT a.id,b.id from a LEFT JOIN b ON a.id = b.id
                - SELECT a.id,b.id from a LEFT OUTER JOIN b ON a.id = b.id
              右外连接:
                - 内连接满足条件的结果+右表不满足条件的结果
                - SELECT a.id,b.id from a RIGHT JOIN b ON a.id = b.id
                - SELECT a.id,b.id from a RIGHT OUTER JOIN b ON a.id = b.id
              满外连接:
                - mysql不支持 FULL OUTER JOIN
          7种常用的JOIN（重点）:
            案例1:
              - "
                A和B交集
                SELECT a.*,b.* FROM a JOIN b ON a.id = b.id
              "
            案例2:
              - "
                A和B交集+A左
                SELECT a.*,b.* FROM a LEFT JOIN b ON a.id = b.id
              "
            案例3:
              - "
                A和B交集+B右
                SELECT a.*,b.* FROM a RIGHT JOIN b ON a.id = b.id
              "
            案例4:
              - "
                A和B的差集
                SELECT a.*,b.* FROM a LEFT JOIN b ON a.id = b.id WHERE b.id IS NULL
              "
            案例5:
              - "
                B和A的差集
                SELECT a.*,b.* FROM a RIGHT JOIN b ON a.id = b.id WHERE a.id IS NULL
              "
            案例6:
              - "
                SELECT a.*,b.* FROM a LEFT JOIN b ON a.id = b.id
                    UNION   可以做，但性能不好，需要去重
                SELECT a.*,b.* FROM a RIGHT JOIN b ON a.id = b.id

                注意点1 UNION ALL 不需要去重，性能比 UNION要好
                注意点2 使用UNION ALL必须确保合并的表字段的列保持一致和列的类型保持一致

                A和B并集 = A和B交集+A左 + B和A的差集
                  SELECT a.*,b.* FROM a LEFT JOIN b ON a.id = b.id
                    UNION ALL
                  SELECT a.*,b.* FROM a RIGHT JOIN b ON a.id = b.id WHERE a.id IS NULL

                A和B并集 = A和B交集+B右 + A和B的差集
                  SELECT a.*,b.* FROM a RIGHT JOIN b ON a.id = b.id
                    UNION ALL
                  SELECT a.*,b.* FROM a LEFT JOIN b ON a.id = b.id WHERE b.id IS NULL
              "
            案例7:
              - "
                注意点1 UNION ALL 不需要去重，性能比 UNION要好
                注意点2 使用UNION ALL必须确保合并的表字段的列保持一致和列的类型保持一致

                A和B的差集 + B和A的差集
                  SELECT a.*,b.* FROM a LEFT JOIN b ON a.id = b.id WHERE b.id IS NULL
                    UNION ALL
                  SELECT a.*,b.* FROM a RIGHT JOIN b ON a.id = b.id WHERE a.id IS NULL
              "
      where的组合使用: "
        SELECT * FROM employees  e WHERE (e.employee_id,e.first_name) = (100,'Steven')
        SELECT * FROM employees  e WHERE e.employee_id = 100 AND e.first_name = 'Steven'
      "
      函数分类:
        单行函数:
          数值函数:
            ABS(x):
              - "
                返回永远是正数
                SELECT ABS(1),ABS(12.3),ABS(-4.44)
              "
            SIGN(x):
              - "
                正数返回1，负数返回-1，0返回0
                SELECT SIGN(1),SIGN(12.3),SIGN(-4.44),SIGN(-0)
              "
            PI():
              - "
                返回圆周率 3.141593
                SELECT PI()
              "
            CEIL(x)&FLOOR(x):
              - "
                返回向上取整的数，不会进行四舍五入
                SELECT CEIL(1),CEIL(1.1),CEIL(1.9),CEIL(-121.9554546)
                SELECT CEILING(1),CEILING(1.1),CEILING(1.9),CEILING(-121.9554546)

                返回向下取整的数，不会进行四舍五入
                SELECT FLOOR(1),FLOOR(1.1),FLOOR(1.9),FLOOR(-121.9554546)
              "
            LEAST(x1,x2,x3,...)&GREATEST(x1,x2,x3,...):
              - "
                取最小的数
                  SELECT LEAST('0aaaa',1,2,3)
                取最大的数
                  SELECT GREATEST('30aaaa',1,2,3)
              "
            MOD(x,y):
              - "
                求余
                SELECT MOD(10,3)
              "
            RAND()&RAND(X):
              - "
                返回0-1随机数 和 返回0-10随机数
                SELECT RAND(),RAND()*10
                如果因子一样，则返回一个固定的随机数
                SELECT RAND('a'),RAND('b'),RAND(0),RAND(10)
              "
            ROUND(x)&ROUND(x,y)&TRUNCATE(x,y):
              - "
                根据小数点第一位做四舍五入，并取整
                SELECT ROUND(10.43213),ROUND(10.53213)
                根据y设置的保留位数做四舍五入
                SELECT ROUND(15.43213,0),ROUND(15.53213,1),ROUND(15.53213,-1)
                根据y设置保留的位数，不做四舍五入
                SELECT TRUNCATE(15.43213,0),TRUNCATE(15.53213,1),TRUNCATE(15.53213,-1)
              "
            SQRT(x):
              - "
                返回开方值3，当x为负数时返回Null
                SELECT SQRT(9)
              "
            FORMAT(X,D):
              - "
              格式一个数值，D表示保留小数点后几位
              SELECT FORMAT('123.12',0)
            "
            CONV(N,from_base,to_base): "
              进制转换，表示将10禁止转换为2进制
              SELECT CONV(103,10,2)
            "
          字符串函数:
            ASCII(s):
              - "
                返回字符的ascii码十进制的值
                SELECT ASCII('a'),ASCII('A')
              "
            SUBSTR(str,start,end):
              - "
                字符串截取，从第几位开始，截取多少位
                SELECT SUBSTR('abc',1,2)
              "
            LENGTH(s)&CHAR_LENGTH(s):
              - "
                返回字符长度，常用这个做计算
                SELECT CHAR_LENGTH('abc'),CHAR_LENGTH('我们')
                返回字符集编码字节的长度
                SELECT LENGTH('abc'),LENGTH('我们')
              "
            CONCAT(s1,s2,...)&CONCAT(x,s1,s2,...):
              - "
                不带分隔符连接字符串
                SELECT CONCAT('a','b','c')
                带分隔符连接字符串
                SELECT CONCAT_WS('-','a','b','c')
              "
            REPLACE(str,a,b)&INSERT(str,idx,len,replcace):
              - "
                替换字符串
                SELECT REPLACE('hello tom','tom','eric')
                指定位置替换字符串，从1开始
                SELECT INSERT('hello tom lyq',7,3,'eric')
              "
            UPPER(s)&LOWER(s):
              - "
                将字符串转换为大写
                SELECT UPPER('Eric'),UCASE('Eric')
                将字符串转换为小写
                SELECT LOWER('Eric'),LCASE('Eric')
              "
            LEFT(str,n)&RIGHT(str,n):
              - "
                返回左边的第几个字符
                SELECT LEFT('Eric',1)
                返回右边的第几个字符
                SELECT RIGHT('Eric',1)
              "
            LPAD(str,len,pad)&RPAD(str,len,pad):
              - "
                指定字符串长度，如果字符串长度不够，则用指定符号补全
                SELECT LPAD('Eric',20,'*')
                SELECT RPAD('Eric',20,'*')
              "
            TRIM(s)&LTRIM(s)&RTRIM(s):
              - "
                去除左右空格
                SELECT TRIM('   Eric   ')
                指定需要去除字符串，左右去除
                SELECT TRIM('-' FROM '---Eric---')
                指定需要去除字符串，左去除
                SELECT TRIM(LEADING '-' FROM '---Eric---')
                指定需要去除字符串，右去除
                SELECT TRIM(TRAILING '-' FROM '---Eric---')

                去除左空格
                SELECT LTRIM('   Eric   ')
                去除右空格
                SELECT RTRIM('   Eric   ')
              "
            REPEAT(str,n):
              - "
                对字符串重复打印几次
                SELECT REPEAT('abc',2)
              "
            STRCMP(s1,s2):
              - "
                比较2个字符串的ascii值，依次进行顺序比较
                s1>s2 = 1
                s1<s2 = -1
                s1=s2 = 0
                SELECT STRCMP('c','bbb')
                SELECT STRCMP('abc','abd')
                SELECT STRCMP('abc','abc')
              "
            LOCATE(subStr,str):
              - "
                查询字符串b出现在哪个位置
                SELECT LOCATE('b','abc')
              "
            ELT(i,s1,s2,s3,...):
              - "
                需要返回第几个字符串
                SELECT ELT(1,'eric','tom','jerry')
              "
            FIELD(s,s1,s2,...)&FIND_IN_SET（s1,s2）:
              - "
                返回字符串出现的位置
                SELECT FIELD('eric','eric','tom','jerry')
                SELECT FIND_IN_SET('eric','eric,tom,jerry')
              "
            REVERSE(s):
              - "
                反转字符串
                SELECT REVERSE('eric')
              "
            NULLIF(s1,s2):
              - "
                str1 = str2  返回 NULL
                str1 != str2 返回 str1
                SELECT NULLIF('a','bb')
                SELECT NULLIF('bb','bb')
              "
            CONVERT:
              - "
                将字符串用于特定字符集进行编码
                CONVERT('123456' USING 'utf8')
              "
          日期和时间函数:
            日期和时间的获取:
              - "
                获取当前时间
                SELECT CURDATE(),CURRENT_DATE(),CURTIME(),CURRENT_TIME(),NOW(),UTC_DATE(),UTC_TIME()
                获取当前时间，并且转换为数值型
                SELECT CURDATE()+0,CURRENT_DATE()+0,CURTIME()+0,CURRENT_TIME()+0,NOW()+0,UTC_DATE()+0,UTC_TIME()+0

                获取当前时间
                SELECT CURRENT_TIMESTAMP() 不带毫秒
                SELECT CURRENT_TIMESTAMP(3) 带毫秒
                获取时间戳
                SELECT UNIX_TIMESTAMP()

                指定一个时间，获取 年月日时分秒
                SELECT YEAR(NOW()),MONTH(NOW()),DAY(NOW()),HOUR(NOW()),MINUTE(NOW()),SECOND(NOW())
                指定一个时间，获取英文的月份
                SELECT MONTHNAME(NOW())
                指定一个时间，获取英文的星期几
                SELECT DAYNAME(NOW())
                指定一个时间，获取周几，星期1是0，星期二是1，星期3是2
                SELECT WEEKDAY(NOW())
                指定一个时间，获取季度，1-4
                SELECT QUARTER(NOW())
                指定一个时间，获取一年中的第几周
                SELECT WEEK(NOW()),SELECT WEEKOFYEAR(NOW())
                指定一个时间，获取一年中的第几天
                SELECT DAYOFYEAR(NOW())
                指定一个时间，获取一个月中的第几天
                SELECT DAYOFMONTH(NOW())
                指定一个时间，获取一周中的第几天，星期日是1 星期一是2 星期二是3
                SELECT DAYOFWEEK(NOW())

                指定一个时间，返回当前时间,毫秒
                SELECT EXTRACT(MICROSECOND FROM CURRENT_TIMESTAMP(6))
                指定一个时间，返回当前时间,年月日时分秒
                SELECT EXTRACT(SECOND FROM NOW()),EXTRACT(MINUTE FROM NOW()),EXTRACT(HOUR FROM NOW()),EXTRACT(DAY FROM NOW()),EXTRACT(MONTH FROM NOW()),EXTRACT(YEAR FROM NOW())

                指定一个时间，返回当前时间在当前年的第几周
                SELECT EXTRACT(WEEK FROM NOW())
                指定一个时间，返回当前时间在当前年的第几月
                SELECT EXTRACT(MONTH FROM NOW())
                指定一个时间，返回当前时间在当前年的第几和季度 1-4
                SELECT EXTRACT(QUARTER FROM NOW())

                指定一个时间，返回秒和毫秒
                SELECT EXTRACT(SECOND_MICROSECOND FROM CURRENT_TIMESTAMP(6))
                指定一个时间，返回分钟和毫秒
                SELECT EXTRACT(MINUTE_MICROSECOND FROM CURRENT_TIMESTAMP(6))
                指定一个时间，返回年和月
                SELECT EXTRACT(YEAR_MONTH FROM CURRENT_TIMESTAMP(6))
              "
            日期和时间的转换:
              - "
                时间和时间戳的互转
                SELECT UNIX_TIMESTAMP('2022-11-25 09:34:20'),FROM_UNIXTIME(1669368860)
                时分秒和秒的互转
                SELECT TIME_TO_SEC(CURRENT_TIME()),SEC_TO_TIME(52375)
              "
            日期和时间的计算:
              - "
                在当前时间上添加年月日时分秒，对应的有DATE_SUB和SUBDATE
                SELECT ADDDATE('2022-1-1 1:1:1.1',INTERVAL 1000 MICROSECOND)
                SELECT DATE_ADD('2022-1-1 1:1:1.1',INTERVAL 1 YEAR)
                SELECT DATE_ADD('2022-1-1 1:1:1.1',INTERVAL 1 MONTH)
                SELECT DATE_ADD('2022-1-1 1:1:1.1',INTERVAL 1 DAY)
                SELECT DATE_ADD('2022-1-1 1:1:1.1',INTERVAL 1 HOUR)
                SELECT DATE_ADD('2022-1-1 1:1:1.1',INTERVAL 1 MINUTE)
                SELECT DATE_ADD('2022-1-1 1:1:1.1',INTERVAL 1 SECOND)

                SELECT DATE_ADD('2022-1-1 1:1:1.1',INTERVAL '1_1' YEAR_MONTH)
                SELECT DATE_ADD('2022-1-1 1:1:1.1',INTERVAL '1_1' DAY_HOUR)
                SELECT DATE_ADD('2022-1-1 1:1:1.1',INTERVAL '1_1' DAY_MINUTE)
                SELECT DATE_ADD('2022-1-1 1:1:1.1',INTERVAL '1_1' DAY_SECOND)
                SELECT DATE_ADD('2022-1-1 1:1:1.1',INTERVAL '1_1' HOUR_MINUTE)
                SELECT DATE_ADD('2022-1-1 1:1:1.1',INTERVAL '1_1' HOUR_SECOND)
                SELECT DATE_ADD('2022-1-1 1:1:1.1',INTERVAL '1_1' MINUTE_SECOND)

                添加和减少天数
                SELECT ADDDATE('2022-1-1',1)
                SELECT SUBDATE('2022-1-2',1)
                添加和减少时分秒
                SELECT ADDTIME(' 1:1:1',1)
                SELECT ADDTIME(' 1:1:1','1:1:1')
                SELECT SUBTIME(' 1:1:1',1)
                SELECT SUBTIME(' 1:1:1','1:1:1')

                date1-date2的时间间隔
                  SELECT TO_DAYS(NOW()) - TO_DAYS('2022-1-1 1:1:1.1')
                  SELECT DATEDIFF(NOW(),'2022-1-1 1:1:1')
                time1-time2的时间间隔
                  SELECT TIMEDIFF('2022-1-1 2:2:2','2022-1-1 1:1:1')
                返回日期date距离0000年1月1日的天数
                  SELECT TO_DAYS(NOW())
              "
            日期和时间的格式化:
              - "
                格式化
                SELECT NOW(),DATE_FORMAT(NOW(),'%Y年%m月%e日 %H时%i分%s秒')
                SELECT NOW(),TIME_FORMAT(NOW(),'%H时%i分%s秒')
                反格式化
                SELECT STR_TO_DATE('2022年11月25日 15时49分11秒','%Y年%m月%e日 %H时%i分%s秒')
                获取某个国家的格式化格式
                SELECT GET_FORMAT(DATETIME, 'USA'),GET_FORMAT(TIME, 'USA')
                SELECT GET_FORMAT(DATETIME, 'ISO'),GET_FORMAT(TIME, 'ISO')
              "
          流程控制函数:
            if函数:
              概述:
                - IF(expr1,expr2,expr3)，expr1为真，执行expr2，否则执行expr3
              使用:
                - "
                SELECT
                  CONCAT( e.first_name, e.last_name ) '名字',
                IF
                  ( e.salary > 10000, IF(e.salary > 15000,'很有钱','有钱') , '穷' ) '金额'
                FROM
                  employees e
              "
            ifnull函数:
              概述:
                - IFNULL(expr1,expr2)，如果为空expr1为null则执行expr2
              使用:
                - "
                  SELECT
                      CONCAT( e.first_name, e.last_name ) '名字',
                      IFNULL( e.commission_pct, '0.00' ) '佣金'
                  FROM
                      employees e
                "
            case函数:
              方式1: "
                类似于if elseif else语句
                SELECT
                    CONCAT( e.first_name, e.last_name ) '名字',
                CASE
                        WHEN e.salary > 15000 THEN'富人'
                        WHEN e.salary > 10000 THEN '有钱人'
                        ELSE '穷人'
                END
                FROM
                    employees e
              "
              方式2: "
                类似于if elseif 语句
                SELECT
                    CONCAT( e.first_name, e.last_name ) '名字',
                CASE
                        WHEN e.salary > 15000 THEN'富人'
                        WHEN e.salary > 10000 THEN '有钱人'
                END
                FROM
                    employees e
              "
              方式3: "
                类似于switch语句case语句
                SELECT
                    CONCAT( e.first_name, e.last_name ) '名字',
                CASE e.department_id / 10
                    WHEN 3 THEN '部门为30'
                    WHEN 5 THEN '部门为50'
                    WHEN 8 THEN '部门为80'
                    ELSE '没有部门'
                END
                FROM
                    employees e

              "
          加密与解密函数: "
              SELECT
                  # 不可逆加密
                  PASSWORD ( '123456' ),
                  # 不可逆加密
                  MD5( '123456' ),
                  # 不可逆加密
                  SHA( '123456' ),
                  # 加密
                  ENCODE( '123456','salt' ),
                  # 解密
                  DECODE( ENCODE( '123456','salt' ),'salt' )
              FROM DUAL
            "
          运维相关函数: "
            SELECT
              # 返回当前MYSQL版本号
              #VERSION()
              # 返回当前MYSQL服务器连接数
              #CONNECTION_ID()
              # 返回MYSQL命令行当前所在的数据库
              #DATABASE(), SCHEMA()
              # 返回当前连接MYSQL用户名，格式为主机名@用户名
              #USER(),CURRENT_USER(),SYSTEM_USER(),SESSION_USER()
              #用于查看当前数据库使用了什么字符串
              #CHARSET('查看字符串')
              #用于查看当前数据库使用了什么比较规则
              #COLLATION('查看比较规则')
              #测试函数执行N次
              BENCHMARK(10000000,MD5('123456'))
              #将ip转换为一个整数
              #INET_ATON('192.168.10.1'),
              #整数转换为一个ip
              #INET_NTOA(3232238081)
              #查看正在使用的是哪个数据库
              DATABASE()
          "
        多行函数:
          聚合函数:
            基本使用: "
              重点： 聚合函数对null是不作计算的
              SELECT
                使用于数值类型
                AVG(e.salary),
                SUM(e.salary),
                适用于数值类型、字符串类型、日期类型、字段类型
                MAX(e.salary),
                MIN(e.salary),
                支持如下写法, 不建议使用字段，从效率角度来考虑
                使用存储引擎为MyISAM，COUNT(*) = COUNT(1) = COUNT( e.salary )
                使用存储引擎为InnoDB，( COUNT(*) = COUNT(1) ) > COUNT( e.salary )
                COUNT( e.salary )
                COUNT( 1 ),
                COUNT( 2 ),
                COUNT( * )
              FROM
                employees e
            "
            GroupBy:
              结论:
                - 使用WITH ROLLUP关键字，不允许使用OrderBy进行排序了
                - 使用GroupBy，列字段只能写GroupBy中存在的字段(聚合函数除外)
              方式1: "
                 SELECT
                  department_id DID,
                  job_id JID,
                  AVG( salary ) ,
                  SUM( salary ) SUM_
                 FROM
                  employees
                 GROUP BY
                  DID, job_id
              "
              方式2: "
                  SELECT
                    department_id DID,
                    job_id JID,
                    AVG( salary ) ,
                    SUM( salary ) SUM_
                  FROM
                    employees
                  GROUP BY
                    DID, job_id
                  ORDER BY DID
              "
              方式3(WITH ROLLUP): "
                使用WITH ROLLUP关键字之后，在会在最后面做一次全量统计
                 SELECT
                  department_id DID,
                  job_id JID,
                  AVG( salary ) ,
                  SUM( salary ) SUM_
                 FROM
                  employees
                 GROUP BY
                  DID, job_id  WITH ROLLUP
              "

            Having:
              Having和Where对比:
                - 效率角度来说，where > having
                - 优势角度来说，having支持聚合函数，where不支持
              合理的使用方式: 不使用聚合函数的时候用where来做筛选，反之则使用having来筛选
              使用方式: "
                不太理想的写法
                SELECT
                  department_id DID,
                  job_id JID,
                  AVG( salary ) ,
                  SUM( salary ) SUM_
                FROM
                  employees
                GROUP BY
                  DID, job_id
                HAVING DID > 80 AND SUM_ > 20000 AND AVG( salary ) > 8000

                理想写法
                SELECT
                  department_id DID,
                  job_id JID,
                  AVG( salary ) ,
                  SUM( salary ) SUM_
                FROM
                  employees
                WHERE department_id > 80
                GROUP BY
                  DID, job_id
                HAVING SUM_ > 20000 AND AVG( salary ) > 8000
              "
      子查询:
        从内查询返回结果条目数角度:
          单行子查询: "
            单行子查询比较操作符
            =
            >
            >=
            <
            <=
            <>
          "
          多行子查询: "
            多行子查询比较操作符
              单独使用
                IN 等于列表中任意一个值
              结合单行子查询比较操作符使用
                比较任意一个值
                =  ANY/SOME
                >  ANY/SOME
                >= ANY/SOME
                <  ANY/SOME
                <= ANY/SOME
                <> ANY/SOME
                比较所有值
                =  ALL
                >  ALL
                >= ALL
                <  ALL
                <= ALL
                <> ALL
          "
        从内查询是否被执行多次角度:
          相关子查询: "
            内查询引用了主查询的字段，内查询会执行多次
            SELECT
              ee.last_name,
              ee.salary,
              ee.department_id
            FROM
              employees ee
            WHERE
              ee.salary > ( SELECT AVG( e.salary ) FROM employees e WHERE e.department_id = ee.department_id )
          "
          不相关子查询: 内查询不引用了主查询的字段，内查询只会执行一次
        EXISTS&NOT EXISTS: "
          EXISTS存在则返回true停止查找，不存在返回false继续查找

          SELECT
              e.employee_id,
              e.last_name,
              e.job_id
          FROM
              employees e
          WHERE
              EXISTS  ( SELECT 'X' FROM employees WHERE e.employee_id = manager_id )


          NOT EXISTS 只是多加了一个非的符号而已
          SELECT
              e.employee_id,
              e.last_name,
              e.job_id
          FROM
              employees e
          WHERE
              NOT EXISTS  ( SELECT 'X' FROM employees mr WHERE e.employee_id = mr.manager_id )
        "
    增: "
      不指明字段
        单条插入
          INSERT INTO t1 VALUES ('1','11')
          INSERT INTO t1 VALUES ((SELECT MAX(salary) from employees ),'11')
        多条插入
          INSERT INTO t1 VALUES ('1','11'),('2','22')
          INSERT INTO t1 SELECT id,salary from employees
      指明字段
        单条插入
          INSERT INTO t1(id,address) VALUES ('1','11')
          INSERT INTO t1(id,address) VALUES ((SELECT MAX(salary) from employees ),'11')
        多条插入
          INSERT INTO t1(id,address) VALUES ('1','11'),('2','22')
          INSERT INTO t1(id,address) SELECT id,salary from employees
    "
    改: "
      方式1
        UPDATE t1 ttt SET ttt.address = 11 WHERE ttt.id = 1
      方式2
        UPDATE t1 ttt SET ttt.address = CONCAT(ttt.id,ttt.address) WHERE ttt.id = 1
      方式3
        UPDATE t1  ttt
        SET ttt.address = ( SELECT e.last_name from employees e WHERE e.employee_id = ttt.id )
        WHERE EXISTS (
        	SELECT * from employees e WHERE e.employee_id  = ttt.id
        )
    "
    删: "
      方式1
        DELETE FROM t1 as ttt  WHERE 0
      方式2
        DELETE FROM t1 WHERE EXISTS (
          SELECT * from employees e WHERE e.employee_id  = t1.id
        )

    "
  DCL(数据控制语言):
    - 用于对数据库，表，字段，用户的访问权限和安全级别
    - commit \ rollback \ savepoint \ grant \ revoke
常见的数据库对象:
  表(TABLE): 表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录
  数据字典: 就是系统表，存放数据库相关信息的表，系统表的数据通常由数据库系统维护，程序员通常不应该修改，只可查看
  约束(CONSTRAINT): 执行数据校验的规则，用于保证数据完整性的规则
  视图(VIEW):
    概述:
     - 一个或多个数据表里的数据的逻辑显示，视图并不存储数据
     - 视图，可以看做是一个虚拟表，本身是不存储数据结构的，视图的本质，可以看做是存储起来的SELECT语句
     - 视图中SELECT语句中涉及到的表成为基表
     - 针对视图做DML操作，会影响到对应的基表中的数据。反之亦然
     - 视图本身的删除，不会导致基本表数据的删除
    语法: "
      CREATE [OR REPLCAE]
      [ALGORITHM] = {UNDEFINED | MERGE | TEMPTABLE}
      VIEW 视图名称 [(字段列名)]
      AS 查询语句
      [WITH [CASCADED | LOCAL ] CHECK OPTION]
    "
    命令: "
      查看数据库表对象、视图对象
      SHOW TABLES
      查看视图结构
      DESC view_name
      查看表、视图的属性信息
      SHOW TABLE STATUS LIKE 'view_name'
      查看视图的定义结构信息
      SHOW CREATE VIEW view_name
    "
    使用: "
      #创建或替换方式1
      CREATE OR REPLACE VIEW  v1(f1,f2)
      AS
      SELECT e.employee_id,e.salary FROM employees e;
      SHOW CREATE VIEW v1;


      #创建或替换方式2
      CREATE OR REPLACE VIEW
      AS
      SELECT e.employee_id f1,e.salary f2 FROM employees e;
      SHOW CREATE VIEW v1;

      #修改方式1
      ALTER VIEW v1(f1,f2)
      AS
      SELECT e.employee_id f1,e.salary f2 FROM employees e;
      SHOW CREATE VIEW v1;

      #修改方式2
      ALTER VIEW v1
      AS
      SELECT e.employee_id f1,e.salary f2 FROM employees e;
      SHOW CREATE VIEW v1;


      #删除
      DROP VIEW v1,v2,v3;
      DROP VIEW IF EXISTS v1,v2,v3;

    "
    不可【更新DML】的视图:
      概述: "
        要使视图可以更新，视图中的行和底层基表中的行之间必须存在一对一关系。
        如下情况视图不支持更新操作
          1.在定义视图的时候指定了ALGORITHM = TEMPTABLE，视图将不支持INSERT和DELETE操作
          2.视图中不包含基表中所有被定义位非空又未指定默认值的列，视图将不支持INSERT操作
          3.在定义视图的SELECT语句中使用了JOIN联合查询，视图将不支持INSERT和DELETE操作
          4.在定义视图的SELECT语句后的字段列表中使用数据表达式或子查询，视图将不支持INSERT，也不支持UPDATE
          5.在定义视图的SELECT语句后的字段列表中使用了DESTINCE、聚合函数、 GROUP BY、HAVING、UNION等，视图将不支持INSERT、UPDATE、DELETE
          6.视图定义基于一个不可以更新视图
          7.常量视图
      "
      结论: 虽然可以更新视图数据，但总的来说，视图作为`虚拟表`，主要用于`方便查询`，不建议过多更新视图的数据。
    优缺点:
      - 优点，简化查询，控制数据的访问
      - 缺点，基本更改有可能导致视图的修改，大量的视图创建维护成本大
  索引(INDEX): 用于提高查询性能，相当于书的目录
  存储过程(STORED PROCEDURE):
    概述:
      - 用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境
    语法: "
      CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)
      [characteristics ...]
      BEGIN
        存储过程体
      END
    "
    优缺点:
      优点:
        - 简化操作，提高了SQL语句的重用性，减少了开发程序员的压力
        - 减少操作过程中的事务，提高效率
        - 减少网络传输量（客户端不需要把所有的SQL语句通过网络发给服务器）
        - 减少SQL语句暴露在网上的风险，也提高了数据查询的安全性
      缺点:
        - 可移植性差，存储过程不能跨数据库移植，比如在MYSQL、ORACLE和SQL SERVER里编写的存储过程，在换成其他数据库时都需要重新编写。
        - 调试困难，只有少数DBMS支持存储过程的调试，对于复杂的存储过程来说，开发和维护都不容易。虽然也有一些第三方工具可以对存储过程进行调试，但是要收费。
        - 存储过程的版本管理很困难，比如数据库表索引发生了变化，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本没有版本控制，版本迭代更新的时候很麻烦。
        - 它不适合高并发场景，高并发的场景需要减少数据库的压力，有时候数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，增加数据库的压力，显然就不适用了。
      结论: 阿里开发规范强制禁止使用存储过程，存储过程难以调试和扩展，更没有移植性
  存储函数(STORED FUNCTION): 用于完成一次特定的计算，具有一个返回值，一部分由系统提供，用户也可以自定义
  触发器(TIGGER): 相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理



