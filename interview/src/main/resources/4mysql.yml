数据库相关:
  事务4大特性(ACID):
    原子性: 当前事务的操作要么同时成功，要么同时失败。由undo log日志来保证
    一致性: 由undo log日志来保证
    持久性: 一旦提交了事务，它堆数据的改变就应该是永久性的，由redo log日志来保证（文件小，可以顺序写磁盘提高性能，异步刷盘）
    隔离性: 在事务并发执行时，它们内部的操作不能相互干扰，由锁机制实现
  (InnoDB引擎中)4种隔离级别，存在的3种并发问题:
    读未提交: 脏读 不可以重复读 幻读 不加锁
    读已提交:     不可以重复读 幻读 不加锁
    可重复读:               幻读(innodb除外)   不加锁
    串行读:                                   加锁
  多个线并发对同一条记录场景:
    读读: 不存在任何线程安全问题
    写写: 加锁，需要排队
    读写:
      存在的问题: 脏读，不可重复读 ，幻读
      方案1加锁: 读加锁，写加锁
      方案2MVCC: 快照读(读)，当前读(写)
  MVCC:
    多版本并发控制:
      - MVCC做到即使有读写冲突时，也能做到不加锁，解决读写阻塞问题
      - 实现依赖于 隐藏字段，UndoLog(日志版本链)，ReadView(根据MVCC规则从UndoLog日志中创建ReadView，一个事务绑定一个ReadView)
    当前读:
      - select ... lock in share mode
      - select ... for update
      - update delete insert
    快照读:
      - 读已提交(RC) 每次快照读一次创建一个ReadView，可以获取到已提交的最新数据
      - 可重复读(RR) 只有在首次快照读创建一次ReadView，可以获取到已提交的历史版本版本或者最新数据
    MVCC解决的问题:
      - 1读写自检阻塞的问题，通过MVCC可以让读写相互不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力
      - 2降低了死锁的概率，这是因为MVCC采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行
      - 3解决快照读的问题，当我们查询数据在某个时间段的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交更新的结果
  索引:
    索引失效:
      - 复合查询，不遵守左前缀法则，索引失效
      - like 在前面加%，索引失效
      - != < > is null is not null or，索引失效
    查看索引是否失效:
      - explain关键字
  mysql,如何实现2个表数据的并集:
    - "
      A和B并集 = A和B交集+B右 + A和B的差集
      SELECT a.*,b.* FROM a RIGHT JOIN b ON a.id = b.id
        UNION ALL
      SELECT a.*,b.* FROM a LEFT JOIN b ON a.id = b.id WHERE b.id IS NULL
    "
  mysql主从是怎么样一个原理: