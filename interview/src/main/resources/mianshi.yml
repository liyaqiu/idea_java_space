html相关:
  是否独立完成布局过一个页面:
  CSS的3种样式表:
    - "外部样式表 <link rel='stylesheet' href='./abc/mystyle.css'>"
    - "内部样式表 <style></style>"
    - "行内样式表 <div style='color: green;'>我们都是好朋友 frends</div>"
  标签元素分类:
    - 块元素，默认占一行
    - 行内元素，不能设置高度，只能设置宽度
    - 行内块元素，宽高都有，并且不会占一行
  选择器分类:
    基础选择器(7种):
      id选择器:
      类选择器:
      标签选择器:
      通配符选择器:
      属性选择器(css3):
      伪类选择器:
      结构伪类选择器(css3):
      伪元素选择器:
    复合选择器(4种):
      后代选择器(空格)+子代选择器(>):
      交集选择器:
      并集选择器(逗号)(同时声明多个选择器):
      复合选择器总结:
  盒子模型:
    - 旧版本盒子模型，边框+内边距+内容区域
    - css3盒子模型，内容区域
  浮动:
  定位:
    静态定位:
      功能:
        - static
        - 静态定位是元素的默认定位方式，静态定位按照标准流特性摆放位置，它没有偏移属性
    相对定位:
    绝对定位:
    固定定位:
    黏性定位:
  清除浮动问题: 父元素没高度，子元素浮动，父元素会出现塌陷问题，所以需要清除浮动
  flex布局有没有用过:
    - 如何改变主轴方向 flex-direction:row;
js相关:
  JS六种数据类型:
    基本(值)数据类型:
      - String
      - Boolean
      - Number
      - Undefined
      - Null
    对象(引用)数据类型:
      - Object
  js中的作用域:
    全局作用域:
    函数作用域:
    块作用域: es6中有
  作用域链:
    - 当在函数作用域操作一个变量或者函数变量时，它会先在自身的作用域中寻找，如果有就直接使用，如果没有则往上一级函数作用域寻找，直到找到全局作用域位置，如果全局还没找到则报错。
  var变量和函数的提升有没有了解过:
  什么是原型:
    - 函数实例对象的隐式原型等于函数对象的显式原型
  原型链(隐式原型链):
    - 实例对象会先从对象本身去访问方法或者属性，如果访问不到会去原型上去访问，直到访问到Object类的原型为止
    - Vue中的Vue对象以及vueComponent原型关系
  事件冒泡:
    - 每个元素都会有默认事件函数，所以当对某个函数触发相应的事件时，都会有冒泡的产生。如果需要该元素不支持冒泡，可以使用event.cancelBubble = true; 停止冒泡
  localStroage和sessionStroage有没有用过:
    - sessionStroage浏览器窗口关闭就会清除
    - localStroage除非用户清除，或者api清楚，否则永久残留
  如何产生闭包:
    - 函数的嵌套，并且函数使用了外部函数作用域的变量
  你是如何理解js中的异步:
    功能:
      - js是单线程执行(回调代码也是在主线程执行)
    代码分类:
      - 初始化代码
      - 回调代码
  为什么会产生跨域: 违背了同源策略的请求，都属于跨域请求，必须保证(协议，域名，端口号)全部一致
  箭头函数:
    功能:
      - 箭头函数没有this，使用任何方式都不能改变this指向
      - 在箭头函数中使用this,这个this始终指向作用域链的this
      - 不能使用new实例化
      - 箭头函数没有arguments
  函数中this对象你是怎么理解的:
    - 解析器会为每个函数隐式传递一个this对象
    - 根据函数的调用方式不同this指向不同
    - "
           以方法方式调用，this指向的是当前对象  obj.fun()
           以new方式调用，this指向的是当前对象  new fun()
           以函数方式调用，this指向window对象  fun()
        "
  如何改变this指向:
    - 调用函数对象的call方法，this为传入的对象，testFun.call(obj,'arg1','arg2')
    - 调用函数对象的apply方法，this为传入的对象 testFun.apply(obj,['arg1','arg2'])
    - 还有一种利用bind方式，对函数进行拷贝，在执行const a2 = testFun.bind(myObj,'eric1','eric2')  a2()
  js中的事件委派有没有了解过:
    - "
        onload = function (){
            document.getElementById('box').onclick = function(even){
                console.dir(even.target)
                console.log(even.target.dataset)
                if(even.target.attributes.need){
                    console.log(even.target.innerHTML)
                }else{
                    console.log('不需要的元素')
                }
            }
        }
        <div class='box' id='box'>
            <ul>
                <li need data-hello='1'>1</li>
                <li need data-hello='2'>2</li>
                <li need data-hello='3'>3</li>
                <li need data-hello='4'>4</li>
                <li need data-hello='5'>5</li>
            </ul>
            <h1 class='h' need>6</h1>
            <h2 class='h' need>7</h2>
            <h3 class='h' need>8</h3>
            <h4 class='h' need>9</h4>
        </div>
      "
  宏队列于微队列:
    功能:
      - JS引擎首先必须先执行所有的初始化同步任务代码
      - 每次准备取出第一个宏任务执行前，都要将所有的微任务一个一个取出来执行。
    宏队列:
      - 用来保存待执行的红任务(回调函数以及一些结果值)，例如，DOM回调，定时器回调，ajax回调
    微队列:
      - 用来保存待执行的微任务(回调函数以及一些结果值)，例如，Promise回调，MutationObserver回调
  Axios拦截器有没有用过:
    - 请求拦截器
    - 响应拦截器
  Promise:
    3种状态:
      - PENDING = 'pending'
      - RESOLVED = 'resolved'
      - REJECTED = 'rejected'
    如何终止/挂起Promise链操作:
      - new一个Promise，然后不调用resolved，rejected即可挂起
  async和await讲一下:
    async函数:
      功能:
        - 只要 return，都是返回成功的Promise对象
        - 只要 throw， 都是返回失败的Promise对象
        - 手动return返回Promise对象，根据自己调用的成功或者失败作为返回
    await:
      功能:
        - await必须写在async函数中
        - await右侧的表达式一般为promise对象
        - await返回的是promise成功的值
        - await的promise失败了，就会报出异常，需要通过try..catch捕获处理
  模块化规范:
    ES5模块化: 闭包
    ES6模块化: import
    CommonJS模块化: require
    AMD模块化:
    CMD模块化:
  http协议基本组成部分:
  OSI模型:
Vue相关:
  Vue中的插槽有几种:
    - 默认插槽
    - 具名插槽
    - 作用域插槽
  Vue中的生命周期钩子函数你都用过哪些:
    功能:
      - 官方生命周期图 https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA
    beforeCreate:
      - 初始化，生命周期、事件，但数据代理还未开始
      - 此时，无法通过VM访问到data中的数据、methods中的方法。
    created:
      - 初始化，数据监测，数据代理
      - 此时，可以通过VM访问到data中的数据、methods中的方法。
    beforeMount:
      - 此阶段之前Vue开始解析模版，在内存中生成虚拟DOM，页面还不能显示解析号的内容
      - 页面呈现的是未经过Vue编译的DOM结构。
      - 所有对DOM的操作，最终都不生效，意思是就算你用原生操作了DOM，最后会被Vue解析后把之前内容覆盖
    mounted(常用):
      - 此阶段之前，Vue将内存中的虚拟DOM转为真实DOM插入页面。
      - 此时，页面中呈现的是经过Vue编译的DOM，对DOM的操作是有效的。
      - 至此初始化过程结束，一般在此进行开启定时器，发送网络请求，订阅消息，绑定自定义事件等初始化操作
    beforeUpdate:
      - 此时，数据是新的，但是页面是旧的，即，页面尚未和数据保持同步。
    updated:
      - 在此阶段之前，Vue根据新数据，生成的虚拟DOM与旧的虚拟DOM进行比较，最终完成页面更新，即完成了Model->View的更新
      - 此时，数据是新的，页面也是新的，即，页面和数据保持同步。
    beforeDestroy(常用):
      - 此时，VM中所有的，data、methods、指令等等，都处于可用状态，马上要执行销毁的过程。
      - 一般在此阶段，关闭定时器，取消订阅消息，解绑自定义事件等收尾操作。
      - "
        注意事项
          销毁后借助Vue开发者工具看不到任何信息。
          销毁后自定义事件会失效，但原生DOM事件依然有效。
          一般不会在beforeDestroy操作数据，因为即便操作数据，也不会在触发更新流程了。
      "
    destroyed:
    $nextTick:
      - 此钩子用于下次渲染执行，比如，一个元素隐藏了，突然需要显式并且获取焦点，那么获取焦点的操作就需要等下一次渲染在执行
    路由器专有的钩子:
      - acticated  当组件被路由回来的时候触发
      - deacticated 当组件被路由走的时候触发
  Vue中路由有几种方式:
    - 一般路由
    - 编程式导航路由
  Vue中的路由守卫都有用过那些:
    - 全局路由守卫(前置路由守卫，后置路由守卫)
    - 独享路由守卫
    - 组件路由守卫
  Vue-6种组件通讯方式:
    1父传子props（父子通吃）:
      - props
      - 父组件传递给子组件(普通数据即刻)
      - 子组件传递给父组件(利用函数作为回调传递)
    2子传父，自定义事件(@xxxName='fun'):
      - 自定义事件，父为子绑定事件 @xxxName='fun'  子组件通过 this.$emit('xxxName',arg1)调用
    3万能:
      - 在全局绑定$bus， 在想要拿到参数的组件中绑定回调 $on('xxxName')和$off('xxxName')，在传递参数的组件同触发回调 this.$emit('xxxName',arg1)调用
    4万能:
      - Vuex 统一状态管理
    5子传父:
      - 父通过ref拿到子组件的引用，利用$on('xxxName')为子组件绑定函数，子组件通过 this.$emit('xxxName',arg1)调用
    6:
      - 利用插槽进行传递
    7万能:
      - pubsub.js 发布与订阅
数据库相关:
  事务4大特性(ACID):
    原子性: 当前事务的操作要么同时成功，要么同时失败。由undo log日志来保证
    一致性: 由undo log日志来保证
    持久性: 一旦提交了事务，它堆数据的改变就应该是永久性的，由redo log日志来保证（文件小，可以顺序写磁盘提高性能，异步刷盘）
    隔离性: 在事务并发执行时，它们内部的操作不能相互干扰，由锁机制实现
  (InnoDB引擎中)4种隔离级别，存在的3种并发问题:
    读未提交: 脏读 不可以重复读 幻读 不加锁
    读已提交:     不可以重复读 幻读 不加锁
    可重复读:               幻读(innodb除外)   不加锁
    串行读:                                   加锁
  多个线并发对同一条记录场景:
    读读: 不存在任何线程安全问题
    写写: 加锁，需要排队
    读写:
      存在的问题: 脏读，不可重复读 ，幻读
      方案1加锁: 读加锁，写加锁
      方案2MVCC: 快照读(读)，当前读(写)
  MVCC:
    多版本并发控制:
      - MVCC做到即使有读写冲突时，也能做到不加锁，解决读写阻塞问题
      - 实现依赖于 隐藏字段，UndoLog(日志版本链)，ReadView(根据MVCC规则从UndoLog日志中创建ReadView，一个事务绑定一个ReadView)
    当前读:
      - select ... lock in share mode
      - select ... for update
      - update delete insert
    快照读:
      - 读已提交(RC) 每次快照读一次创建一个ReadView，可以获取到已提交的最新数据
      - 可重复读(RR) 只有在首次快照读创建一次ReadView，可以获取到已提交的历史版本版本或者最新数据
    MVCC解决的问题:
      - 1读写自检阻塞的问题，通过MVCC可以让读写相互不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力
      - 2降低了死锁的概率，这是因为MVCC采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行
      - 3解决快照读的问题，当我们查询数据在某个时间段的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交更新的结果
  索引:
    索引失效:
      - 复合查询，不遵守左前缀法则，索引失效
      - like 在前面加%，索引失效
      - != < > is null is not null or，索引失效
    查看索引是否失效:
      - explain关键字
Java相关:
  springboot包管理:
    - springboot POM中管理了很多包的依赖关系
  SpringBoot自动配置:
    - 1继承spring-boot-starter
    - 2配置@Conditional注解
    - 3在META-INF创建spring.factories文件，并且制定需要加载的配置类
  spring事务注解简单说下:
  jvm内存模型:
    方法区，堆区，本地方法栈，Java虚拟机栈，程序计数器
  你是如何理解内存溢出和内存泄漏的:
    内存溢出: 内存不足时候会触发GC，如果GC后还不能不够内存分配对象，就会触发OOM
    内存泄漏: 当一个对象一直有引用指向它，又没有使用，并且GC无法回收，就是内存泄漏，如果大量的对象存在内存泄漏问题，有可能会触发OOM
  java有几种引用对象:
    - 强(GC不回收)
    - 软(GC不够的时候回收)
    - 若(触发GC就回收)
    - 虚
    - 终结器引用
  多线程有几种状态(6种):
    - NEW,RUNNABLE,BLOCKED,WAITING,TIMED_WAITING,TERMINATED;
  CAS:
    原理:
      - 比较并交换，底层调用了unsafe类的API
    缺点:
      - ABA问题
      - 循环时长导致CPU开销大
  多线程有三大特性:
    原子性: cas来确保
    可见性和有序性: 可以通过volatile关键字来确保，volatile可以防止jvm指令重排
    synchronized: 可以确保 原子性，可见性，有序性
  高并发与多线程:
    JMM(Java Memory Model):
      概念:
        - JMM本身是一种抽象的概念，并不真实存在，它仅仅描述的是一组规范
        - JMM规范定义了程序中各个变量的读写访问方式并决定一个线程对共享变量的写入时，如何变成对另一个线程的可见
        - JMM关键技术点都是围绕多线程的原子性，可见性，有序性展开的
      JMM规范下的三大特性:
        - 原子性
        - 可见性
        - 有序性
      JMM能干嘛:
        - 通过JMM来实现线程和主内存之间的抽象关系
        - 屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各个平台下都能达到一致的内存访问效果
      JMM规范下的happens before原则:
        原理:
          - https://zhuanlan.zhihu.com/p/534251322
          - happens-before 原则是对 Java 内存模型的简化，让我们更好地写出并发代码。
          - 我们可以利用happens before原则推导出程序的执行顺序，是否有线程安全问题。
        8种原则:
          - 顺序原则，单个线程书写在前面的操作先行发生于写在后面的操作
          - 锁定原则（synchronized或者Lock），A线程的释放锁，一定先行发生于B线程的获取锁
          - volatile原则，被volatile修饰的变量，A线程的写操作，先行发生于B线程读操作
          - 传递性原则，A操作先行于B操作，B操作先行于C操作，A操作一定先行于C操作
          - 线程启动原则，Thread 对象的 start () 方法先行发生于此线程的每一个动作。
          - 线程中断原则，对线程 interrupt () 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread.interrupted () 方法检测到是否有中断发生。
          - 线程终止原则，线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread.join () 方法结束、Thread.isAlive () 的返回值等手段检测到线程已经终止执行。
          - 对象终结原则，一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize () 方法的开始。
      Volatile:
        可见性原理:
          - 被Volatile修饰过的变量，写操作的话，这个变量的最新值会立即刷新回到主内存中，读操作的话，总是能够读取到这个变量的最新值
          - 当某个线程收到通知，去读取被Volatile修饰过的变量的时候，线程私有工作内存数据失效，需要重新回到主内存中区读取最新的数据
          - 被Volatile修饰过的变量，每次的写操作都会立即从工作内存立即刷新到主存中，每次读操作都会从主存中获取最新的数据到工作内存
        有序性原理:
          写屏障:
            - 普通读 -> 普通写 ->  StroeStroe屏障 -> Volatile写 -> StroeLoad屏障
            - StroeStroe屏障，禁止Volatile写与前面的普通读写进行重排序
            - StroeLoad屏障，禁止Volatile写与后面Volatile读/写进行重排序
          读屏障:
            - Volatile读 -> LoadLoad屏障 -> LoadStore屏障 -> 普通读 -> 普通写
            - LoadLoad屏障，禁止Volatile读后面的所有普通读操作进行重新排序
            - LoadStore屏障，禁止Volatile读后面的所有普通写操作进行重新排序
          总结:
            - 写屏障，前后都加屏障指令，分别为StroeStroe和StroeLoad
            - 读屏障，后面加屏障指令，分别为LoadLoad和LoadStore
      总结:
        - JMM定义了Java多线程访问物理内存的规范
        - 在JMM规范下，多线程对共享变量的读写过程，每个线程都有自己的工作内存，线程与线程之间不允许直接访问，必须通过主存来共享访问（1个线程从主存拷贝一个变量副本到工作内存，修改后在写回主存，另一个线程也是同样的操作）
    Java锁:
      悲观锁与乐观锁:
        悲观锁:
          - 适合写操作多的场景
          - synchronized是悲观锁的实现方式
          - Lock的实现类都是悲观锁的实现方式
        乐观锁:
          - 适合读操作多的场景
          - CAS是乐观锁的实现方式
          - 版本控制的实现方式
      公平锁与非公平锁:
        - "

          公平锁 new ReentrantLock(true): 新增加的线程，需要排队来获取锁，性能差，涉及到频繁的线程上下文切换
          非公平锁 new ReentrantLock(false): 新增加的线程，可以直接与队列中等待的线程进行竞争锁资源
        "
      可重入锁(递归锁):
        - 当持有同样的锁的时候，无须重新获得锁就可以直接访问
        - Synchronized支持锁重入，释放由JVM来处理
        - ReentrantLock支持锁重入，进入几次就得释放几次
      自旋锁:
        - 通过CAS来实现自旋锁 https://www.bilibili.com/video/BV1ar4y1x727?p=76&vd_source=cc17fab1d456bc3958dcb51e2fdd520b
      无锁->偏向锁->轻量级锁->重量级锁:
        - synchornized
      无锁->独占锁->读写锁->邮戳锁:
    AQS(AbstractQueuedSynchronizer):
      前置知识:
        原理:
          - AQS是一个抽象队列同步器,AQS主要维护了一个双向队列（双向链表），用于线程并发的时候存储等待的线程
          - AQS是用来实现锁或者其他同步器组件的公共基础部分的抽象实现
          - AQS是重量级基础框架及整个JUC体系的基石，主要用于解决锁分配给"谁"的问题
          - AQS整体是一个抽象的FIFO队列来完成资源获取线程的排队工作，并通过一个int类变量表示持有锁的状态
        LockSupport:
          park: 线程等待
          unpark: 唤醒线程
        AQS内部:
          AQS内部的state:
          AQS内部的Node类(双向队列，双向链表):
            - Node SHARED(S锁)
            - Node EXCLUSIVE(X锁)
            - "
              int waitStatus
              0 当一个Node被初始化的时候默认值的
              1 表示线程获取锁的请求已经被取消
              -1 表示线程已经准备好了，就等资源释放了
              -2 表示节点在等待队列中，节点线程等待唤醒
              -3 表示当前线程处在SHARED(S锁)情况下，该字段才会使用
            "
          AQS内部4个重要的方法:
            - tryAcquire() 获取排它锁
            - tryRelease() 释放排它锁
            - tryAcquireShared() 获取共享锁
            - tryReleaseShared() 释放共享锁
        和QAS有关的常用类:
          - ReentrantLock（利用AQS排它锁来，实现了公平锁和非公平锁）
          - ReentrantReadWriteLock（利用AQS排它锁和共享锁来，实现了公平锁和非公平锁，并且支持读锁[共享锁]和写锁[排它锁]）
          - CountDownLatch
          - Semaphore
        ReentrantLock内部:
          获取独占锁 public final void acquire(int arg):
            - 需要实现，tryAcquire(arg)获取锁，如果返回true代表抢锁成功，否则抢锁失败，继续执行acquireQueued方面
            - acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) addWaiter加入队列，acquireQueued，加入队列并且挂起(LockSupport.park)
            - AQS的acquire方法中，通过tryAcquire获取锁，获取不到则加入AQS队列并且park线程
          释放独占锁 public final boolean release(int arg):
            - 需要实现，tryRelease，释放资源
            - AQS的release方法中通过tryRelease释放锁，并且通过unparkSuccessor唤醒队列中等待的线程
          Sync extends AbstractQueuedSynchronizer:
          FairSync extends Sync(公平锁):
          NonfairSync extends Sync(非公平锁):
          公平锁:
            - 新来的线程需要排队进行锁的获取
          非公平锁:
            - 不管队列里面是否有线程等待，新来的线程一样可以争抢锁
        CountDownLatch内部:
          获取共享锁 tryAcquireShared():
          释放共享锁 tryReleaseShared():
    ThreadLocal:
      原理以及内存泄漏问题:
        - 当你把对象存进ThreadLocal，首先会找到当前线程的map，然后把ThreadLocal对象作为key存储，并且key是一个弱引用，解决内存泄漏的问题，value是通过remove来解决内存泄漏
      使用场景:
        - 如果多个方法需要使用到同一个对象，那么使用ThreadLocal比较合适，Spring @Transaction底层就是把Connection对象封装在了ThreadLocal里面