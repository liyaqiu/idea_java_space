事务: 事务是一组操作，要么全部成功，要么全部失败，目的是为了保证数据最终一致性
数据库执行引擎:
  - InnoDB(支持事务)
  - MyISAM(不支持事务)
事务4大特性(ACID):
  原子性: 当前事务的操作要么同时成功，要么同时失败。由undo log日志来保证
  一致性: 由undo log日志来保证
  持久性: 一旦提交了事务，它堆数据的改变就应该是永久性的，由redo log日志来保证（文件小，可以顺序写磁盘提高性能，异步刷盘）
  隔离性: 在事务并发执行时，它们内部的操作不能相互干扰，由锁机制实现
解释各种读:
  脏读: 能读取对方未提交的数据
  不可重复读: 一个事务查询同一条记录2次，得到的结果不一致（已提交事务）（数据修改）
  幻读: 一个事务查询2次，得到的记录条数不一致（已提交事务）（数据新增，数据删除）
(InnoDB引擎中)4种隔离级别，存在的3种并发问题:
  读未提交: 脏读 不可以重复读 幻读 不加锁
  读已提交:     不可以重复读 幻读 不加锁
  可重复读:               幻读(innodb除外)   不加锁
  串行读:                                   加锁
多个线并发对同一条记录场景:
  读读: 不存在任何线程安全问题
  写写: 加锁，需要排队
  读写:
    存在的问题: 脏读，不可重复读 ，幻读
    方案1加锁: 读加锁，写加锁
    方案2MVCC: 快照读(读)，当前读(写)
锁:
  按照数据操作类型划分:
    读锁（共享锁 S锁）:
      - select ... lock in share mode
      - 读锁是共享锁，多个事务可以同时读取同一个资源，但不允许其他事务修改
    写锁（排它锁 X锁）:
      - select ... for update
      - update delete insert都会加写锁
      - 写锁是排它锁，会阻塞其他的写锁和读锁
  按照粒度划分:
    表级锁:
      表级别的S锁，X锁:
      意向锁:
      自增锁: 主键自动增长锁
      MDL锁:
    行级锁:
      记录锁: 针对单条记录加锁(可以加S)
      间隙锁: 针对某一个间隙不存在的记录加锁(S锁X锁都一样)
    页级锁:
  对待锁的态度划分:
    悲观锁:
    乐观锁:
  加锁方式:
    隐式加锁:
    显示加锁:
  其他:
    全局锁:
    死锁:
MVCC:
  多版本并发控制:
    - MVCC做到即使有读写冲突时，也能做到不加锁，解决读写阻塞问题
    - 实现依赖于 隐藏字段，UndoLog(日志版本链)，ReadView(根据MVCC规则从UndoLog日志中创建ReadView，一个事务绑定一个ReadView)
  当前读:
    - select ... lock in share mode
    - select ... for update
    - update delete insert
  快照读:
    - 读已提交(RC) 每次快照读一次创建一个ReadView，可以获取到已提交的最新数据
    - 可重复读(RR) 只有在首次快照读创建一次ReadView，可以获取到已提交的历史版本版本或者最新数据
  MVCC解决的问题:
    - 1读写自检阻塞的问题，通过MVCC可以让读写相互不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力
    - 2降低了死锁的概率，这是因为MVCC采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行
    - 3解决快照读的问题，当我们查询数据在某个时间段的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交更新的结果

索引:
  索引失效:
    - 复合查询，不遵守左前缀法则，索引失效
    - like 在前面加%，索引失效
    - != < > is null is not null or，索引失效
  查看索引是否失效:
    - explain关键字
