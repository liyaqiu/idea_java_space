Java相关:
  springboot包管理:
    - springboot POM中管理了很多包的依赖关系
  SpringBoot自动配置:
    - 1继承spring-boot-starter
    - 2配置@Conditional注解
    - 3在META-INF创建spring.factories文件，并且制定需要加载的配置类
  spring事务注解简单说下:
  spring代理有几种模式: cglib jdk,简单说下这2种代理
  jvm内存模型:
    方法区，堆区，本地方法栈，Java虚拟机栈，程序计数器
  你是如何理解内存溢出和内存泄漏的:
    内存溢出: 内存不足时候会触发GC，如果GC后还不能不够内存分配对象，就会触发OOM
    内存泄漏: 当一个对象一直有引用指向它，又没有使用，并且GC无法回收，就是内存泄漏，如果大量的对象存在内存泄漏问题，有可能会触发OOM
  java有几种引用对象:
    - 强(GC不回收)
    - 软(GC不够的时候回收)
    - 若(触发GC就回收)
    - 虚
    - 终结器引用
  多线程有几种状态(6种):
    - NEW,RUNNABLE,BLOCKED,WAITING,TIMED_WAITING,TERMINATED;
  CAS:
    原理:
      - 比较并交换，底层调用了unsafe类的API
    缺点:
      - ABA问题
      - 循环时长导致CPU开销大
  多线程有三大特性:
    原子性: cas来确保
    可见性和有序性: 可以通过volatile关键字来确保，volatile可以防止jvm指令重排
    synchronized: 可以确保 原子性，可见性，有序性
  高并发与多线程:
    JMM(Java Memory Model):
      概念:
        - JMM本身是一种抽象的概念，并不真实存在，它仅仅描述的是一组规范
        - JMM规范定义了程序中各个变量的读写访问方式并决定一个线程对共享变量的写入时，如何变成对另一个线程的可见
        - JMM关键技术点都是围绕多线程的原子性，可见性，有序性展开的
      JMM规范下的三大特性:
        - 原子性
        - 可见性
        - 有序性
      JMM能干嘛:
        - 通过JMM来实现线程和主内存之间的抽象关系
        - 屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各个平台下都能达到一致的内存访问效果
      JMM规范下的happens before原则:
        原理:
          - https://zhuanlan.zhihu.com/p/534251322
          - happens-before 原则是对 Java 内存模型的简化，让我们更好地写出并发代码。
          - 我们可以利用happens before原则推导出程序的执行顺序，是否有线程安全问题。
        8种原则:
          - 顺序原则，单个线程书写在前面的操作先行发生于写在后面的操作
          - 锁定原则（synchronized或者Lock），A线程的释放锁，一定先行发生于B线程的获取锁
          - volatile原则，被volatile修饰的变量，A线程的写操作，先行发生于B线程读操作
          - 传递性原则，A操作先行于B操作，B操作先行于C操作，A操作一定先行于C操作
          - 线程启动原则，Thread 对象的 start () 方法先行发生于此线程的每一个动作。
          - 线程中断原则，对线程 interrupt () 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread.interrupted () 方法检测到是否有中断发生。
          - 线程终止原则，线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread.join () 方法结束、Thread.isAlive () 的返回值等手段检测到线程已经终止执行。
          - 对象终结原则，一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize () 方法的开始。
      Volatile:
        可见性原理:
          - 被Volatile修饰过的变量，写操作的话，这个变量的最新值会立即刷新回到主内存中，读操作的话，总是能够读取到这个变量的最新值
          - 当某个线程收到通知，去读取被Volatile修饰过的变量的时候，线程私有工作内存数据失效，需要重新回到主内存中区读取最新的数据
          - 被Volatile修饰过的变量，每次的写操作都会立即从工作内存立即刷新到主存中，每次读操作都会从主存中获取最新的数据到工作内存
        有序性原理:
          写屏障:
            - 普通读 -> 普通写 ->  StroeStroe屏障 -> Volatile写 -> StroeLoad屏障
            - StroeStroe屏障，禁止Volatile写与前面的普通读写进行重排序
            - StroeLoad屏障，禁止Volatile写与后面Volatile读/写进行重排序
          读屏障:
            - Volatile读 -> LoadLoad屏障 -> LoadStore屏障 -> 普通读 -> 普通写
            - LoadLoad屏障，禁止Volatile读后面的所有普通读操作进行重新排序
            - LoadStore屏障，禁止Volatile读后面的所有普通写操作进行重新排序
          总结:
            - 写屏障，前后都加屏障指令，分别为StroeStroe和StroeLoad
            - 读屏障，后面加屏障指令，分别为LoadLoad和LoadStore
      总结:
        - JMM定义了Java多线程访问物理内存的规范
        - 在JMM规范下，多线程对共享变量的读写过程，每个线程都有自己的工作内存，线程与线程之间不允许直接访问，必须通过主存来共享访问（1个线程从主存拷贝一个变量副本到工作内存，修改后在写回主存，另一个线程也是同样的操作）
    Java锁:
      悲观锁与乐观锁:
        悲观锁:
          - 适合写操作多的场景
          - synchronized是悲观锁的实现方式
          - Lock的实现类都是悲观锁的实现方式
        乐观锁:
          - 适合读操作多的场景
          - CAS是乐观锁的实现方式
          - 版本控制的实现方式
      公平锁与非公平锁:
        - "

          公平锁 new ReentrantLock(true): 新增加的线程，需要排队来获取锁，性能差，涉及到频繁的线程上下文切换
          非公平锁 new ReentrantLock(false): 新增加的线程，可以直接与队列中等待的线程进行竞争锁资源
        "
      可重入锁(递归锁):
        - 当持有同样的锁的时候，无须重新获得锁就可以直接访问
        - Synchronized支持锁重入，释放由JVM来处理
        - ReentrantLock支持锁重入，进入几次就得释放几次
      自旋锁:
        - 通过CAS来实现自旋锁 https://www.bilibili.com/video/BV1ar4y1x727?p=76&vd_source=cc17fab1d456bc3958dcb51e2fdd520b
      无锁->偏向锁->轻量级锁->重量级锁:
        - synchornized
      无锁->独占锁->读写锁->邮戳锁:
    AQS(AbstractQueuedSynchronizer):
      前置知识:
        原理:
          - AQS是一个抽象队列同步器,AQS主要维护了一个双向队列（双向链表），用于线程并发的时候存储等待的线程
          - AQS是用来实现锁或者其他同步器组件的公共基础部分的抽象实现
          - AQS是重量级基础框架及整个JUC体系的基石，主要用于解决锁分配给"谁"的问题
          - AQS整体是一个抽象的FIFO队列来完成资源获取线程的排队工作，并通过一个int类变量表示持有锁的状态
        LockSupport:
          park: 线程等待
          unpark: 唤醒线程
        AQS内部:
          AQS内部的state:
          AQS内部的Node类(双向队列，双向链表):
            - Node SHARED(S锁)
            - Node EXCLUSIVE(X锁)
            - "
              int waitStatus
              0 当一个Node被初始化的时候默认值的
              1 表示线程获取锁的请求已经被取消
              -1 表示线程已经准备好了，就等资源释放了
              -2 表示节点在等待队列中，节点线程等待唤醒
              -3 表示当前线程处在SHARED(S锁)情况下，该字段才会使用
            "
          AQS内部4个重要的方法:
            - tryAcquire() 获取排它锁
            - tryRelease() 释放排它锁
            - tryAcquireShared() 获取共享锁
            - tryReleaseShared() 释放共享锁
        和QAS有关的常用类:
          - ReentrantLock（利用AQS排它锁来，实现了公平锁和非公平锁）
          - ReentrantReadWriteLock（利用AQS排它锁和共享锁来，实现了公平锁和非公平锁，并且支持读锁[共享锁]和写锁[排它锁]）
          - CountDownLatch
          - Semaphore
        ReentrantLock内部:
          获取独占锁 public final void acquire(int arg):
            - 需要实现，tryAcquire(arg)获取锁，如果返回true代表抢锁成功，否则抢锁失败，继续执行acquireQueued方面
            - acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) addWaiter加入队列，acquireQueued，加入队列并且挂起(LockSupport.park)
            - AQS的acquire方法中，通过tryAcquire获取锁，获取不到则加入AQS队列并且park线程
          释放独占锁 public final boolean release(int arg):
            - 需要实现，tryRelease，释放资源
            - AQS的release方法中通过tryRelease释放锁，并且通过unparkSuccessor唤醒队列中等待的线程
          Sync extends AbstractQueuedSynchronizer:
          FairSync extends Sync(公平锁):
          NonfairSync extends Sync(非公平锁):
          公平锁:
            - 新来的线程需要排队进行锁的获取
          非公平锁:
            - 不管队列里面是否有线程等待，新来的线程一样可以争抢锁
        CountDownLatch内部:
          获取共享锁 tryAcquireShared():
          释放共享锁 tryReleaseShared():
    ThreadLocal:
      原理以及内存泄漏问题:
        - 当你把对象存进ThreadLocal，首先会找到当前线程的map，然后把ThreadLocal对象作为key存储，并且key是一个弱引用，解决内存泄漏的问题，value是通过remove来解决内存泄漏
      使用场景:
        - 如果多个方法需要使用到同一个对象，那么使用ThreadLocal比较合适，Spring @Transaction底层就是把Connection对象封装在了ThreadLocal里面