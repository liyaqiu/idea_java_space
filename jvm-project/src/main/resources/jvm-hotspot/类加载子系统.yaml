类加载子系统:
  功能:
    - 在Java中，数据类型分为基本数据类型和引用数据类型。基本数据类型由虚拟机预选定义，引用数据类型则需要进行类的加载。
  类的生命周期: 加载->链接(校验、准备、解析)->初始化->使用->卸载
  1加载阶段:
    个人总结: 将字节码文件二进制流数据加载到方法区，并且在堆空间生成类模版对象实例。
    加载原理:
      - 所谓加载，就是将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型【类模版】
      - 所谓类模版对象，其实就是Java类在JVM内存中的一个快照，JVM将从字节码文件中解析出的常量池、类字段、类方法、类属性等信息，存储到类模版中
      - 这样JVM在运行期间便能通过类模版而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用。
      - 反射的机制就是基于这一基础，如果JVM没有将Java类的声明信息存储起来，则JVM在运行期间也无法反射。
    加载完成的操作:
      - 加载阶段，查找并加载类的二进制数据，生成Class的实例
      - "
        在加载类时，Java虚拟机必须完成以下3件事情:
          通过类的全名，获取类的二进制数据流。
          解析类的二进制数据流为方法区内的数据结构(类模版)
          创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口
      "
    二进制流的获取方式:
      - 对于类的二进制数据流，虚拟机可以用过多重途径产生和获得，只要所读取的字节码二进制流数据符合JVM规范即可。
      - "
        最常见，虚拟机可能通过文件系统读入一个class后缀的文件
        读取jar，zip等归档数据包，提取类文件
        事先存放在数据库中的类的二进制数据
        使用类似HTTP之类的协议通过网络进行加载
        在运行时生成一段Class的二进制流数据等。
      "
      - 在获取到类的二进制流数据后，Java虚拟机就会处理这些数据，并最终转为一个java.lang.Class的实例。
      - 如果输入的二进制流数据不符合类文件结构，则会抛出ClassFormatError异常。
    类模版的位置:
      - 加载的类在JVM中创建相应的类结构，类结构会存储在方法区(JDK1.7及以前永久代，JDK1.8及以后元空间)
    类模版实例的位置:
      - class文件加载到方法区后，会在堆中创建一个类模版本实例，用来封装类位于方法区内的数据结构，该类模版实例是在加载类的过程中创建的，每个类模版都对应一个类模版实例。
      - 类模版实例是访问类模版的元数据的接口，也是实线反射的关键数据。入口。
      - 通过类模版实例接口，可以获得类模版所关联的方法、字段等信息。
    数组类的加载:
      - 创建数组类的情况稍微有些特殊，因为数组类本身并不是由类加载负责创建的，而是由JVM在运行时根据需要在创建的。但是数组的类型仍然需要依靠类加载器去创建。
      - "
        创建数组的过程
          int[] a = new int[2];
          String[] str = new String[2];
          如果数组的类型是引用类型，那么就跟将引用类型按照类加载子系统的过程进行加载。
          如果数组的类型是基本类型，则不需要加载。
      "
  2链接阶段:
    校验环节:
      功能:
        - 验证环节主要就是保证加载的字节码合法、合理并符合JVM规范。
        - 格式校验会和加载阶段一起执行，验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。
        - 语义校验、字节码校验、符号引用校验将会在方法区中进行校验。
      格式校验:
        - 是否以0xCAFEBABE开头，主版本和次版本是否在当前Java虚拟机的支持范围内，数据中每个项是否拥有正确的长度。
      语义校验:
        - 是否所有的类都有父类(除Object)
        - 被定义为final的方法或者类，是否有被别的类进行重写或者继承等错误操作。
        - 某个类实现了接口或者继承了抽象类，是否有实现了抽象方法。
        - 类里面的方法重写是否遵从Java规范。
      字节码校验:
        - 在字节的执行过程中，是否会挑战到一条不存在的指令。
        - 函数的调用是否传递了正确类型的参数。
        - 变量的复制是不是给了正确的数据类型等。
        - 栈映射帧(StackMapTable)就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确是数据类型。
      符号引用校验:
        - Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。所以JVM会检查这些符号引用对应的方法和类是否存在。
        - 此校验需要到解析环节才会执行
    准备环节:
      功能:
        - 准备环节不会为实例变量分配内存，类变量类常量会分配在方法区中，而实例变量和实例常量会随着对象一起分配到Java堆中。
        - 如果该类变量或类常量没有在clinit方法中进行赋值，那么就是在链接阶段的准备环节进行了赋值了。
        - "
          为类变量分配内存，并且赋默认值
            原始代码 static String str = 'hello';                     准备环节 static String str = null;
            原始代码 static int i = 100;                              准备环节 static int i = 0;
            原始代码 static String str = new String('hello');         准备环节 static String str = null;
        "
        - "
          为类常量(基本数据类型，String类型,通过字面量方式赋值)分配内存，并且赋值
            原始代码 final static int i = 100;        准备环节 final static int i = 100
            原始代码 final static String str = '123'; 准备环节 final static String str = '123'
        "
    解析环节:
      功能:
        - 将类，接口，字段和方法的符号引用转换为直接引用。
        - 符号引用就是一些字面量引用，和虚拟机的内部数据结构和内存布局无关。
        - 比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用，但是在程序实际运行时，只有符号引用是不够的，当xxx()方法被调用时，需要明确知道改方法的内存地址。
        - 以方法调用为例，JVM为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法时，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。通过解析操作，符号引用就可以转化为目标方法在类中方法表中的位置，从而使得方法被成功调用。
        - 所谓的解析环节就是将符号引用转化为直接引用，也就是得到类、字段、方法在内存中的指针或者偏移量。因此，如果直接引用存在，那么久肯定系统中存在该类、方法或者字段。如果只存在符号引用，就不能确定JVM中一定存在该结构。
      执行顺序:
        - 在Java虚拟机规范并没有明确要求解析环节一定要按照顺序执行。在hotspot中，解析环节往往会在JVM执行完初始化之后在执行。
  3初始化阶段:
    功能:
      - 为类变量和类常量赋值
      - 初始化阶段的重要工作就是执行类的clinit()方法。
      - clinit()方法是由类变量，类常量的赋值语句以及静态代码块合并产生的。
      - 在加载一个类的时候，JVM总数会试图加载该类的父类，因为父类的clinit方法总是在子类的clinit方法之前执行。
      - "
          执行clinit方法，为类变量或者类常量，并且赋值
            原始代码 static String str = 'hello';                     初始化阶段 static String str = 'hello';
            原始代码 static int i = 100;                              初始化阶段 static int i = 100;
            原始代码 static String str = new String('hello');         初始化阶段 static String str = new String('hello');
            原始代码 final static Integer i = new Integer(100);       初始化阶段 final static Integer i = new Integer(100);
            原始代码 final static Integer i = 100;                    初始化阶段 final static Integer i = 100;
            原始代码 final static String str = new String('hello');   初始化阶段 final static String str = new String('hello');
      "
    clinit方法线程安全:
      - 对于clinit方法的调用，也就是类的初始化，JVM会在内部确保其多线程环境中的安全性。
      - JVM会保证一个类的clinit方法在多线程环境中被正确的加锁，同步，如果多个线程同时去初始化一个类，那么只会有一个线程区执行这个类的clinit方法，其他线程都需要阻塞等待。
      - 正是因为clinit是一个同步方法，因此，如果一个类的clinit方法中有耗时很长的操作，就可能造成多个线程阻塞，或者引发死锁问题。
      - clinit方法从字节码角度看，是看不到同步标识的，JVM在运行期间隐式去上锁的。
      - clinit方法只允许执行一次。如果之前的线程成功加载了类，则等在队列中的线程就没机会在此执行clinit方法了。那么，当需要使用这个类的时候， JVM就会直接返回给它已经准备好的信息。
    类的主动与被动使用:
      功能:
        - 类的主动使用会调用clinit()方法，类的被动使用不会调用clinit()方法。
      主动场景:
        - new关键字方式、反序列化方式、反射方式、克隆方式
        - 调用类的静态的方法
        - 调用类的(普通类，抽象类，接口类)类变量或者类常量(除开基本数据类型，String类型,通过字面量方式赋值)
        - 当初始化子类时，如果父类还没进行初始化，则需要先触发父类的初始化。
              如果初始化子类，该子类实现的接口并不会初始化。
                如果该接口定义了default方法，那么会初始化。
              如果初始化接口，它的父接口也不会初始化。
        - 当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法)，虚拟机会先初始化这个类
        - 当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。(涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类)
      被动场景:
