JVM介绍:
  Java及JVM简介:
    JVM虚拟机分类:
       - oracle收购Sun公司发行的HotSpot虚拟机
       - oracle收购了BEA发行的JRockit虚拟机
       - IBM发行J9虚拟机
    JDK分类:
      - Open JDK
      - Oracle JDK
  JVM虚拟机:
    - 遵循【Java规范的字节码】都可以运行在Java虚拟机上
    - 一次编译，到处运行
    - 自动内存管理
    - 自动垃圾回收功能
  Java代码执行流程: 源代码 -> Javac编译器 -> Class文件 -> 类加载器 -> 执行引擎
  JVM的架构模型:
    栈指令集架构:
      - 性能差，实现简单，移植行强
      - 典型案例:hotspot
      - 与CPU耦合底
      - 指令集小，指令多
    寄存器指令集架构:
      - 性能好，实现难，移植行差
      - 典型案例:window系统,安卓的Davlik虚拟机
      - 与CPU偶尔高
      - 指令集大，指令少
  JVM的生命周期:
    JVM启动: Java虚拟机的启动是通过【引导类加载器】创建一个初始类完成的，这个类是由虚拟机的具体实现指定的
    JVM运行: 执行一个所谓的Java程序的时候，才真真正正的执行Java虚拟机进程
    JVM退出:
      - 执行程序过程中异常导致jvm退出
      - 由操作系统出现错误导致jvm退出
      - System.exit(0);
      - Runtime.getRuntime().exit(0);
      - Runtime.getRuntime().halt(0);
  JVM后台系统线程:
    功能: 在JVM启动时候会默认创建
    线程类型:
      虚拟机线程:
        功能:
          - 这种线程的操作是需要JVM达到安全点才会出现，这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化
          - 这种线程的类型包括"stop-the-world"的垃圾收集，线程占收集，线程挂载以及偏向锁撤销
      周期任务线程: 这种线程是时间周期事件的体现(比如中断)，他们一般用于周期性操作的调度执行
      GC线程: 这种线程对在JVM里不同的种类的垃圾收集行为提供了支持
      编译线程: 这种线程在运行时会将字节码编译成本地代码
      信号调度线程: 这种线程接收信号并发给JVM，在它内部通过调用适当的方法进行处理
JVM的整体结构:
  上层:
    class字节码文件:
      功能: 由javac前端编译器编译成class字节码文件
      组成:
        - 类信息
        - 常量池（Constant pool）
    类加载子系统:
      功能:
        - 类加载器子系统负载从文件系统或者网络中加载Class文件，Class文件在文件开头有特定的文件标识，
        - ClassLoader只负责class文件的加载，至于它是否可以运行，则由执行引擎（Execution Engine）决定
        - 加载的类信息存放在方法区的内存空间，除了类的信息外，方法区中还会存放运行时常量池信息（指的是class文件中的Constant pool），
        - 可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）
      个人功能总结: 类加载子系统将class文件加载到方法区中
      双亲委派机制:
        功能:
          - Java虚拟机对class文件采用的是【按需加载】的方式，也就是说当要使用该类的时候才会将它的class文件加载到内存生成class对象。
          - 而且加载某个类的class文件时，Java虚拟机采用的是双亲委派机制，即把请求交给父类处理，它是一种任务委派模式。
        工作原理:
          - 如果一个类加载器收到了类加载请求，它并不会自己去先加载，而是把这个请求委托给父类的加载器去执行。
          - 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层引导类加载器。
          - 如果父类加载器可以完成类加载任务，就成功返回，如果父类加载器无法完成加载任务，则子类加载器才会尝试自己去加载。
        好处:
          - 可以避免冗余加载
          - 防止核心api篡改（当把java.lang开头的包提交到引导类的时候，引导类不会对其进行加载）
      类的主动使用与被动使用:
        功能: 类使用需要经历 加载->链接->初始化阶段，也就是一个类被jvm加载了，不代表初始化，当初始化的时候需要调用类clinit()
        主动使用:
          - 1.创建类实例
          - 2.访问某个类或者接口的静态变量，或者对该静态变量赋值
          - 3.调用类的静态方法
          - 4.反射调用(比如：Class.forName("com.ClassLoader.custom.PersonEntity"))
          - 5.初始化一个类的子类
          - 6.Java的虚拟机启动时被标明为启动类的类
          - 7.java.lang.invoke.MethodHandle实例的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则初始化
        被动使用: 除了以上情况都属于被动使用
      一共有3个阶段:
        加载阶段:
          功能:
            - 类加载器负责将class转换成DNA元数据模版
            - 通过一个类的全限定名获取定义此类的二进制字节流
            - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
            - 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口
          类加载器分类:
            引导类加载器:
              引导类加载器(Bootstrap Class Loader)（C/C++语言实现）:
                功能:
                  - 它使用C/C++语言实现的，嵌套在JVM内部,它用来加载Java核心类库，用于提供JVM自身需要的类
                  - 负责加载【扩展类加载器】和【系统类加载器】，并且成为他们的父类加载器
                  - 出于安装考虑，Bootstrap引导类加载器只加载了包名为java，javax，sun等开头的类
                加载位置:
                    - D:/jdk1.8.0_121/jre/lib/
                    - D:/jdk1.8.0_121/jre/lib/resources.jar
                      D:/jdk1.8.0_121/jre/lib/rt.jar
                      D:/jdk1.8.0_121/jre/lib/sunrsasign.jar
                      D:/jdk1.8.0_121/jre/lib/jsse.jar
                      D:/jdk1.8.0_121/jre/lib/jce.jar
                      D:/jdk1.8.0_121/jre/lib/charsets.jar
                      D:/jdk1.8.0_121/jre/lib/jfr.jar
                通过系统属性查看: System.getProperty("sun.boot.class.path")
                是否继承java.lang.ClassLoader: 不继承
                父类加载器: 没有
            自定义类加载器(sun.misc.Launcher作为入口类):
              扩展类加载器(Extension Class Loader)（Java语言实现）:
                功能:
                  - Java语言编写，sun.misc.Launcher$ExtClassLoader@4f023edb
                  - 它是程序中默认的类加载器，一般情况下用户写的类都是由它来加载
                加载位置:
                  - D:\jdk1.8.0_121\jre\lib\ext\;
                  - D:\jdk1.8.0_121\jre\lib\ext\access-bridge-64.jar
                    D:\jdk1.8.0_121\jre\lib\ext\cldrdata.jar
                    D:\jdk1.8.0_121\jre\lib\ext\dnsns.jar
                    D:\jdk1.8.0_121\jre\lib\ext\jaccess.jar
                    D:\jdk1.8.0_121\jre\lib\ext\jfxrt.jar
                    D:\jdk1.8.0_121\jre\lib\ext\localedata.jar
                    D:\jdk1.8.0_121\jre\lib\ext\meta-index
                    D:\jdk1.8.0_121\jre\lib\ext\nashorn.jar
                    D:\jdk1.8.0_121\jre\lib\ext\sunec.jar
                    D:\jdk1.8.0_121\jre\lib\ext\sunjce_provider.jar
                    D:\jdk1.8.0_121\jre\lib\ext\sunmscapi.jar
                    D:\jdk1.8.0_121\jre\lib\ext\sunpkcs11.jar
                    D:\jdk1.8.0_121\jre\lib\ext\zipfs.jar
                  - C:\Windows\Sun\Java\lib\ext\
                  - 如果用户创建了xxx.jar放在jre/lib/ext目录下，也会被扩展类加载器加载
                通过系统属性查看: System.getProperty("java.ext.dirs")
                是否继承java.lang.ClassLoader: 继承
                父类加载器: 引导类加载器
              系统类加载器(Application Class Loader)（Java语言实现）:
                功能: Java语言编写，sun.misc.Launcher$AppClassLoader@18b4aac2
                加载位置:
                  - 由-classpath指定
                  - java -classpath xx1.jar;xx2.jar com.test.Test
                通过系统属性查看: System.getProperty("java.class.path")
                是否继承java.lang.ClassLoader: 继承
                父类加载器: 扩展类加载器
              自定义类加载器(Custom Class Loader)（Java语言实现）:
                功能:
                  - 实现同一个class文件不同加载器加载
                  - 实现动态加载类
                  - 可以对class做加密处理
                加载位置:
                  - 可以通过网络
                  - 可以通过磁盤
                是否继承java.lang.ClassLoader: 继承
                父类加载器: 系統类加载器
        链接阶段:
          校验:
            功能: 确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载的正确性，不会危害虚拟机的自身安全
            主要包括四种验证:
              - 文件格式校验
              - 元数据校验
              - 字节码校验
              - 符号引用校验
          准备:
            功能:
              - 为类变量分配内存，并且设置该类变量的默认初始值
                java代码定义：【这里的具体赋值需要到初始化阶段调用clinit()】
                  static String a1 = “hello”
                  static int a2 = 10
                  static bl a3 = true
                准备
                  static String a1 = null
                  static int a2 = 0
                  static bl a3 = false
              - 这里不包含用final修饰类变量,因为final修饰类变量在编译的时候就会分配，准备阶段会显示初始化
                  java代码定义：
                  final static String a1 = 'hello'
                  final static int a2 = 10
                  final static bl a3 = true
                准备
                  final static String a1 = 'hello'
                  final static int a2 = 10
                  final static bl a3 = true
              - 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会跟随对象一起分配到堆内存中
          解析:
            功能:
              - 将常量池（指的是class文件中的Constant pool）内的符号引用转换位直接引用的过程
              - 事实上，解析操作往往会伴随着JVM在执行完初始化之后在执行
              - 符号引用就是一组符号来描述所引用的目标，符号引用的字面量形式明确定义在Java虚拟机规范的Class文件中。
              - 直接引用就是直接指向了目标的至臻，相对偏移量或一个间接定位到目标的句柄
              - 解析动作主要针对类或接口,字段,类方法,接口方法,方法类型等.对应的常量池中CONSTANT_Class_info CONSTANT_Fieldref_info CONSTANT_Methodred_info等
        初始化阶段:
          功能:
            - <clinit>()主要是对类变量和静态代码块的整合，然后进行初始化
            - 初始化阶段就是执行类构造器方法<clinit>()的过程
                <clinit>()作用对类变量赋值
                static String a1 = “hello”
                static int a2 = 10
                static bl a3 = true
                static {
                  int num = 10;
                  int num1 = a2;
                }
            - 此方法不需要定义，是javac编译器自动收集类中的【所有类变量的赋值动作】和【静态代码块中的语句】合并而来
            - 类构造器方法<clinit>()中的指令集执行顺序是根据源代码中出现的顺序执行
                0 iconst_1
                1 putstatic #2 <com/test/Test.a>
                4 iconst_3
                5 istore_0
                6 return
            - <clinit>()不同于类的构造器(关联:构造器是虚拟机视角下的<init>())
            - 若该类具有父类,JVM会保证父类的<clinit>()先执行，然后在执行子类的<clinit>()
            - 虚拟机必须保证一个类的<clinit>()方法在多线程下同步加锁
  中层:
    运行时数据区:
      功能:
        - 内存是长飞重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。
        - JVM内存布局规定了Java在运行过程中内存申请，分配，管理的策略，保证了JVM的高效运行
        - 不同的JVM对于内存的划分方式和管理机制存在着部分差异(hotspot有方法区，J9和Jrockit没有方法区)
      1.方法区(线程共享):
          功能:
            - 永久代-堆内存: jdk1.7之前
            - 元空间-直接内存: jdk1.8之后
          元空间:
            常量池:
            方法元信息:
            klass类元信息:
          CodeCache:
            功能: JIT编译产物
      2.堆区(线程共享):
          功能:
            - 栈管运行，堆管存储
          新生代(Young区):
            幸存者区(S0/S1):
            伊甸园区(Eden):
          老年代(Old区):
      3.本地方法栈(线程独享):
          功能:
            - 调用native方法
            - 调用本地方法接口
            - 本地方法库
      4.Java虚拟机栈(线程独享):
        功能:
          - 栈管运行，堆管存储
          - 每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个栈帧，每个栈帧对应一个方法的调用
          - Java虚拟机栈的声明周期和线程共存亡
          - Java虚拟机栈它保存方法的局部变量(8种基本数据类型，对象的引用地址)，以及线程运行中产生的部分结果，并且参与方法的调用和返回
          - Java虚拟机栈的操作只有2个
            出栈
            进栈
          - 调用非native方法
          - 1个栈帧包含(本地变量表,操作数栈,动态链接,方法返回地址,一些附加信息)
          - 1个栈帧对应源代码1个方法,1个方法的执行对应一个栈帧入栈，一个方法的结束对应一个栈帧的出栈
          - 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器
          - 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧(栈顶栈帧)是有效的，这个栈帧被称为当前栈帧，与当前真真相对应的方法就是当前当面，定这个方法的类就是当前类
          - 执行引擎运行的所有字节码指令只针对当前栈帧进行操作
          - 如果在该方法中调用了其他方法，对应的新的栈帧会创建出来，放在栈顶，成为新的当前栈帧
          - 不同线程中所包含的栈是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧
          - 如果当前党法调用了其他方法，方法返回之前，当前栈帧会传回此方法的执行结果给前一个栈帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧
          - Java方法有两种返回方法(栈帧)的方式，一种是正常方法返回(return),另一种事抛出异常返回(throw RuntimeException)，都会导致栈帧被弹出
        栈的存储单位: 栈帧(Stack Frame)
        栈帧:
          局部变量表/本地变量表:
            功能:
              - 局部变量表也被陈伟局部变量数组或本地变量表
              - 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据包括各类基本数据类型，对象引用，以及returnAddress类型
              - 由于局部变量表是在栈帧中，而栈帧又是在Java虚拟机栈中，所以局部变量表是线程的私有数据，因此不存在数据安全问题
              - 局部变量表中的变量只在当前栈帧(方法)中生效,在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。
              - 当栈帧(方法)调用结束后，随着栈帧的销毁，局部变量表也随之销毁
              - 参数值的存放总是在局部变量数组的Index0开始，到数组长度—1索引结束
              - 局部变量表的基本存储单位是Slot（变量槽）
              - 局部变量表中存放编译期可知的各种基本数据类型(8种)，引用类型(reference)，returnAddress类型变量
              - 类变量(静态变量)和局部变量对比
                我们知道【类变量表】有两次初始化机会，第一次是在连接阶段->准备环节中赋默认值，第二次是在初始化阶段赋值(代码中写的值)
                和类变量初始化不同的是，局部变量表不存在系统初始化过程，这意味着一旦定义了局部变量则必须认为初始化，否则无法使用
                public void test5(){
                int a;
                System.out.println(a);//不能直接使用
                }
              - 在栈帧与栈帧之间的调用时，虚拟机利用局部变量表来进行参数传递，也就是方法调用之前是否需要传参，方法结束的时候是否需要返回参数
              - 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或者间接引用的对象都不会被回收
            从字节码层面:
              局部变量表的大小:
                - 局部变量表所需要的容量大小是在编译期间(javac)就确定下来的，在方法运行期间不会改变局部变量表的大小
                  方法 -> test -> Code -> 杂项 -> 局部变量最大槽数
              局部变量表的位置:
                - 方法 -> test -> Code -> LocalVariableTable
              局部变量表的单位: 槽slot
              槽slot:
                - 一个槽=4个字节=32位
                - byte short float char boolean(0表示false,1表示true) 被转换为int
                - int 引用类型 占1个槽
                - long double 占2个槽
                - JVM会为局部变量表中的每一个Slot都分配一个访问索引,通过这个索引即可成功访问到局部变量表中指定的局部变量值
                - 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上
                - 如果需要访问局部变量表中一个，只需要使用索引号(槽的索引)即可访问
                - 如果当前栈帧是由构造方法或者实例方法创建的，那么该对象的引用this将会存放在Index为0的slot位置，其他的参数按照参数顺序继续排位
                  public Test(){
                  //this
                  }
                  public void test(){
                  //this
                  }
                - 槽的重复利用
                  public void test5(){
                  int a = 10;
                  {
                  // int b = 10;
                  double c = 20;
                  }
                  int d = 20;
                  }
          操作数栈/表达式栈:
            功能:
              - 操作数栈底层是基于数组实现的，栈是先进后出
              - 操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据，或者提取数据
              - 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数栈的值取出，使用他们后再把结果压入栈。
              - 操作数栈主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间
              - 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个栈帧的操作数栈是一个空的数组
              - 我们说Java虚拟机的解析引擎是基于栈的执行引擎，其中指的就是操作数栈
            从字节码层面:
              操作数栈的大小:
                - 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期(javac)就定义好了
                  方法 -> test -> Code -> 杂项 -> 操作数栈最大深度
              操作数栈的单位: 深度
              深度:
                1个深度 = 4个字节=32位
          动态链接:
            功能:
              - 指向运行时常量池的方法引用
          方法返回地址:
            功能:
              - 方法正常退出
              - 方法异常退出
          一些附加信息:
        是否支持GC: 不支持
        是否会出现OOM:
          - 固定大小(jvm默认)/StackOverFlowError
            如果采用固定大的Java虚拟机栈，那么每个线程的Java虚拟机栈容量可以在线程创建的时候独立选定，
            如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容易，则抛异常
          - 动态扩展/OutOfMenoryError
            如果采用动态扩展Java虚拟机栈，那么线程在尝试扩展的时候无法申请到足够的内存，或者在創建新的綫程
            时没有足够的内存去创建对应的虚拟机栈，则抛异常
        设置栈大小:
          - 默认Linux/macOS = 1024kb
          - 默认Windows = 没有明确说明
          - -Xss1m
          - -Xss1024k
          - -Xss1048576
        方法的调用:
          解析:
          分派:
      5.程序计数器(线程独享):
          功能:
            - 也叫PC寄存器(Program Counter Register)
            - 程序计数器用来存储指向下一条指令的地址，由执行殷勤读取下一条指令。
            - 它是一块很小的内存空间，几乎可以忽略不计，也是运行速度最快的存储区域
            - 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致
            - 程序计数器会存储当前线程正在执行的指令地址
                0 aload_0
                1 invokespecial #1 <java/lang/Object.<init> : ()V>
                4 return
                (0 1 4)就是指令地址
            - 如果是在执行native方法，则是未指定的值(undefined)
            - 它是程序空间流的指示器，如分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成
            - 执行引擎工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
            - 它是唯一一个在Java虚拟机规范中没有出现任何的OOM情况的区域
          是否支持GC: 不支持
          是否会出现OOM: 不出现
  下层:
    执行引擎:
      功能:
        - 将字节码指令转换成机器指令,最后将机器指令给CPU运行
      解析器:
        功能: 利用程序计数器逐行解析字节码，将字节码解析成机器指令并且执行
      JIT即时编译器(JIT后端编译器):
        功能: 通过程序计数器寻找热点代码,将字节码编译成机器指令并且执行（缓存机器指令，放在方法区的CodeCache）
      垃圾回收器:
    本地方法接口:
      功能: 被本地方法栈调用
    本地方法库:
      功能: 被本地方法栈调用
