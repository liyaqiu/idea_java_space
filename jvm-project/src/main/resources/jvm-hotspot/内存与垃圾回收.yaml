JVM介绍:
  Java及JVM简介:
    JVM虚拟机分类:
       - oracle收购Sun公司发行的HotSpot虚拟机
       - oracle收购了BEA发行的JRockit虚拟机
       - IBM发行J9虚拟机
    JDK分类:
      - Open JDK
      - Oracle JDK
  JVM虚拟机:
    - 遵循【Java规范的字节码】都可以运行在Java虚拟机上
    - 一次编译，到处运行
    - 自动内存管理
    - 自动垃圾回收功能
  Java代码执行流程: 源代码 -> Javac编译器 -> Class文件 -> 类加载器 -> 执行引擎
  JVM的架构模型:
    栈指令集架构:
      - 性能差，实现简单，移植行强
      - 典型案例:hotspot
      - 与CPU耦合底
      - 指令集小，指令多
    寄存器指令集架构:
      - 性能好，实现难，移植行差
      - 典型案例:window系统,安卓的Davlik虚拟机
      - 与CPU偶尔高
      - 指令集大，指令少
  JVM的生命周期:
    JVM启动: Java虚拟机的启动是通过【引导类加载器】创建一个初始类完成的，这个类是由虚拟机的具体实现指定的
    JVM运行: 执行一个所谓的Java程序的时候，才真真正正的执行Java虚拟机进程
    JVM退出:
      - 执行程序过程中异常导致jvm退出
      - 由操作系统出现错误导致jvm退出
      - System.exit(0);
      - Runtime.getRuntime().exit(0);
      - Runtime.getRuntime().halt(0);
  JVM后台系统线程:
    功能: 在JVM启动时候会默认创建
    线程类型:
      虚拟机线程:
        功能:
          - 这种线程的操作是需要JVM达到安全点才会出现，这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化
          - 这种线程的类型包括"stop-the-world"的垃圾收集，线程占收集，线程挂载以及偏向锁撤销
      周期任务线程: 这种线程是时间周期事件的体现(比如中断)，他们一般用于周期性操作的调度执行
      GC线程: 这种线程对在JVM里不同的种类的垃圾收集行为提供了支持
      编译线程: 这种线程在运行时会将字节码编译成本地代码
      信号调度线程: 这种线程接收信号并发给JVM，在它内部通过调用适当的方法进行处理
JVM的整体结构/JVM内存模型:
  上层:
    class字节码文件:
      功能: 由javac前端编译器编译成class字节码文件
      组成:
        - 类信息
        - 常量池（Constant pool）
    类加载子系统:
      功能:
        - 类加载器子系统负载从文件系统或者网络中加载Class文件，Class文件在文件开头有特定的文件标识，
        - ClassLoader只负责class文件的加载，至于它是否可以运行，则由执行引擎（Execution Engine）决定
        - 加载的类信息存放在方法区的内存空间，除了类的信息外，方法区中还会存放运行时常量池信息（指的是class文件中的Constant pool），
        - 可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）
        - 虚方法表的创建
            虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕
      个人功能总结: 类加载子系统将class文件加载到方法区中
      类的主动使用与被动使用:
        功能: 类使用需要经历 加载->链接->初始化阶段，也就是一个类被jvm加载了，不代表初始化，当初始化的时候需要调用类clinit()
        主动使用:
          - 1.创建类实例
          - 2.访问某个类或者接口的静态变量，或者对该静态变量赋值
          - 3.调用类的静态方法
          - 4.反射调用(比如：Class.forName("com.ClassLoader.custom.PersonEntity"))
          - 5.初始化一个类的子类
          - 6.Java的虚拟机启动时被标明为启动类的类
          - 7.java.lang.invoke.MethodHandle实例的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则初始化
        被动使用: 除了以上情况都属于被动使用
      一共有3个阶段:
        加载阶段:
          功能:
            - 类加载器负责将class转换成DNA元数据模版
            - 通过一个类的全限定名获取定义此类的二进制字节流
            - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
            - 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口
          类加载器分类:
            引导类加载器:
              引导类加载器(Bootstrap Class Loader)（C/C++语言实现）:
                功能:
                  - 它使用C/C++语言实现的，嵌套在JVM内部,它用来加载Java核心类库，用于提供JVM自身需要的类
                  - 负责加载【扩展类加载器】和【系统类加载器】，并且成为他们的父类加载器
                  - 出于安装考虑，Bootstrap引导类加载器只加载了包名为java，javax，sun等开头的类
                加载位置:
                    - D:/jdk1.8.0_121/jre/lib/
                    - D:/jdk1.8.0_121/jre/lib/resources.jar
                      D:/jdk1.8.0_121/jre/lib/rt.jar
                      D:/jdk1.8.0_121/jre/lib/sunrsasign.jar
                      D:/jdk1.8.0_121/jre/lib/jsse.jar
                      D:/jdk1.8.0_121/jre/lib/jce.jar
                      D:/jdk1.8.0_121/jre/lib/charsets.jar
                      D:/jdk1.8.0_121/jre/lib/jfr.jar
                通过系统属性查看: System.getProperty("sun.boot.class.path")
                是否继承java.lang.ClassLoader: 不继承
                父类加载器: 没有
            自定义类加载器(sun.misc.Launcher作为入口类):
              扩展类加载器(Extension Class Loader)（Java语言实现）:
                功能:
                  - Java语言编写，sun.misc.Launcher$ExtClassLoader@4f023edb
                  - 它是程序中默认的类加载器，一般情况下用户写的类都是由它来加载
                加载位置:
                  - D:\jdk1.8.0_121\jre\lib\ext\;
                  - D:\jdk1.8.0_121\jre\lib\ext\access-bridge-64.jar
                    D:\jdk1.8.0_121\jre\lib\ext\cldrdata.jar
                    D:\jdk1.8.0_121\jre\lib\ext\dnsns.jar
                    D:\jdk1.8.0_121\jre\lib\ext\jaccess.jar
                    D:\jdk1.8.0_121\jre\lib\ext\jfxrt.jar
                    D:\jdk1.8.0_121\jre\lib\ext\localedata.jar
                    D:\jdk1.8.0_121\jre\lib\ext\meta-index
                    D:\jdk1.8.0_121\jre\lib\ext\nashorn.jar
                    D:\jdk1.8.0_121\jre\lib\ext\sunec.jar
                    D:\jdk1.8.0_121\jre\lib\ext\sunjce_provider.jar
                    D:\jdk1.8.0_121\jre\lib\ext\sunmscapi.jar
                    D:\jdk1.8.0_121\jre\lib\ext\sunpkcs11.jar
                    D:\jdk1.8.0_121\jre\lib\ext\zipfs.jar
                  - C:\Windows\Sun\Java\lib\ext\
                  - 如果用户创建了xxx.jar放在jre/lib/ext目录下，也会被扩展类加载器加载
                通过系统属性查看: System.getProperty("java.ext.dirs")
                是否继承java.lang.ClassLoader: 继承
                父类加载器: 引导类加载器
              系统类加载器(Application Class Loader)（Java语言实现）:
                功能: Java语言编写，sun.misc.Launcher$AppClassLoader@18b4aac2
                加载位置:
                  - 由-classpath指定
                  - java -classpath xx1.jar;xx2.jar com.test.Test
                通过系统属性查看: System.getProperty("java.class.path")
                是否继承java.lang.ClassLoader: 继承
                父类加载器: 扩展类加载器
              自定义类加载器(Custom Class Loader)（Java语言实现）:
                功能:
                  - 实现同一个class文件不同加载器加载
                  - 实现动态加载类
                  - 可以对class做加密处理
                加载位置:
                  - 可以通过网络
                  - 可以通过磁盤
                是否继承java.lang.ClassLoader: 继承
                父类加载器: 系統类加载器
          双亲委派机制:
            功能:
              - Java虚拟机对class文件采用的是【按需加载】的方式，也就是说当要使用该类的时候才会将它的class文件加载到内存生成class对象。
              - 而且加载某个类的class文件时，Java虚拟机采用的是双亲委派机制，即把请求交给父类处理，它是一种任务委派模式。
            工作原理:
              - 如果一个类加载器收到了类加载请求，它并不会自己去先加载，而是把这个请求委托给父类的加载器去执行。
              - 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层引导类加载器。
              - 如果父类加载器可以完成类加载任务，就成功返回，如果父类加载器无法完成加载任务，则子类加载器才会尝试自己去加载。
            好处:
              - 可以避免冗余加载
              - 防止核心api篡改（当把java.lang开头的包提交到引导类的时候，引导类不会对其进行加载）
        链接阶段:
          校验:
            功能: 确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载的正确性，不会危害虚拟机的自身安全
            主要包括四种验证:
              - 文件格式校验
              - 元数据校验
              - 字节码校验
              - 符号引用校验
          准备:
            功能:
              - 为类变量分配内存，并且设置该类变量的默认初始值
                java代码定义：【这里的具体赋值需要到初始化阶段调用clinit()】
                  static String a1 = “hello”
                  static int a2 = 10
                  static bl a3 = true
                准备
                  static String a1 = null
                  static int a2 = 0
                  static bl a3 = false
              - 这里不包含用final修饰类变量,因为final修饰类变量在编译的时候就会分配，准备阶段会显示初始化
                  java代码定义：
                  final static String a1 = 'hello'
                  final static int a2 = 10
                  final static bl a3 = true
                准备
                  final static String a1 = 'hello'
                  final static int a2 = 10
                  final static bl a3 = true
              - 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会跟随对象一起分配到堆内存中
          解析:
            功能:
              - 将常量池（指的是class文件中的Constant pool）内的符号引用转换为直接引用(真实的内存地址)的过程
              - 事实上，解析操作往往会伴随着JVM在执行完初始化之后在执行
              - 符号引用就是一组符号来描述所引用的目标，符号引用的字面量形式明确定义在Java虚拟机规范的Class文件中。
              - 直接引用就是直接指向了目标的指针，相对偏移量或一个间接定位到目标的句柄
              - 解析动作主要针对类或接口,字段,类方法,接口方法,方法类型等.对应的常量池中CONSTANT_Class_info CONSTANT_Fieldref_info CONSTANT_Methodred_info等
        初始化阶段:
          功能:
            - <clinit>()主要是对类变量和静态代码块的整合，然后进行初始化
            - 初始化阶段就是执行类构造器方法<clinit>()的过程
                <clinit>()作用对类变量赋值
                static String a1 = “hello”
                static int a2 = 10
                static bl a3 = true
                static {
                  int num = 10;
                  int num1 = a2;
                }
            - 此方法不需要定义，是javac编译器自动收集类中的【所有类变量的赋值动作】和【静态代码块中的语句】合并而来
            - 类构造器方法<clinit>()中的指令集执行顺序是根据源代码中出现的顺序执行
                0 iconst_1
                1 putstatic #2 <com/test/Test.a>
                4 iconst_3
                5 istore_0
                6 return
            - <clinit>()不同于类的构造器(关联:构造器是虚拟机视角下的<init>())
            - 若该类具有父类,JVM会保证父类的<clinit>()先执行，然后在执行子类的<clinit>()
            - 虚拟机必须保证一个类的<clinit>()方法在多线程下同步加锁
  中层:
    运行时数据区:
      功能:
        - 内存是长飞重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。
        - JVM内存布局规定了Java在运行过程中内存申请，分配，管理的策略，保证了JVM的高效运行
        - 不同的JVM对于内存的划分方式和管理机制存在着部分差异(hotspot有方法区，J9和Jrockit没有方法区)
      1.方法区(线程共享):
          功能:
            - 对于Hotspot而言，方法区还有一个别名叫非堆，所以方法区可以看作是一块独立于Java堆的内存空间
            - 方法区与堆区一样，是各个线程共享的内存区域
            - 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和堆区一样都可以是不连续的
            - 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展
            - 方法区的大小决定了系统可以保存多少个类，如果系统顶了太多的类，会导致方法区溢出，从而抛OOM
            - 关闭JVM就会释放这个区域的内存
          永久代jdk7及之前(使用JVM虚拟机内存):
            设置永久代大小:
              - 默认 -XX:PermSize=21m    -XX:MaxPermSize=82m
              - 修改 -XX:PermSize=1g     -XX:MaxPermSize=1g
              - 查看 jinfo -flag PermSize/MaxPermSize 10780
          元空间jdk1.8之后(使用物理机本地内存):
            设置元空间大小:
              - 默认 -XX:MetaspaceSize=21m    -XX:MaxMetaspaceSize=-1无限大
              - 修改 -XX:MetaspaceSize=1g     -XX:MaxMetaspaceSize=1g
              - 查看 jinfo -flag MetaspaceSize/MaxMetaspaceSize 10780
              - 特别说明 只能通过jinfo -flag查看 初始值和最大值，图形界面看不到
              - 与永久代不同，如果不指定大小，默认情况下，虚拟机会消耗尽所有的可用系统内存
              - 对于一个64位的服务器端的JVM来说，其默认的-XX:MetaspaceSize=21m，这就是初始的高水位线，一旦触及这个水位线，将会被触发Full GC
              - 并且卸载没用的类(即这些类对应的类加载器不在存活)，然后这个高水位线将会充值，新的高水位线的值取决于GC后释放的了多少元空间，如果释放的空间不足，
              - 那么在不超过MaxMetaspaceSize时，释放提高该值，如果释放空间过多，则适当降低该值
              - 如果初始化的高水位线设置过低，上述高水位线调整的情况会发生很多次，通过垃圾回授权的日志可以观察到Full GC多次调用，
              - 为了避免频繁的GC，建议将-XX:MetaspaceSize=21m设置为一个对象较高的值
          永久代替换元空间好处:
            永久代设置内存的大小很难确定:
              - 在某些场景下，如果动态加载类过多，容易产生OOM
              - 比如某个实际的Web工程中，因为功能点比较多，在运行过程中，要不断动态加载类，很容易出现OOM
            永久代调优很困难:
          方法区存储内容:
            - 类信息
                类型信息
                  这里到类加载的时候还会把类加载器的信息加载进来
                  对每个加载的类型，JMV必须在方法区中存储以下类型信息
                  这个类型的完成有效名称(全类名=包名.类名)
                  这个类型的直接父类的完整有效名(java.lang.Object没有父类)
                  这个类型的修饰符(public,abstract,final的某个子集)
                  这个类型的直接口的一个有序表
                  public class com.Test
                  minor version 0
                  major version 52
                  flags ACC_PUBLIC, ACC_SUPER
                字段信息
                  JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序
                  域的相关信息包括，域名称，域类型，域修饰符(public,private,protected,static,final,volatile,transient的某个子集)
                  static int i;
                  descriptor I
                  flags ACC_STATIC

                  static final int b;
                  descriptor I
                  flags ACC_STATIC, ACC_FINAL
                  ConstantValue int 10
                方法信息
                  JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序
                  方法的名称
                  方法的返回类型(int void...)
                  方法参数的数量和类型(按顺序)
                  方法的修饰符(public,private,finanl,static,protected,synchronized,natice,abstract的一个子集)
                  方法的字节码(Code),操作数栈，局部变量表以及大小(abstract和native方法除外)
                  异常表(abstract和native方法除外)
                  每个异常表处理的开始位置，结束位置，代码处理在程序计数器中的便宜地址，被捕获的异常类的常量池索引
                  public com.Test();
                  descriptor ()V
                  flags ACC_PUBLIC
                  Code
                  stack=1, locals=1, args_size=1
                  0 aload_0
                  1 invokespecial #1                  // Method java/lang/Object."<init>":()V
                  4 return
                  LineNumberTable
                  line 7 0
                  LocalVariableTable
                  Start  Length  Slot  Name   Signature
                  0       5     0  this   Lcom/Test;
            - 运行时常量池
                字符串常量池(StringTable)存放字面量
                常量池主要存放两大类常量，字面量和符号引用
                    字面量比较接近Java语言层次的常量概念，如果文本字符串，被声明的为final的常量值等
                      /**
                        #17 = Utf8               LocalVariableTable
                        #18 = Utf8               this
                        #19 = Utf8               Lcom/Test;
                        #20 = Utf8               hello 自己定义的字符串
                        #21 = Utf8               main
                        #22 = Utf8               ([Ljava/lang/String;)V
                        #23 = Utf8               args
                        #24 = Utf8               [Ljava/lang/String;
                        #25 = Utf8               a
                        #26 = Utf8               Ljava/lang/String;
                        #27 = Utf8               Exceptions
                      **/
                    而符号引用则属于编译原理方面的概念，包括下面三类常量
                      类和接口的全限定名
                      字段的名称和描述符
                      方法的名称和描述符
                常量池，可以看做是一张表，虚拟机指令根据这张常量池表找到要执行的类名，方法名，参数类型，字面量等类型
                常量池存储了，数量值，字符串值，类引用，字段引用，方法引用
                一个有效的字节码文件中除了包含类的版本信息，字段，方法以及接口等描述信息外，还包含一项信息那就是常量池表，包括各种字面量，类型，域和方法的符号引用
                常量池表是Class文件的一部分，用于存放编译前生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中
                运行时常量池，在加载类和接口到虚拟机后，就会创建每一个类或接口对应的运行时常量池
                JVM为每个已加载的类型(类或接口)都维护一个常量池，翅中数据项就像数组一样，是通过索引访问的
                运行时常量池中包含了多种不同的常量，包括编译前就已经明确的数值字面量，也包括到运行期解析后才能获得的方法或者字段的引用，此时不再是常量池中的符号地址了，这里换为真实地址
                  运行时常量池，相对于Class文件常量池的另一重要的特征是，具备动态性
                运行时常量池类似于传统编程语言中的符号表，但是它所包含的数据却比符号表要更加丰富一些
                  Constant pool
                    /**
                    #1 = Methodref          #7.#32         // java/lang/Object."<init>":()V
                    #2 = Class              #33            // java/lang/String
                    #3 = String             #34            // 1
                    #4 = Methodref          #2.#35         // java/lang/String."<init>":(Ljava/lang/String;)V
                    #5 = Fieldref           #6.#36         // com/Test.i:I
                    #6 = Class              #37            // com/Test
                    #7 = Class              #38            // java/lang/Object
                    #8 = Utf8               i
                    #9 = Utf8               I
                    #10 = Utf8               b
                    #11 = Utf8               ConstantValue
                    #12 = Integer            10
                    #13 = Utf8               <init>
                    #14 = Utf8               ()V
                    #15 = Utf8               Code
                    #16 = Utf8               LineNumberTable
                    #17 = Utf8               LocalVariableTable
                    #18 = Utf8               this
                    #19 = Utf8               Lcom/Test;
                    #20 = Utf8               hello
                    #21 = Utf8               main
                    #22 = Utf8               ([Ljava/lang/String;)V
                    #23 = Utf8               args
                    #24 = Utf8               [Ljava/lang/String;
                    #25 = Utf8               s
                    #26 = Utf8               Ljava/lang/String;
                    #27 = Utf8               Exceptions
                    #28 = Class              #39            // java/lang/InterruptedException
                    #29 = Utf8               <clinit>
                    #30 = Utf8               SourceFile
                    #31 = Utf8               Test.java
                    #32 = NameAndType        #13:#14        // "<init>":()V
                    #33 = Utf8               java/lang/String
                    #34 = Utf8               1
                    #35 = NameAndType        #13:#40        // "<init>":(Ljava/lang/String;)V
                    #36 = NameAndType        #8:#9          // i:I
                    #37 = Utf8               com/Test
                    #38 = Utf8               java/lang/Object
                    #39 = Utf8               java/lang/InterruptedException
                    #40 = Utf8               (Ljava/lang/String;)V
                      **/
            - JIT代码缓存
          jdk1.6及以前: 字符串常量池(String Table),静态变量(静态变量名)，存放方法区
          jdk1.7及以后: 字符串常量池(String Table),静态变量(静态变量名)，存放堆空间
          jdk1.7中为什么要把字符串常量池和静态变量从方法区转移到堆空间:
            - 因为方法区回收需要FullGC,而FullGC的触发需要老年代或者永久代空间不足的时候触发，所以放在堆区，回收效率高
            - 在我们开发中会有大量的字符串被创建字符串被创建，回收效率低，容易导致永久代内存不足，放到堆里面能够及时回收内存
          是否支持GC:
            - 对于一个64位的服务器端的JVM来说，其默认的-XX:MetaspaceSize=21m，这就是初始的高水位线，一旦触及这个水位线，将会被触发Full GC
            - 有些人认为方法区是没有垃圾收集行为的，其实不然。Java虚拟机规范，对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现GC
            - 事实上也确实有未实现或未能完整的实现方法区类型卸载的收集器存在(JDK 11时期的ZGC收集器不支持类卸载)
            - 方法区的GC主要有2部分，一部分是常量池中不使用的常量，一部分是不在使用的类信息
                常量的回收，Hotspot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收
                类信息的回收
                    该类的所有的实例都已经被回收，也就是说Java堆中不存在该类及求他任何派生子类的实例
                    加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGI，JSP的重加载等，否则通常是很难达成的
                    该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
            - Java虚拟机被允许对满足上述的三个条件的无用类进行回收，这里说的仅仅是被允许，而并不是和对象一样，没有引用就必然会回收。
            - "关于是否要对类型进行回收，Hotspot虚拟机提供-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClass-Loading -XX:+TraceClassUnLoading查看类加载和卸载信息"
            - 在大量使用反色，动态代理（Jdk,CGLib）等字节码框架，动态生成JSP以及OSGI这类频繁的自定义类加载器场景中，通常都需要Java虚拟机具备类卸载的能力，以保证不会对方法区造成过大的内存压力
          是否会出现异常: 当元空间/永久代空间不足时，触发GC，GC还存不下该对象，触发OOM
      2.堆区(线程共享):
          功能:
            - 栈管运行，堆管存储
            - 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域
            - 【Java堆区在JVM启动的时候被创建，其空间大小也就确定了】，是JVM管理的最大一块内存空间
            - Java虚拟机规范规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它是连续的。
            - 堆的大部分内存都被线程共享，只有TLAB(Thread Local Allocation Buffer)缓存区是线程私有的
            - Java虚拟机规范中对Java堆的描述是，所有的对象实例以及数组都应当在运行时分配在对上。
            - 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置
            - 在方法结束后，堆中的对象不会被立马移除，仅仅在垃圾收集(GC)的时候才会被移除
            - 堆是GC执行垃圾的重点区域
          正常对象内存分配过程(重点):
            - https://www.bilibili.com/video/BV1PJ411n7xZ?p=72&spm_id_from=pageDriver
            - new对象 -> 伊甸园(TLAB) -> 伊甸园 -> 幸存者区(15岁以后) -> 老年区
            - new对象 -> 伊甸园(TLAB) -> 伊甸园 -> 伊甸园满了以后 -> 触发MinorGC(伊甸园区+幸存者from区)将没有引用的对象清理掉 -> 对象头的age属性加1
                                                                                                      -> 把age=16【晋升到】老年区 -> 老年区满以后 -> 触发MajorGC将没有引用的对象清理掉
                                                                                                      -> 把age<16存到幸存者to区(有引用的对象)
          特殊情况对象内存分配过程(重点):
            - new对象 -> 伊甸园(TLAB) -> 伊甸园
                                        放不下 -> 触发MinorGC -> 伊甸园
                                                 放不下 -> 永久代
                                                          放不下 -> 触发MajorGC -> 永久代
                                                                   放不下 -> OOM
          内存分配策略(或对象晋升规则):
            - 优先分配到伊甸园区
            - 大对象直接分配到老年代
            - 长期存活的对象分配到老年代
            - 动态对象年龄判断
                如果幸存者区中相同年龄的所有对象带下总和大于幸存者空间的一半，年龄大于或者等于该年龄的对象可以直接进入老年代，无须等到-XX:MaxTenuringThreshold=15中要求的年龄
            - 空间分配担保
                在JDK7以后-XX:HandelPromotionFailure此参数不能影响到它了，但默认会有空间分配担保
                -XX:HandelPromotionFailure=true
                    在发生MinorGC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。
                      如果大于,则尝试进行一次MinorGC,但这次MinorGC依然事有风险的
                      如果小于,则进行一次FullGC
                -XX:HandelPromotionFailure=false
                    直接进行一次FullGC
          新生代区:
            功能:
              - 绝大部分的Java对象的销毁都在新生代进行了
              - IBM公司研究表明，新生代中80%的对象都是“朝生夕死”的
            伊甸园区(Eden):
              功能:
                - 几乎所有Java对象都是在伊甸园区被new出来的
              TLAB线程私有缓冲区:
                功能:
                  - 从内存模型角度，而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区，它包含在了伊甸园空间内
                  - 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略
                  - 据我所知，所有OpenJDK衍生出来的JVM都提供了TLAB的设计
                为什么要有TLAB:
                  - 堆区是线程共享区域，任何线程都可以访问到堆区的共享数据
                  - 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
                  - 为了避免多个线程操作同一个地址，需要使用加锁等机制，进而影响分配速度。
                  - 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选
                  - 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用【加锁机制确保数据操作的原子性】，从而直接在伊甸园空间中分配内存
                TLAB参数设置:
                  - 查看 TLAB jinfo -flag UseTLAB 10332
                      -XX:+UseTLAB
                  - 默认设置 -XX:TLABSize=512k
            幸存者区(S0/S1):
              功能:
                - from区 to区
                - 复制之后有交换，谁空谁是to
          老年代区:
            功能:
              - 存放幸存者区经历过多次GC扔存活的对象
          可使用堆内存: 伊甸园区+(幸存者0区 or 幸存者1区)+老年代区
          设置堆大小(新生代+老年代):
            - https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html
            - 堆空间的初始值 -Xms20m
            - 堆空间的最大值 -Xmx20m
            - 通常会将 -Xms -Xmx 参数配置相同的值，其目的是为了能够在GC(Java垃圾回收机制)清理完堆区后不需要重新分配计算堆区大小，从而提高性能
            - -Xms1024 -Xmx1024
            - -Xms20K -Xmx20K
            - -Xms20m -Xmx20m
            - -Xms1g -Xmx1g
            - 默认情况下
               初始内存 物理电脑内存大小/64
                  long initSize = Runtime.getRuntime().totalMemory() / 1024 /1024;
               最大内存 物理电脑内存大小/4
                  long maxSize = Runtime.getRuntime().maxMemory() / 1024 /1024;
            - 可以使用
          设置伊甸园区和幸存者区占比:
            - 关闭自适应内存策略 -XX:-UseAdaptiveSizePolicy
            - 查看命令 jinfo -flag SurvivorRatio 11924
            - 默认 -XX:SurvivorRatio=8 伊甸园区占8 幸存者0占1 幸存者1占1 8:1:1
                  默认情况下显示是的占比8，实际是6，所以需要手动显式指定-XX:SurvivorRatio=8
            - 修改 -XX:SurvivorRatio=6 伊甸园区占6 幸存者0占1 幸存者1占1 6:1:1
          设置新生代跟老年代占比:
            - 查看命令 jinfo -flag NewRatio 11924
            - 默认 -XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3
            - 修改 -XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5
            - -Xmn400m 可以强行执行新生代的大小，如果此参数设置 -XX:NewRatio参数会失效
          设置对象年龄的阈值(age):
            - 默认 -XX:MaxTenuringThreshold=15
            - 修改 -XX:MaxTenuringThreshold=20
          是否支持GC: 存在GC
          是否会出现异常:
            - 一旦堆区中的内存大小超过了"-Xmx"所指定的最大内存时，就会抛出OOM(OutOfMemoryError)异常
            - 当老年代空间不足时，触发GC，GC还存不下该对象，会触发OOM
                  伊甸园区和幸存者区空间不足都会存到老年代区，所以堆区只有老年代会触发OOM
      3.本地方法栈(线程独享):
          功能:
            - 调用本地方法(native方法)
            - Java虚拟机用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用
            - 本地方法栈是线程私有的
            - 本地方法是使用C语言实现的
            - 它的具体做法是本地方法栈中登记了本地方法，在执行引擎执行时加载本地方法库
            - 当某个线程调用一个本地方法，它就进入了一个全新的并且不再受虚拟机限制的世界，它虚拟机拥有同样的权限
                本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区
                它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量内存
            - 并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言，具体实现方式，数据结构等。
            - 如果JVM产品不大算支持本地方法，也可以无需实现本地方法栈
            - 在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一
          是否支持GC: 不支持
          是否会出现异常:
            - 固定大小(jvm默认)/StackOverFlowError
                如果线程请求分配的栈容量超过本地方法栈允许的最大容量，StackOverFlowError异常
            - 动态扩展/OutOfMenoryError
                如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新
                的线程时没有足够的内存区创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMenoryError异常
      4.Java虚拟机栈(线程独享):
          功能:
            - 栈管运行，堆管存储
            - 每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个栈帧，每个栈帧对应一个方法的调用
            - Java虚拟机栈的声明周期和线程共存亡
            - Java虚拟机栈它保存方法的局部变量(8种基本数据类型，对象的引用地址)，以及线程运行中产生的部分结果，并且参与方法的调用和返回
            - Java虚拟机栈的操作只有2个
              出栈
              进栈
            - 调用非native方法
            - 1个栈帧包含(本地变量表,操作数栈,动态链接,方法返回地址,一些附加信息)
            - 1个栈帧对应源代码1个方法,1个方法的执行对应一个栈帧入栈，一个方法的结束对应一个栈帧的出栈
            - 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器
            - 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧(栈顶栈帧)是有效的，这个栈帧被称为当前栈帧，与当前真真相对应的方法就是当前当面，定这个方法的类就是当前类
            - 执行引擎运行的所有字节码指令只针对当前栈帧进行操作
            - 如果在该方法中调用了其他方法，对应的新的栈帧会创建出来，放在栈顶，成为新的当前栈帧
            - 不同线程中所包含的栈是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧
            - 如果当前党法调用了其他方法，方法返回之前，当前栈帧会传回此方法的执行结果给前一个栈帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧
            - Java方法(栈帧)有两种返回的方式，一种是正常方法返回(return),另一种事抛出异常返回(throw RuntimeException)，都会导致栈帧被弹出
          栈的存储单位: 栈帧(Stack Frame)
          栈帧:
            局部变量表/本地变量表:
              功能:
                - 局部变量表也被称为局部变量数组或本地变量表
                - 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据包括各类基本数据类型，对象引用，以及returnAddress类型
                - 由于局部变量表是在栈帧中，而栈帧又是在Java虚拟机栈中，所以局部变量表是线程的私有数据，因此不存在数据安全问题
                - 局部变量表中的变量只在当前栈帧(方法)中生效,在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。
                - 当栈帧(方法)调用结束后，随着栈帧的销毁，局部变量表也随之销毁
                - 参数值的存放总是在局部变量数组的Index0开始，到数组长度—1索引结束
                - 局部变量表的基本存储单位是Slot（变量槽）
                - 局部变量表中存放编译期可知的各种基本数据类型(8种)，引用类型(reference)，returnAddress类型变量
                - 类变量(静态变量)和局部变量对比
                  我们知道【类变量表】有两次初始化机会，第一次是在连接阶段->准备环节中赋默认值，第二次是在初始化阶段赋值(代码中写的值)
                  和类变量初始化不同的是，局部变量表不存在系统初始化过程，这意味着一旦定义了局部变量则必须认为初始化，否则无法使用
                  public void test5(){
                  int a;
                  System.out.println(a);//不能直接使用
                  }
                - 在栈帧与栈帧之间的调用时，虚拟机利用局部变量表来进行参数传递，也就是方法调用之前是否需要传参，方法结束的时候是否需要返回参数
                - 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或者间接引用的对象都不会被回收
              从字节码层面:
                局部变量表的大小:
                  - 局部变量表所需要的容量大小是在编译期间(javac)就确定下来的，在方法运行期间不会改变局部变量表的大小
                    方法 -> test -> Code -> 杂项 -> 局部变量最大槽数
                局部变量表的位置:
                  - 方法 -> test -> Code -> LocalVariableTable
                局部变量表的单位: 槽slot
                槽slot:
                  - 一个槽=4个字节=32位
                  - byte short float char boolean(0表示false,1表示true) 被转换为int
                  - int 引用类型 占1个槽
                  - long double 占2个槽
                  - JVM会为局部变量表中的每一个Slot都分配一个访问索引,通过这个索引即可成功访问到局部变量表中指定的局部变量值
                  - 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上
                  - 如果需要访问局部变量表中一个，只需要使用索引号(槽的索引)即可访问
                  - 如果当前栈帧是由构造方法或者实例方法创建的，那么该对象的引用this将会存放在Index为0的slot位置，其他的参数按照参数顺序继续排位
                    public Test(){
                    //this
                    }
                    public void test(){
                    //this
                    }
                  - 槽的重复利用
                    public void test5(){
                    int a = 10;
                    {
                    // int b = 10;
                    double c = 20;
                    }
                    int d = 20;
                    }
            操作数栈/表达式栈:
              功能:
                - 操作数栈底层是基于数组实现的，栈是先进后出
                - 操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据，或者提取数据
                - 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数栈的值取出，使用他们后再把结果压入栈。
                - 操作数栈主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间
                - 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个栈帧的操作数栈是一个空的数组
                - 我们说Java虚拟机的解析引擎是基于栈的执行引擎，其中指的就是操作数栈
              从字节码层面:
                操作数栈的大小:
                  - 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期(javac)就定义好了
                    方法 -> test -> Code -> 杂项 -> 操作数栈最大深度
                操作数栈的单位: 深度
                深度:
                  1个深度 = 4个字节=32位
            动态链接:
              功能:
                - 指向运行时常量池的方法引用，目的是为了知道当前方法对应了运行时常量池的哪个方法
                - 每一个栈帧的内部都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。比如invokedynamic指令
                - 在Java源文件被编译到字节码文件中时，所有的变量和方法的符号引用都保存在class文件的常量池中。
                - 比如：描述一个方法调用了其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用
              从字节码层面:
                - Constant pool:
                  #1 = Methodref          #6.#17         // java/lang/Object."<init>":()V
                  #2 = Fieldref           #18.#19        // java/lang/System.out:Ljava/io/PrintStream;
                  #3 = String             #20            // 1
                  #4 = Methodref          #21.#22        // java/io/PrintStream.println:(Ljava/lang/String;)V
                - 0: getstatic     #2（静态解析）          // Field java/lang/System.out:Ljava/io/PrintStream;
                  3: ldc           #3                  // String 1
                  5: invokevirtual #4 (动态链接)          // Method java/io/PrintStream.println:(Ljava/lang/String;)V
                  8: return
            方法返回地址:
              功能:
                - 针对的是正常退出而言，存放调用该方法的pc寄存器的值
                - 本质上，方法的退出就是当前栈帧出栈的过程，此时需要恢复上层方法的局部变量表，操作数栈，将返回值压入调用者栈帧的操作数栈，设置PC寄存器值等，让调用者方法继续执行下去
              正常退出: 调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址
              异常退出:
                - 异常完成出口退出的不会给他的上层调用则产生任何的返回值
                - 在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是说只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出
          是否支持GC: 不支持
          是否会出现异常:
            - 固定大小(jvm默认)/StackOverFlowError
              如果采用固定大的Java虚拟机栈，那么每个线程的Java虚拟机栈容量可以在线程创建的时候独立选定，
              如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容易，则抛异常
            - 动态扩展/OutOfMenoryError
              如果采用动态扩展Java虚拟机栈，那么线程在尝试扩展的时候无法申请到足够的内存，或者在創建新的綫程
              时没有足够的内存去创建对应的虚拟机栈，则抛异常
          设置栈大小:
            - 默认Linux/macOS = 1024kb
            - 默认Windows = 没有明确说明
            - -Xss1m
            - -Xss1024k
            - -Xss1048576
      5.程序计数器(线程独享):
          功能:
            - 也叫PC寄存器(Program Counter Register)
            - 程序计数器用来存储指向下一条指令的地址，由执行殷勤读取下一条指令。
            - 它是一块很小的内存空间，几乎可以忽略不计，也是运行速度最快的存储区域
            - 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致
            - 程序计数器会存储当前线程正在执行的指令地址
                0 aload_0
                1 invokespecial #1 <java/lang/Object.<init> : ()V>
                4 return
                (0 1 4)就是指令地址
            - 如果是在执行native方法，则是未指定的值(undefined)
            - 它是程序空间流的指示器，如分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成
            - 执行引擎工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
            - 它是唯一一个在Java虚拟机规范中没有出现任何的OOM情况的区域
          是否支持GC: 不支持
          是否会出现异常: 不出现
      堆是分配对象存储的唯一选择吗?:
        逃逸分析技术之栈上分配:
          功能:
            - 在深入理解Java虚拟机中描述，随着JIT即时编译器的发展，与逃逸分析技术逐渐成熟，栈上分配，标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到对上也渐渐变得不那么"绝对了"
            - 在Java虚拟机中，对象是在Java堆中分配内存的，这个是一个普遍的认知。
            - 但是有一种特殊情况，那就是如果经过逃逸分析后发现，一个new出来的对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无序在堆上分配内存，也无序进行GC回收，这也是最常见的对外存储技术。
            - 在JDK6u23以后的版本，默认开启了套你分析
            - 通过逃逸分析，Java Hotspot编译器能够分析出一个new对象的引用使用范围，从而决定是否需要将这个对象分配到堆上
            - 逃逸分析的基本行为就是分析对象的动态作用域，当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸，反之则发生逃逸。
        使用逃逸分析技术，编译器可以对代码做如下优化:
          栈上分配:
            - 将堆分配转化为栈分配，如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配
            - JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有发逃逸出方法的话，就可能被优化成栈上分配(前提是栈空间能容纳的情况下，否则还是会堆分配),分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收，这样久无序进行垃圾回收
            - 测试栈上分配
                开启逃逸分析 -Xms256m -Xmx256m -XX:+PrintGCDetails -XX:+DoEscapeAnalysis
                    结论(在栈空间能容纳的情况下，栈上分配对象，并且不会触发MinorGC，执行时间较快)
                关系逃逸分析 -Xms256m -Xmx256m -XX:+PrintGCDetails -XX:+DoEscapeAnalysis
                    结论(堆上分配对象，会触发MinorGC，执行时间较慢)
          锁消除(同步省略):
            - 如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以考虑不同步
            - 在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被被发布到其他线程，那么JIT编译器在编译这个同步代码块的时候就会取消对这个部分代码的同步。
            - 这样就能大大一高并发性和性能，这个取消同步的过程就叫同步省略，也叫锁消除
          分离对象或标量替换: 有的对象可能不需要作为一个连续内存结构存在也可以被访问到，那么对象的部分(或全部)可以不存储在内存，而是存储早CPU寄存器中
          个人总结: 虽然有逃逸分析可以实现栈上分配，但是hotspot并没这样做，所以基于hotspot虚拟机来说，所有的new对象都是基于在堆上分配
        设置逃逸分析:
          开启: -XX:+DoEscapeAnalysis
          关闭: -XX:-DoEscapeAnalysis
      对象的实例化:
        创建对象方式:
          - new
          - 反射
          - clone()
          - 反序列化方式
          - 第三方库Objenesis
        对象的实例化过程:
          - 1.判断对象对应的类是否加载，链接，初始化
                虚拟机遇到一条new指令，首先去检查这个指令的参数能否在方法区的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类
                是否已经被加载，解析和初始化。(即判断类元信息是否存在)。如果不存在，那么在双亲委派机制下，使用当前类加载器以key(CLassLoader+包名+类名)进行查找对应的.class文件。
                如果没有找到文件，则抛出ClassNotFoundException异常，如果找到则进行类加载，并生成对应的Class类对象
          - 2.为对象分配内存
                首先计算对象占用的空间大小，接着在堆中划分一块内存给新对象。
                  如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小
                      int float char byte 引用类型(4字节)
                      double long (8字节)
                如果内存规整，使用指针碰撞
                  如果内存是规整的，那么虚拟机将采用的是指针碰撞法来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另一边，中间放着一个指针
                  作为分界点的指示器，分配内存就仅仅是吧指针向空闲的那边挪动一段与对象大小相等的距离。如果GC选择的是Serial或者ParNew这种基于压缩算法
                  的，虚拟机采用这种分配方式，一般使用带有compact(整理)过程的收集器时，使用指针碰撞。
                如果内存不规整，虚拟机需要维护一个列表，使用空闲列表分配
                  如果内存是不规整的，已使用的内存和未使用的内存相互交换，那么虚拟机将采用的是空闲列表来法来为对象分配内存。
                  意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象
                  实例，并更新列表上的内容。这种分配方式为空闲列表
                说明，选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又取决于垃圾回收器是否带有压缩整理功能决定
          - 3.处理并发安全问题
                在分配内存空间时，另外一个问题是及时保证new对象时候的线程安全性，创建对象是非常频繁的操作，虚拟机需要解决并发问题
                虚拟机采用了两种方式解决并发问题
                  CAS 失败重试，区域加锁，保证指针更新操作的原子性
                  TLAB 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预选分配一小块内存，称为本地线程分配缓冲区
          - 4.初始化分配到空间
                内存配分结束，虚拟机将分配到的内存空间都初始化为零值(意思就是成员变量都赋予默认值)(不包括对象头)，这一步保证了对象的实例字段
                在Java代码中可以不用初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值
          - 5.设置对象的对象头
               将，对象的所属类(即类的元数据信息)，对象的HashCode，对象的GC信息，对象的锁信息等数据存储在对象的对象头。
               这个过程的具体设置方式取决于JVM实现
          - 6.执行init方法进行初始化
                在Java程序的视角看，初始化才正式开始。
                初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。
      对象的内存布局:
        对象头(Header):
          运行时元数据(Mark Word):
            - 哈希值(HashCode)
            - GC分代年龄
            - 锁状态标志
            - 线程持有的锁
            - 偏向线程ID
            - 偏向时间戳
          类型指针:
            - 指向类元数据InstanceKlass，确定该对象所属的类型
          说明: 如果是数组，还需要记录数组的长度
        实例数据(Instance Data):
          规则:
            - 相同宽度的字段总是被分配在一起
            - 父类中定义的变量会出现在子类之前
            - 如果CompactFields参数为true(默认为true)，子类的窄变量可能插入到父类变量的空隙
          说明: 它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段(包括从父类继承下来的和本身拥有的字段)
        对齐填充(Padding): 不是必然的，也没有特别含义，仅仅祈祷占位符的作用
      对象的访问定位:
        句柄访问:
          访问流程: 局部变量表 -> 堆空间的句柄池(维护了2个指针)
                                  -> 1个指向对空间的实例对象
                                  -> 1个指向方法区的类元信息
          好处: 布局变量表的引用稳定指向句柄池地址，对象被移动时候(GC)只会改变句柄池中的实例对象指针即可
        直接指针(hotspot使用):
          访问流程: 局部变量表 -> 对空间对象实例 -> 方法区类元信息
      直接内存:
        功能:
          - 直接内存不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域
          - 直接内存是在Java堆外的，直接向系统申请的内存区间
          - 来源于NIO，通过存在堆中的DirectByteBuffer操作本地内存
              ByteBuffer.allocateDirect(1024*1024*100); 使用直接内存
              ByteBuffer.allocate(1024*1024*100); 使用堆内存
          - 一般来说，访问直接内存的速度会快，读写效率高
              因此处于性能考虑，读写频繁的场合可以考虑使用直接内存
              Java的NIO库允许Java程序使用直接内存
        缺点:
          - 分配和回收成本较高
        设置直接内存的大小:
          - 默认 直接内存大小 = 最大堆内存大小(-Xmx)
          - 修改 -XX:MaxDirectMemorySize=100m
          - 查看 jinfo -flag MaxDirectMemorySize 6296
        是否支持GC: 存在GC
        是否会出现异常: 一旦MaxDirectMemorySize=100m超过了设置直接内存大小，就会导致OOM java.lang.OutOfMemoryError Direct buffer memory
      GC:
        功能:
          - https://www.bilibili.com/video/BV1PJ411n7xZ?p=76&spm_id_from=pageDriver
          - 频繁在新生代区收集，很少在养老代区收集，几乎不再永久代/元空间收集
          - JVM进行GC时，并非每次都对这（新生代，老年代，方法区(永久代/元空间)）3个区域一起回收的，大部分时候回收的都是新生代
          - STW（stop the world）
            触发GC以后，会导致用户线程暂停，GC线程执行垃圾回收
        GC回收区域划分为两种大类型（针对Hotspot的实现）:
          - 部分收集（Partial GC）不完全收集整个Java堆的垃圾收集
              新生代收集（Minor GC / Young GC）只是新生代(伊甸园区，幸存者from区)的垃圾收集
              老年代收集（Major GC / Old GC）只是老年代的收集收集
                目前，只有CMS GC会有单独收集老年代的行为
                注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收
              混合收集（Mixed GC）收集整个新生代以及部分老年代的垃圾收集
                目前,只有G1 GC会有这种行为
          - 整堆收集（Full GC）收集整个Java堆区(新生代收集和老年代收集)和方法区(永久代/元空间)的垃圾收集
        MinorGC:
          - 触发者条件是伊甸园区内存空间不足
          - MinorGC完全等价YoungGC
          - 收集区域:"对伊甸园区和幸存者from区进行垃圾收集"
          - 因为Java对象"大多数具备朝生夕死"的特性，所以MinorGC非常频繁，一般回收速度也比较快
          - MinorGC会引发STW，暂停用户线程，等待GC线程垃圾回收结束，用户线程才恢复运行
        MajorGC:
          - 触发者条件是老年代区内存空间不足
          - MajorGC完全等价OldGC
          - 收集区域:"对老年代区进行垃圾收集"
          - 出现了MajorGC，经常会伴随至少一次MinorGC,也就是说老年代空间不足时，会先尝试触发MinorGC,如果之后空间还不足，则触发MajorGC(但非绝对的，在Parallel Scavenge收集器的收集策略里就是直接进行MajorGC，而没有进行MinorGC)
          - MajorGC的速度一般会比MinorGC慢10倍以上，STW的时间会更长
          - 如果MajorGC后，内存还不足，就报OOM了
        FullGC:
          - 收集区域 堆区+方法区+直接内存(NIO)
          - 收集区域 对新生代(伊甸园区，幸存者form区)，老年代，方法区(元空间/永久代)，直接内存(NIO)
          - 触发FullGC的三种情况
          - 1.调用System.gc()时，系统建议执行FullGC，但是不必然执行
          - 2.老年代空间不足
                通过MinorGC后进入老年代的平均大小大于老年代的可用内存
                由伊甸园区，幸存者from区向幸存者to区复制时，对象大小大于幸存者to区可用内存，则把该对象转存到老年代，而且老年代的可用内存小于该对象大小
          - 3.方法区空间不足
                对于一个64位的服务器端的JVM来说，其默认的-XX:MetaspaceSize=21m，这就是初始的高水位线，一旦触及这个水位线，就会触发Full GC
  下层:
    执行引擎:
      功能:
        - 将字节码指令转换成机器指令,最后将机器指令给CPU运行
        - 虚拟机是一个相对于物理机的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器，缓存，指令集和操作系统层面上的，而虚拟机的执行引擎是由软件自行实现的，因此可以不受物理条件的约束定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式
        - JVM的主要任务是负责装载字节码到其内部，但是字节码并不能够直接运行在操作系统之上，因为字节码指令不等价于机器指令，它内部包含的仅仅是一些能够被JVM所识别的字节码指令，符号表，以及其他辅助信息
        - 如果想要一个Java程序运行起来，执行引擎的任务就是将字节码指令[解析/编译]为对应平台上(windows/linux/ios)的本地机器指令才可以。
        - 简单来说，JVM中的执行引擎充当了将高级语言翻译成机器语言的翻译者
        - 从外观上看，所有的Java虚拟机的执行引擎输入，处理，输出都是一样的，输入的就是字节码二进制流，处理过程就是将字节码解析执行的等效过程，输出的就是执行结果
        - Hotspot JVM是目前市面上高性能虚拟机的代表作之一，它采用解析器与及时编译器并存的架构，在Java虚拟机运行时，解析器和及时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时候和直接解析执行代码的时间
        - Java代码的执行分类
            第一种是将源代码编译成字节码文件，然后在运行时通过解析器将字节码文件转为机器码执行
            第二种是编译执行(直接编译成)，现代虚拟机为了提高执行效率，会使用及时编译技术将jvm指令编译成机器码后在执行
      设置Hotspot模式:
        - -Xint 完全采用解析器模式执行程序
        - -Xcomp 完全采用即时编译器模式执行程序。如果即时编译器出现问题，解析器会接入执行
        - -Xmixed 采用解析器+即时编译器的混合模式共同执行程序
      解析器和及时编译器为什么同时存在:
        - 当程序启动后，解析器可以立马发挥作用，省去编译的时间，立即执行。
        - 编译器要想发挥作用，需要把代码编译成本地代码，这个编译过程需要一定的执行时间。但是编译为本地代码以后，以后再次执行效率就很高
        - 当Java虚拟机启动时，解析器可以首先发挥作用，而不必等待即时编译器全部编译完后在执行，这样可以省去许多不必要的编译时间，随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，或得更高的执行效率
        - 同时，在编译器进行激进优化不成立的时候，解析器可以作为编译器的后备方案运行
        - Hotspot执行当时，当虚拟机启动的时候，解析器可以先手发挥作用，而不必等待即时编译器全部编译完在执行，这样可以省去许多不必要的编译时间，并且随着程序的运行时间的推移，及时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译编译为本地机器指令，以换取更高的程序执行效率
      编译器:
        前端编译器:
          - 把 .java文件编译成 .class文件
          - Sun公司提供的javac
          - Eclipse JDT中的增量式编译器(ECJ)
        后端运行期编译器:
          - 把字节码指令转换为机器码的过程
          - Hotspot client 用是的 JIT C1 编译器
          - Hotspot server 用是的 JIT C2 编译器
          - Hotspot JDK10 加入了一个 Graal编译器
        静态提前编译器:
          - 直接把 .java文件编译成本地机器代码过程
          - AOT编译器
          - 缺点就是不跨平台
          - https://www.bilibili.com/video/BV1PJ411n7xZ?p=117&spm_id_from=pageDriver
          - jdk9 使用jaotc工具将.class文件编译成.so文件
      1.解析器:
        功能:
          - 利用程序计数器逐行解析字节码，将字节码解析成机器指令并且执行
          - 当Java虚拟机启动时会根据预定义的规范对字节码采用【逐行解析的方式执行】，将每条字节码文件中的内容翻译为对应平台(windows/linux/ios)的机器指令执行
          - 解析器真正的意义上所承担的角色就是一个运行时翻译者，将字节码文件中的内容翻译为对应平台的本地机器指令执行。
          - 当一条字节码指令被解析执行完成后，接着在根据程序计数器中的记录的下一条需要被执行的字节码指令执行执行解析操作。
      2.即时编译器(JIT后端编译器):
        功能:
          - 通过程序计数器寻找热点代码,将字节码编译成机器指令并且执行（缓存机器指令，放在方法区的CodeCache）
          - JIT编译器就是将字节码直接编译成和本地机器相关的机器语言
          - 是否启动及时编译器，则需要根据代码被调用的【执行频率】而定。
          - 关于那些需要被即时编译器所编译的代码也称之为【热点代码】
          - JIT编译器编译器在运行时会针对那些频繁被调用的热点代码做出深入优化，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能
        热点代码:
          - 一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为【热点代码】
          - 因次都可以通过JIT编译器编译为本地机器指令，由于这种编译方式发生在方法的执行过程中，因此也被称为栈上替换
        hotspot基于计数器的热点探测方式:
          功能: 基于计数器的热点探测，hotspotVM 将会为每一个方法都建立2个不同类型的计数器,方法调用计数器和回边计数器
          方法调用计数器:
            - 方法调用计数器用于统计方法的调用次数
            - 当一个方法被调用时，会先检查该方法是否被JIT编译过
                  如果编译过，则优先使用编译后的本地代码来执行
                  如果没编译过，则此方法的调用计数器+1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值，如果已经超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求
            - 如果不做任何设置，方法调用计数器统计的并不是方法的绝对次数，而是一个相对的执行频率，即一段时间之内的方法调用的次数。
            - 当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给及时编译器编译，那么这个方法的调用计数器就会被【减少一半】，这个过程称为方法调用计数器的热度衰减，而这段时间就称为此方法统计的半衰周期
          回边计数器:
            - 回边计数器用于统计循环体执行的循环次数
          计数器设置参数:
            - 设置阈值，达到多少次会提交给及时编译器编译
                默认 Client模式下为-XX:CompileThreshold=1500 Server模式下为-XX:CompileThreshold=10000
            - 是否关闭热度衰减，开启，表示规定范围时间内需要累计达到10000次会进行及时编译器提交。关闭，表示不规定时间内累计达到10000次会进行即时编译提交
                默认开启 -XX:+UseCounterDecay
            - 设置衰减周期时间,单位是秒，VM选项“CounterHalfLifeTime”正在开发中，仅在VM的调试版本中可用。
                暂时不支持设置 -XX:CounterHalfLifeTime=100
      3.垃圾回收器:
      代码编译和代码执行的过程:
        代码编译:
          传统编译过程: 程序源码 -> 词法分析 -> 单词流 -> 语法分析 -> 抽象语法树
          javac编译过程: 源代码 -> 此法分析器 -> Token流 -> 语法分析器 -> 语法树/抽象语法树 -> 语义分析器 -> 注解抽象语法树 -> 字节码生成器
        代码执行:
          传统执行引擎解析器: 指令流(可选) -> 解析器 -> 解析执行
          传统执行引擎编译器: 优化器(可选) -> 中间代码(可选) -> 生成器 -> 目标代码
          jvm执行引擎解析器: JVM字节码 -> 字节码解析器 -> 解析执行
          jvm执行引擎编译器(JIT): JVM字节码 -> 机器无关优化 -> 中间代码 -> 机器相关优化 -> 中间代码 -> 寄存器分配器 -> 中间代码 -> 目标代码生成器 -> 目标代码(机器指令)
        说明: 大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经历过上图中的各个步骤
      指令和指令集:
        机器码:
          - 各种用二进制编码方式表示的指令(010101001)，叫做机器指令码。
          - 开始，人们就用它来编写程序，这就是机器语言
          - 机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不容易被人们理解和记忆，并且用它编程容易出差错
          - 用机器语言编写的程序一旦输入计算机，CPU能够直接读取运行，因此和其他语言变得程序相比，执行速度最快
        指令/机器指令:
          - 由于机器码是由0和1组成的二进制序列，可读性差，于是人类发明了指令
          - 指令就是把机器码中特定的0和1序列，简化成对应的指令
              比如 01010101 = mov指令
              比如 11110011 = inc指令
          - 由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令(比mov)，对应的机器码也可能不同。
        指令集:
          - 多个指令组成了指令集
          - 不同的硬件平台，哥自支持的指令是有差别的，因此每个平台所支持的指令，称之为对应平台的指令集
          - x86指令集，对应的是x86架构的平台
          - ARM指令集，对应的是ARM架构的平台
      汇编语言:
        - 由于指令/机器指令的可读性还是太差，于是人类又发明了汇编语言
        - 在汇编语言中，用助记符代替机器指令的操作码，用地址符号货标号代替指令或操作数的地址
        - 在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令
        - 由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行
      高级语言:
        - 为了使计算机用户编程更容易，后来久出现了各种高级计算机语言
        - 高级语言比机器语言，汇编语言更接入人类的语言
        - 当计算机执行高级语言编写的程序时，仍需要吧程序解析和编译成机器的指令码。完成这个过程的程序就叫做解析程序或编译程序
        - 案例1   汇编语言 -> 汇编的过程 -> 机器指令 -> CPU
        - 案例2   高级语言(字节码文件) -> 编译/解析过程 -> 汇编语言 -> 汇编的过程 -> 机器指令 -> CPU
    本地方法:
      功能:
        - 被native修饰的方法叫本地方法
          public final native Class<?> getClass();
          public native int hashCode();
          public final native void notify();
      与Java环境外交互:
        - 有时候Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。
        - 你可以想象Java需要与一些底层系统，如操作系统或者硬件交换信息的时候，本地方法正是这样的一种交流机制，
        - 它为我们提供了一个非常简洁的就扣，而且我们无需去了解Havana应用之外的繁琐细节
      与操作系统交互:
        - JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解析字节码）和一些连接到本地代码的库组成。
        - 然而不管怎么样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统尝尝是强大的操作系统。
        - 通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的。
        - 还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法
      Sun`s Java:
        - Sun的解释器是用C实现的，这使得它能想一些普通的C一样与外部交互。
        - jre大部分是用Java实现的，它也通过一些本地方法与外界交互。
        - 例如:类java.lang.Thread的setPriority()方法是Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。
        - 这个方法就是用C实现的，并且植入JVM内部，在Windows 95的平台上，这个本地费最终将调用Win 32 SetPriority()API。
        - 这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库提供，然后被JVM调用
      本地方法接口:
        功能: 被本地方法栈调用
      本地方法库:
        功能: 被本地方法栈调用
