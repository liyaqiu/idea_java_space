JVM介绍:
  Java及JVM简介:
    JVM虚拟机分类:
       - oracle收购Sun公司发行的HotSpot虚拟机
       - oracle收购了BEA发行的JRockit虚拟机
       - IBM发行J9虚拟机
    JDK分类:
      - Open JDK
      - Oracle JDK
  JVM虚拟机:
    - 遵循【Java规范的字节码】都可以运行在Java虚拟机上
    - 一次编译，到处运行
    - 自动内存管理
    - 自动垃圾回收功能
  Java代码执行流程: 源代码 -> Javac编译器 -> Class文件 -> 类加载器 -> 执行引擎
  JVM的架构模型:
    栈指令集架构:
      - 性能差，实现简单，移植行强
      - 典型案例:hotspot
      - 与CPU耦合底
      - 指令集小，指令多
    寄存器指令集架构:
      - 性能好，实现难，移植行差
      - 典型案例:window系统,安卓的Davlik虚拟机
      - 与CPU偶尔高
      - 指令集大，指令少
  JVM的生命周期:
    JVM启动: Java虚拟机的启动是通过【引导类加载器】创建一个初始类完成的，这个类是由虚拟机的具体实现指定的
    JVM运行: 执行一个所谓的Java程序的时候，才真真正正的执行Java虚拟机进程
    JVM退出:
      - 执行程序过程中异常导致jvm退出
      - 由操作系统出现错误导致jvm退出
      - System.exit(0);
      - Runtime.getRuntime().exit(0);
      - Runtime.getRuntime().halt(0);
  JVM后台系统线程:
    功能: 在JVM启动时候会默认创建
    线程类型:
      虚拟机线程:
        功能:
          - 这种线程的操作是需要JVM达到安全点才会出现，这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化
          - 这种线程的类型包括"stop-the-world"的垃圾收集，线程占收集，线程挂载以及偏向锁撤销
      周期任务线程: 这种线程是时间周期事件的体现(比如中断)，他们一般用于周期性操作的调度执行
      GC线程: 这种线程对在JVM里不同的种类的垃圾收集行为提供了支持
      编译线程: 这种线程在运行时会将字节码编译成本地代码
      信号调度线程: 这种线程接收信号并发给JVM，在它内部通过调用适当的方法进行处理
JVM的整体结构:
  上层:
    class字节码文件:
      功能: 由javac前端编译器编译成class字节码文件
      组成:
        - 类信息
        - 常量池（Constant pool）
    类加载子系统:
      功能:
        - 类加载器子系统负载从文件系统或者网络中加载Class文件，Class文件在文件开头有特定的文件标识，
        - ClassLoader只负责class文件的加载，至于它是否可以运行，则由执行引擎（Execution Engine）决定
        - 加载的类信息存放在方法区的内存空间，除了类的信息外，方法区中还会存放运行时常量池信息（指的是class文件中的Constant pool），
        - 可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）
        - 虚方法表的创建
            虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕
      个人功能总结: 类加载子系统将class文件加载到方法区中
      类的主动使用与被动使用:
        功能: 类使用需要经历 加载->链接->初始化阶段，也就是一个类被jvm加载了，不代表初始化，当初始化的时候需要调用类clinit()
        主动使用:
          - 1.创建类实例
          - 2.访问某个类或者接口的静态变量，或者对该静态变量赋值
          - 3.调用类的静态方法
          - 4.反射调用(比如：Class.forName("com.ClassLoader.custom.PersonEntity"))
          - 5.初始化一个类的子类
          - 6.Java的虚拟机启动时被标明为启动类的类
          - 7.java.lang.invoke.MethodHandle实例的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则初始化
        被动使用: 除了以上情况都属于被动使用
      一共有3个阶段:
        加载阶段:
          功能:
            - 类加载器负责将class转换成DNA元数据模版
            - 通过一个类的全限定名获取定义此类的二进制字节流
            - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
            - 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口
          类加载器分类:
            引导类加载器:
              引导类加载器(Bootstrap Class Loader)（C/C++语言实现）:
                功能:
                  - 它使用C/C++语言实现的，嵌套在JVM内部,它用来加载Java核心类库，用于提供JVM自身需要的类
                  - 负责加载【扩展类加载器】和【系统类加载器】，并且成为他们的父类加载器
                  - 出于安装考虑，Bootstrap引导类加载器只加载了包名为java，javax，sun等开头的类
                加载位置:
                    - D:/jdk1.8.0_121/jre/lib/
                    - D:/jdk1.8.0_121/jre/lib/resources.jar
                      D:/jdk1.8.0_121/jre/lib/rt.jar
                      D:/jdk1.8.0_121/jre/lib/sunrsasign.jar
                      D:/jdk1.8.0_121/jre/lib/jsse.jar
                      D:/jdk1.8.0_121/jre/lib/jce.jar
                      D:/jdk1.8.0_121/jre/lib/charsets.jar
                      D:/jdk1.8.0_121/jre/lib/jfr.jar
                通过系统属性查看: System.getProperty("sun.boot.class.path")
                是否继承java.lang.ClassLoader: 不继承
                父类加载器: 没有
            自定义类加载器(sun.misc.Launcher作为入口类):
              扩展类加载器(Extension Class Loader)（Java语言实现）:
                功能:
                  - Java语言编写，sun.misc.Launcher$ExtClassLoader@4f023edb
                  - 它是程序中默认的类加载器，一般情况下用户写的类都是由它来加载
                加载位置:
                  - D:\jdk1.8.0_121\jre\lib\ext\;
                  - D:\jdk1.8.0_121\jre\lib\ext\access-bridge-64.jar
                    D:\jdk1.8.0_121\jre\lib\ext\cldrdata.jar
                    D:\jdk1.8.0_121\jre\lib\ext\dnsns.jar
                    D:\jdk1.8.0_121\jre\lib\ext\jaccess.jar
                    D:\jdk1.8.0_121\jre\lib\ext\jfxrt.jar
                    D:\jdk1.8.0_121\jre\lib\ext\localedata.jar
                    D:\jdk1.8.0_121\jre\lib\ext\meta-index
                    D:\jdk1.8.0_121\jre\lib\ext\nashorn.jar
                    D:\jdk1.8.0_121\jre\lib\ext\sunec.jar
                    D:\jdk1.8.0_121\jre\lib\ext\sunjce_provider.jar
                    D:\jdk1.8.0_121\jre\lib\ext\sunmscapi.jar
                    D:\jdk1.8.0_121\jre\lib\ext\sunpkcs11.jar
                    D:\jdk1.8.0_121\jre\lib\ext\zipfs.jar
                  - C:\Windows\Sun\Java\lib\ext\
                  - 如果用户创建了xxx.jar放在jre/lib/ext目录下，也会被扩展类加载器加载
                通过系统属性查看: System.getProperty("java.ext.dirs")
                是否继承java.lang.ClassLoader: 继承
                父类加载器: 引导类加载器
              系统类加载器(Application Class Loader)（Java语言实现）:
                功能: Java语言编写，sun.misc.Launcher$AppClassLoader@18b4aac2
                加载位置:
                  - 由-classpath指定
                  - java -classpath xx1.jar;xx2.jar com.test.Test
                通过系统属性查看: System.getProperty("java.class.path")
                是否继承java.lang.ClassLoader: 继承
                父类加载器: 扩展类加载器
              自定义类加载器(Custom Class Loader)（Java语言实现）:
                功能:
                  - 实现同一个class文件不同加载器加载
                  - 实现动态加载类
                  - 可以对class做加密处理
                加载位置:
                  - 可以通过网络
                  - 可以通过磁盤
                是否继承java.lang.ClassLoader: 继承
                父类加载器: 系統类加载器
          双亲委派机制:
            功能:
              - Java虚拟机对class文件采用的是【按需加载】的方式，也就是说当要使用该类的时候才会将它的class文件加载到内存生成class对象。
              - 而且加载某个类的class文件时，Java虚拟机采用的是双亲委派机制，即把请求交给父类处理，它是一种任务委派模式。
            工作原理:
              - 如果一个类加载器收到了类加载请求，它并不会自己去先加载，而是把这个请求委托给父类的加载器去执行。
              - 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层引导类加载器。
              - 如果父类加载器可以完成类加载任务，就成功返回，如果父类加载器无法完成加载任务，则子类加载器才会尝试自己去加载。
            好处:
              - 可以避免冗余加载
              - 防止核心api篡改（当把java.lang开头的包提交到引导类的时候，引导类不会对其进行加载）
        链接阶段:
          校验:
            功能: 确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载的正确性，不会危害虚拟机的自身安全
            主要包括四种验证:
              - 文件格式校验
              - 元数据校验
              - 字节码校验
              - 符号引用校验
          准备:
            功能:
              - 为类变量分配内存，并且设置该类变量的默认初始值
                java代码定义：【这里的具体赋值需要到初始化阶段调用clinit()】
                  static String a1 = “hello”
                  static int a2 = 10
                  static bl a3 = true
                准备
                  static String a1 = null
                  static int a2 = 0
                  static bl a3 = false
              - 这里不包含用final修饰类变量,因为final修饰类变量在编译的时候就会分配，准备阶段会显示初始化
                  java代码定义：
                  final static String a1 = 'hello'
                  final static int a2 = 10
                  final static bl a3 = true
                准备
                  final static String a1 = 'hello'
                  final static int a2 = 10
                  final static bl a3 = true
              - 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会跟随对象一起分配到堆内存中
          解析:
            功能:
              - 将常量池（指的是class文件中的Constant pool）内的符号引用转换为直接引用(真实的内存地址)的过程
              - 事实上，解析操作往往会伴随着JVM在执行完初始化之后在执行
              - 符号引用就是一组符号来描述所引用的目标，符号引用的字面量形式明确定义在Java虚拟机规范的Class文件中。
              - 直接引用就是直接指向了目标的指针，相对偏移量或一个间接定位到目标的句柄
              - 解析动作主要针对类或接口,字段,类方法,接口方法,方法类型等.对应的常量池中CONSTANT_Class_info CONSTANT_Fieldref_info CONSTANT_Methodred_info等
        初始化阶段:
          功能:
            - <clinit>()主要是对类变量和静态代码块的整合，然后进行初始化
            - 初始化阶段就是执行类构造器方法<clinit>()的过程
                <clinit>()作用对类变量赋值
                static String a1 = “hello”
                static int a2 = 10
                static bl a3 = true
                static {
                  int num = 10;
                  int num1 = a2;
                }
            - 此方法不需要定义，是javac编译器自动收集类中的【所有类变量的赋值动作】和【静态代码块中的语句】合并而来
            - 类构造器方法<clinit>()中的指令集执行顺序是根据源代码中出现的顺序执行
                0 iconst_1
                1 putstatic #2 <com/test/Test.a>
                4 iconst_3
                5 istore_0
                6 return
            - <clinit>()不同于类的构造器(关联:构造器是虚拟机视角下的<init>())
            - 若该类具有父类,JVM会保证父类的<clinit>()先执行，然后在执行子类的<clinit>()
            - 虚拟机必须保证一个类的<clinit>()方法在多线程下同步加锁
  中层:
    运行时数据区:
      功能:
        - 内存是长飞重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。
        - JVM内存布局规定了Java在运行过程中内存申请，分配，管理的策略，保证了JVM的高效运行
        - 不同的JVM对于内存的划分方式和管理机制存在着部分差异(hotspot有方法区，J9和Jrockit没有方法区)
      1.方法区(线程共享):
          功能:
            - 永久代-堆内存: jdk1.7之前
            - 元空间-直接内存: jdk1.8之后
          元空间:
            常量池:
            方法元信息:
            klass类元信息:
          CodeCache:
            功能: JIT编译产物
          是否支持GC: 支持
          是否会出现异常: 出现
      2.堆区(线程共享):
          功能:
            - 栈管运行，堆管存储
            - 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域
            - 【Java堆区在JVM启动的时候被创建，其空间大小也就确定了】，是JVM管理的最大一块内存空间
            - Java虚拟机规范规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它是连续的。
            - 堆的大部分内存都被线程共享，只有TLAB(Thread Local Allocation Buffer)缓存区是线程私有的
            - Java虚拟机规范中对Java堆的描述是，所有的对象实例以及数组都应当在运行时分配在对上。
            - 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置
            - 在方法结束后，堆中的对象不会被立马移除，仅仅在垃圾收集(GC)的时候才会被移除
            - 堆是GC执行垃圾的重点区域
          正常对象内存分配过程(重点):
            - https://www.bilibili.com/video/BV1PJ411n7xZ?p=72&spm_id_from=pageDriver
            - new对象 -> 伊甸园 -> 幸存者区(15岁以后) -> 老年区
            - new对象 -> 伊甸园 -> 伊甸园满了以后 -> 触发MinorGC(伊甸园区+幸存者from区)将没有引用的对象清理掉 -> 对象头的age属性加1
                                                                                                      -> 把age=16【晋升到】老年区 -> 老年区满以后 -> 触发MajorGC将没有引用的对象清理掉
                                                                                                      -> 把age<16存到幸存者to区(有引用的对象)
          特殊情况对象内存分配过程(重点):
            - new对象 -> 伊甸园
                        放不下 -> 触发MinorGC -> 伊甸园
                                 放不下 -> 永久代
                                          放不下 -> 触发MajorGC -> 永久代
                                                   放不下 -> OOM
          内存分配策略(或对象晋升规则):
            - 优先分配到伊甸园区
            - 大对象直接分配到老年代
            - 长期存活的对象分配到老年代
            - 动态对象年龄判断
                如果幸存者区中相同年龄的所有对象带下总和大于幸存者空间的一半，年龄大于或者等于该年龄的对象可以直接进入老年代，无须等到-XX:MaxTenuringThreshold=15中要求的年龄
            - 空间分配担保
                -XX:HandelPromotionFailure
          新生代区:
            功能:
              - 绝大部分的Java对象的销毁都在新生代进行了
              - IBM公司研究表明，新生代中80%的对象都是“朝生夕死”的
            伊甸园区(Eden):
              功能:
                - "几乎所有"Java对象都是在伊甸园区被new出来的
              TLAB线程私有缓冲区:
                功能:
                  - 从内存模型角度，而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区，它包含在了伊甸园空间内
                  - 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略
                  - 据我所知，所有OpenJDK衍生出来的JVM都提供了TLAB的设计
                为什么要有TLAB:
                  - 堆区是线程共享区域，任何线程都可以访问到堆区的共享数据
                  - 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
                  - 为了避免多个线程操作同一个地址，需要使用加锁等机制，进而影响分配速度。
                  - 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选
                  - 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用【加锁机制确保数据操作的原子性】，从而直接在伊甸园空间中分配内存
                TLAB参数设置:
                  - 查看 TLAB jinfo -flag UseTLAB 10332
                      -XX:+UseTLAB
                  - 默认设置 -XX:TLABSize=512k
            幸存者区(S0/S1):
              功能:
                - from区 to区
                - 复制之后有交换，谁空谁是to
          老年代区:
            功能:
              - 存放幸存者区经历过多次GC扔存活的对象
          可使用堆内存: 伊甸园区+(幸存者0区 or 幸存者1区)+老年代区
          设置堆大小(新生代+老年代):
            - https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html
            - 堆空间的初始值 -Xms20m
            - 堆空间的最大值 -Xmx20m
            - 通常会将 -Xms -Xmx 参数配置相同的值，其目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分配计算堆区大小，从而提高性能
            - -Xms1024 -Xmx1024
            - -Xms20K -Xmx20K
            - -Xms20m -Xmx20m
            - -Xms1g -Xmx1g
            - 默认情况下
               初始内存 物理电脑内存大小/64
                  long initSize = Runtime.getRuntime().totalMemory() / 1024 /1024;
               最大内存 物理电脑内存大小/4
                  long maxSize = Runtime.getRuntime().maxMemory() / 1024 /1024;
            - 可以使用
          设置伊甸园区和幸存者区占比:
            - 关闭自适应内存策略 -XX:-UseAdaptiveSizePolicy
            - 查看命令 jinfo -flag SurvivorRatio 11924
            - 默认 -XX:SurvivorRatio=8 伊甸园区占8 幸存者0占1 幸存者1占1 8:1:1
                  默认情况下显示是的占比8，实际是6，所以需要手动显式指定-XX:SurvivorRatio=8
            - 修改 -XX:SurvivorRatio=6 伊甸园区占6 幸存者0占1 幸存者1占1 6:1:1
          设置新生代跟老年代占比:
            - 查看命令 jinfo -flag NewRatio 11924
            - 默认 -XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3
            - 修改 -XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5
            - -Xmn400m 可以强行执行新生代的大小，如果此参数设置 -XX:NewRatio参数会失效
          设置对象年龄的阈值(age):
            - 默认 -XX:MaxTenuringThreshold=15
            - 修改 -XX:MaxTenuringThreshold=20
          GC:
            功能:
              - https://www.bilibili.com/video/BV1PJ411n7xZ?p=76&spm_id_from=pageDriver
              - 频繁在新生代区收集，很少在养老代区收集，几乎不再永久代/元空间收集
              - JVM进行GC时，并非每次都对这（新生代，老年代，方法区(永久代/元空间)）3个区域一起回收的，大部分时候回收的都是新生代
              - STW（stop the world）
                  触发GC以后，会导致用户线程暂停，GC线程执行垃圾回收
            GC回收区域划分为两种大类型（针对Hotspot的实现）:
              - 部分收集（Partial GC）不完全收集整个Java堆的垃圾收集
                  新生代收集（Minor GC / Young GC）只是新生代(伊甸园区，幸存者from区)的垃圾收集
                  老年代收集（Major GC / Old GC）只是老年代的收集收集
                    目前，只有CMS GC会有单独收集老年代的行为
                    注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收
                  混合收集（Mixed GC）收集整个新生代以及部分老年代的垃圾收集
                    目前,只有G1 GC会有这种行为
              - 整堆收集（Full GC）收集整个Java堆区(新生代收集和老年代收集)和方法区(永久代/元空间)的垃圾收集
            MinorGC:
              - 触发者条件是伊甸园区内存空间不足
              - MinorGC完全等价YoungGC
              - 收集区域:"对伊甸园区和幸存者from区进行垃圾收集"
              - 因为Java对象"大多数具备朝生夕死"的特性，所以MinorGC非常频繁，一般回收速度也比较快
              - MinorGC会引发STW，暂停用户线程，等待GC线程垃圾回收结束，用户线程才恢复运行
            MajorGC:
              - 触发者条件是老年代区内存空间不足
              - MajorGC完全等价OldGC
              - 收集区域:"对老年代区进行垃圾收集"
              - 出现了MajorGC，经常会伴随至少一次MinorGC,也就是说老年代空间不足时，会先尝试触发MinorGC,如果之后空间还不足，则触发MajorGC(但非绝对的，在Parallel Scavenge收集器的收集策略里就是直接进行MajorGC，而没有进行MinorGC)
              - MajorGC的速度一般会比MinorGC慢10倍以上，STW的时间会更长
              - 如果MajorGC后，内存还不足，就报OOM了
            FullGC:
              - 收集区域:"对新生代(伊甸园区，幸存者form区)，老年代，方法区(元空间/永久代)"
              - 触发FullGC的三种情况
              - 1.调用System.gc()时，系统建议执行FullGC，但是不必然执行
              - 2.老年代空间不足
                    通过MinorGC后进入老年代的平均大小大于老年代的可用内存
                    由伊甸园区，幸存者from区向幸存者to区复制时，对象大小大于幸存者to区可用内存，则把该对象转存到老年代，而且老年代的可用内存小于该对象大小
              - 3.方法区空间不足
          是否支持GC: 存在GC
          是否会出现异常:
            - 一旦堆区中的内存大小超过了"-Xmx"所指定的最大内存时，就会抛出OOM(OutOfMemoryError)异常
            - 当老年代空间不足会触发OOM
                  伊甸园区和幸存者区空间不足都会存到老年代区，所以堆区只有老年代会触发OOM
      3.本地方法栈(线程独享):
          功能:
            - 调用本地方法(native方法)
            - Java虚拟机用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用
            - 本地方法栈是线程私有的
            - 本地方法是使用C语言实现的
            - 它的具体做法是本地方法栈中登记了本地方法，在执行引擎执行时加载本地方法库
            - 当某个线程调用一个本地方法，它就进入了一个全新的并且不再受虚拟机限制的世界，它虚拟机拥有同样的权限
                本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区
                它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量内存
            - 并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言，具体实现方式，数据结构等。
            - 如果JVM产品不大算支持本地方法，也可以无需实现本地方法栈
            - 在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一
          是否支持GC: 不支持
          是否会出现异常:
            - 固定大小(jvm默认)/StackOverFlowError
                如果线程请求分配的栈容量超过本地方法栈允许的最大容量，StackOverFlowError异常
            - 动态扩展/OutOfMenoryError
                如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新
                的线程时没有足够的内存区创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMenoryError异常
      4.Java虚拟机栈(线程独享):
          功能:
            - 栈管运行，堆管存储
            - 每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个栈帧，每个栈帧对应一个方法的调用
            - Java虚拟机栈的声明周期和线程共存亡
            - Java虚拟机栈它保存方法的局部变量(8种基本数据类型，对象的引用地址)，以及线程运行中产生的部分结果，并且参与方法的调用和返回
            - Java虚拟机栈的操作只有2个
              出栈
              进栈
            - 调用非native方法
            - 1个栈帧包含(本地变量表,操作数栈,动态链接,方法返回地址,一些附加信息)
            - 1个栈帧对应源代码1个方法,1个方法的执行对应一个栈帧入栈，一个方法的结束对应一个栈帧的出栈
            - 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器
            - 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧(栈顶栈帧)是有效的，这个栈帧被称为当前栈帧，与当前真真相对应的方法就是当前当面，定这个方法的类就是当前类
            - 执行引擎运行的所有字节码指令只针对当前栈帧进行操作
            - 如果在该方法中调用了其他方法，对应的新的栈帧会创建出来，放在栈顶，成为新的当前栈帧
            - 不同线程中所包含的栈是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧
            - 如果当前党法调用了其他方法，方法返回之前，当前栈帧会传回此方法的执行结果给前一个栈帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧
            - Java方法(栈帧)有两种返回的方式，一种是正常方法返回(return),另一种事抛出异常返回(throw RuntimeException)，都会导致栈帧被弹出
          栈的存储单位: 栈帧(Stack Frame)
          栈帧:
            局部变量表/本地变量表:
              功能:
                - 局部变量表也被称为局部变量数组或本地变量表
                - 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据包括各类基本数据类型，对象引用，以及returnAddress类型
                - 由于局部变量表是在栈帧中，而栈帧又是在Java虚拟机栈中，所以局部变量表是线程的私有数据，因此不存在数据安全问题
                - 局部变量表中的变量只在当前栈帧(方法)中生效,在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。
                - 当栈帧(方法)调用结束后，随着栈帧的销毁，局部变量表也随之销毁
                - 参数值的存放总是在局部变量数组的Index0开始，到数组长度—1索引结束
                - 局部变量表的基本存储单位是Slot（变量槽）
                - 局部变量表中存放编译期可知的各种基本数据类型(8种)，引用类型(reference)，returnAddress类型变量
                - 类变量(静态变量)和局部变量对比
                  我们知道【类变量表】有两次初始化机会，第一次是在连接阶段->准备环节中赋默认值，第二次是在初始化阶段赋值(代码中写的值)
                  和类变量初始化不同的是，局部变量表不存在系统初始化过程，这意味着一旦定义了局部变量则必须认为初始化，否则无法使用
                  public void test5(){
                  int a;
                  System.out.println(a);//不能直接使用
                  }
                - 在栈帧与栈帧之间的调用时，虚拟机利用局部变量表来进行参数传递，也就是方法调用之前是否需要传参，方法结束的时候是否需要返回参数
                - 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或者间接引用的对象都不会被回收
              从字节码层面:
                局部变量表的大小:
                  - 局部变量表所需要的容量大小是在编译期间(javac)就确定下来的，在方法运行期间不会改变局部变量表的大小
                    方法 -> test -> Code -> 杂项 -> 局部变量最大槽数
                局部变量表的位置:
                  - 方法 -> test -> Code -> LocalVariableTable
                局部变量表的单位: 槽slot
                槽slot:
                  - 一个槽=4个字节=32位
                  - byte short float char boolean(0表示false,1表示true) 被转换为int
                  - int 引用类型 占1个槽
                  - long double 占2个槽
                  - JVM会为局部变量表中的每一个Slot都分配一个访问索引,通过这个索引即可成功访问到局部变量表中指定的局部变量值
                  - 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上
                  - 如果需要访问局部变量表中一个，只需要使用索引号(槽的索引)即可访问
                  - 如果当前栈帧是由构造方法或者实例方法创建的，那么该对象的引用this将会存放在Index为0的slot位置，其他的参数按照参数顺序继续排位
                    public Test(){
                    //this
                    }
                    public void test(){
                    //this
                    }
                  - 槽的重复利用
                    public void test5(){
                    int a = 10;
                    {
                    // int b = 10;
                    double c = 20;
                    }
                    int d = 20;
                    }
            操作数栈/表达式栈:
              功能:
                - 操作数栈底层是基于数组实现的，栈是先进后出
                - 操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据，或者提取数据
                - 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数栈的值取出，使用他们后再把结果压入栈。
                - 操作数栈主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间
                - 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个栈帧的操作数栈是一个空的数组
                - 我们说Java虚拟机的解析引擎是基于栈的执行引擎，其中指的就是操作数栈
              从字节码层面:
                操作数栈的大小:
                  - 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期(javac)就定义好了
                    方法 -> test -> Code -> 杂项 -> 操作数栈最大深度
                操作数栈的单位: 深度
                深度:
                  1个深度 = 4个字节=32位
            动态链接:
              功能:
                - 指向运行时常量池的方法引用
                - 每一个栈帧的内部都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。比如invokedynamic指令
                - 在Java源文件被编译到字节码文件中时，所有的变量和方法的符号引用都保存在class文件的常量池中。
                - 比如：描述一个方法调用了其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用
              从字节码层面:
                - Constant pool:
                  #1 = Methodref          #6.#17         // java/lang/Object."<init>":()V
                  #2 = Fieldref           #18.#19        // java/lang/System.out:Ljava/io/PrintStream;
                  #3 = String             #20            // 1
                  #4 = Methodref          #21.#22        // java/io/PrintStream.println:(Ljava/lang/String;)V
                - 0: getstatic     #2（静态解析）          // Field java/lang/System.out:Ljava/io/PrintStream;
                  3: ldc           #3                  // String 1
                  5: invokevirtual #4 (动态链接)          // Method java/io/PrintStream.println:(Ljava/lang/String;)V
                  8: return
            方法返回地址:
              功能:
                - 针对的是正常退出而言，存放调用该方法的pc寄存器的值
                - 本质上，方法的退出就是当前栈帧出栈的过程，此时需要恢复上层方法的局部变量表，操作数栈，将返回值压入调用者栈帧的操作数栈，设置PC寄存器值等，让调用者方法继续执行下去
              正常退出: 调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址
              异常退出:
                - 异常完成出口退出的不会给他的上层调用则产生任何的返回值
                - 在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是说只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出
          是否支持GC: 不支持
          是否会出现异常:
            - 固定大小(jvm默认)/StackOverFlowError
              如果采用固定大的Java虚拟机栈，那么每个线程的Java虚拟机栈容量可以在线程创建的时候独立选定，
              如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容易，则抛异常
            - 动态扩展/OutOfMenoryError
              如果采用动态扩展Java虚拟机栈，那么线程在尝试扩展的时候无法申请到足够的内存，或者在創建新的綫程
              时没有足够的内存去创建对应的虚拟机栈，则抛异常
          设置栈大小:
            - 默认Linux/macOS = 1024kb
            - 默认Windows = 没有明确说明
            - -Xss1m
            - -Xss1024k
            - -Xss1048576
      5.程序计数器(线程独享):
          功能:
            - 也叫PC寄存器(Program Counter Register)
            - 程序计数器用来存储指向下一条指令的地址，由执行殷勤读取下一条指令。
            - 它是一块很小的内存空间，几乎可以忽略不计，也是运行速度最快的存储区域
            - 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致
            - 程序计数器会存储当前线程正在执行的指令地址
                0 aload_0
                1 invokespecial #1 <java/lang/Object.<init> : ()V>
                4 return
                (0 1 4)就是指令地址
            - 如果是在执行native方法，则是未指定的值(undefined)
            - 它是程序空间流的指示器，如分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成
            - 执行引擎工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
            - 它是唯一一个在Java虚拟机规范中没有出现任何的OOM情况的区域
          是否支持GC: 不支持
          是否会出现异常: 不出现
  下层:
    执行引擎:
      功能:
        - 将字节码指令转换成机器指令,最后将机器指令给CPU运行
      解析器:
        功能: 利用程序计数器逐行解析字节码，将字节码解析成机器指令并且执行
      JIT即时编译器(JIT后端编译器):
        功能: 通过程序计数器寻找热点代码,将字节码编译成机器指令并且执行（缓存机器指令，放在方法区的CodeCache）
      垃圾回收器:
    本地方法:
      功能:
        - 被native修饰的方法叫本地方法
          public final native Class<?> getClass();
          public native int hashCode();
          public final native void notify();
      与Java环境外交互:
        - 有时候Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。
        - 你可以想象Java需要与一些底层系统，如操作系统或者硬件交换信息的时候，本地方法正是这样的一种交流机制，
        - 它为我们提供了一个非常简洁的就扣，而且我们无需去了解Havana应用之外的繁琐细节
      与操作系统交互:
        - JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解析字节码）和一些连接到本地代码的库组成。
        - 然而不管怎么样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统尝尝是强大的操作系统。
        - 通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的。
        - 还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法
      Sun`s Java:
        - Sun的解释器是用C实现的，这使得它能想一些普通的C一样与外部交互。
        - jre大部分是用Java实现的，它也通过一些本地方法与外界交互。
        - 例如:类java.lang.Thread的setPriority()方法是Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。
        - 这个方法就是用C实现的，并且植入JVM内部，在Windows 95的平台上，这个本地费最终将调用Win 32 SetPriority()API。
        - 这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库提供，然后被JVM调用
      本地方法接口:
        功能: 被本地方法栈调用
      本地方法库:
        功能: 被本地方法栈调用
