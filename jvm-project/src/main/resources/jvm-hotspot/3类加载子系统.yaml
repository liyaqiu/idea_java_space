类加载子系统:
  功能:
    - 在Java中，数据类型分为基本数据类型和引用数据类型。基本数据类型由虚拟机预选定义，引用数据类型则需要进行类的加载。
  类的生命周期: 加载->链接(校验、准备、解析)->初始化->使用->卸载
  1加载阶段:
    个人总结:
      - 将字节码文件二进制流数据加载到方法区，并且在堆空间生成类模版实例。
      - 类加载器只作用在加载阶段，后面的链接阶段以及初始化阶段是作用在JVM。
      - 打印当前JVM加载的所有类信息 -XX:+TraceClassLoading
    加载原理:
      - 所谓加载，就是将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型【类模版】
      - 所谓类模版对象，其实就是Java类在JVM内存中的一个快照，JVM将从字节码文件中解析出的常量池、类字段、类方法、类属性等信息，存储到类模版中
      - 这样JVM在运行期间便能通过类模版而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用。
      - 反射的机制就是基于这一基础，如果JVM没有将Java类的声明信息存储起来，则JVM在运行期间也无法反射。
    加载完成的操作:
      - 加载阶段，查找并加载类的二进制数据，生成Class的实例
      - "
        在加载类时，Java虚拟机必须完成以下3件事情:
          通过类的全名，获取类的二进制数据流。
          解析类的二进制数据流为方法区内的数据结构(类模版)
          并且在堆空间创建java.lang.Class类的实例(类模版实例)，表示该类型。作为方法区这个类的各种数据的访问入口
      "
    二进制流的获取方式:
      - 对于类的二进制数据流，虚拟机可以用过多重途径产生和获得，只要所读取的字节码二进制流数据符合JVM规范即可。
      - "
        最常见，虚拟机可能通过文件系统读入一个class后缀的文件
        读取jar，zip等归档数据包，提取类文件
        事先存放在数据库中的类的二进制数据
        使用类似HTTP之类的协议通过网络进行加载
        在运行时生成一段Class的二进制流数据等。
      "
      - 在获取到类的二进制流数据后，Java虚拟机就会处理这些数据，并最终转为一个java.lang.Class的实例。
      - 如果输入的二进制流数据不符合类文件结构，则会抛出ClassFormatError异常。
    类模版的位置:
      - 加载的类在JVM中创建相应的类结构，类结构会存储在方法区(JDK1.7及以前永久代，JDK1.8及以后元空间)
    类模版实例的位置:
      - class文件加载到方法区后，会在堆中创建一个类模版本实例，用来封装类位于方法区内的数据结构，该类模版实例是在加载类的过程中创建的，每个类模版都对应一个类模版实例。
      - 类模版实例是访问类模版的元数据的接口，也是实线反射的关键数据。入口。
      - 通过类模版实例接口，可以获得类模版所关联的方法、字段等信息。
    数组类的加载:
      - 创建数组类的情况稍微有些特殊，因为数组类本身并不是由类加载负责创建的，而是由JVM在运行时根据需要在创建的。但是数组的类型仍然需要依靠类加载器去创建。
      - "
        创建数组的过程
          int[] a = new int[2];
          String[] str = new String[2];
          如果数组的类型是引用类型，那么就跟将引用类型按照类加载子系统的过程进行加载。
          如果数组的类型是基本类型，则不需要加载。
      "
    类加载器:
      功能:
        - 类加载器是JVM执行类加载机制的前提
        - 类加载器是Java的核心组件，所有的字节码文件都是由类加载器进行加载的。
        - 类加载器负责通过各种方式将字节码二进制数据流读入JVM内部，在方法区生成一个类模版，并且在堆空间生成一个类模版实例(指针指向类模版)，然后将该类模版实例交给JVM进行链接和初始化等操作。
        - 因此，类加载器只能作用在加载阶段，而链接阶段和初始化阶段与类加载器无关。至于它是否可以运行，则由执行引擎决定。
        - 类加载器涉及到的异常有 ClassNotFoundExecption和NoClassDefFoundError
        - 类加载器除了顶层的启动类加载器外，其余的类加载器都应当有自动的"父类"加载器，这个父类不同于Java的继承关系的父类，而是一种包含关系，在下层加载器中，包含上层加载器的引用。
        - 不同的类加载器加载同一份字节码的时候，虽然全类名同样，但是他们属于不同的类模版实例，并且他们之间也不能相互转换和兼容。
      类加载器的显式加载和隐式加载:
        功能:
          - 所谓的隐式加载是指不用用户自己操作类加载器进行加载。而显示加载需要用户通过类加载器进行加载。
        显式加载:
          - Class.forName('com.Hello')
          - new Hello().getClass().getClassLoader().loadClass("com.Hello")
        隐式加载:
          - new方式
          - clone方式
          - 反序列化方式
      类的唯一性:
        - 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在JVM中的唯一性。
        - 每一个类加载器都拥有一个独立的类名称空间，比较两个类模版实例是否相等，只有在这两个类模版实例是由同一个类加载器的前提下才有意义。
        - 否则，即使这两个类源自同一个Class文件，被同一个JVM加载，只要加载它们的类加载器不同，那这两个类模版实例就必定不相等。
      类的命名空间:
        - 每个类加载器都有自己的命名空间。
        - 在同一命名空间中，不可以出现全类名相同的两个类。
        - 在不同的命名空间中，可以出现全类名相同的两个类。(前提没有双亲委派机制约束下)
      类加载器的3个基本特征:
        - "
          双亲委派机制，但不是所有类加载器都遵守这个机制，有的时候，启动类加载器所加载的类型，可能是要加载用户代码的，比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现。
          JDK也需要提供些默认的参考实现，比如Java中的JNDI，JDBC，文件系统，Cipher等很多方面，都是利用上下文加载器加载，而不会使用双亲委派机制加载。
        "
        - 可见性，子类加载器可以访问父类加载器的类型，但是父类加载器不能访问子类加载器的类型，不然，因为缺少必要的隔离，我们就没办法利用类加载器去实现容器的逻辑。
        - 单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，久不会在子加载器中重复加载。但是注意，类加载器邻居间，同一类型仍然可以被加载多次，因为互相并不可见。
      类加载器分类:
        引导类加载器:
          引导类加载器(Bootstrap Class Loader)（C/C++语言实现）:
            功能:
              - 它使用C/C++语言实现的，嵌套在JVM内部,它用来加载Java核心类库，用于提供JVM自身需要的类
              - 负责加载【扩展类加载器】和【系统类加载器】，并且成为他们的父类加载器
              - 出于安装考虑，Bootstrap引导类加载器只加载了包名为java，javax，sun等开头的类
            加载位置:
              - D:/jdk1.8.0_121/jre/lib/
              - D:/jdk1.8.0_121/jre/lib/resources.jar
                D:/jdk1.8.0_121/jre/lib/rt.jar
                D:/jdk1.8.0_121/jre/lib/sunrsasign.jar
                D:/jdk1.8.0_121/jre/lib/jsse.jar
                D:/jdk1.8.0_121/jre/lib/jce.jar
                D:/jdk1.8.0_121/jre/lib/charsets.jar
                D:/jdk1.8.0_121/jre/lib/jfr.jar
            通过系统属性查看: System.getProperty("sun.boot.class.path")
            是否继承java.lang.ClassLoader: 不继承
            父类加载器: 没有
        自定义类加载器(sun.misc.Launcher作为入口类):
          扩展类加载器(Extension Class Loader)（Java语言实现）:
            功能:
              - Java语言编写，sun.misc.Launcher$ExtClassLoader@4f023edb
              - 它是程序中默认的类加载器，一般情况下用户写的类都是由它来加载
            加载位置:
              - D:\jdk1.8.0_121\jre\lib\ext\;
              - D:\jdk1.8.0_121\jre\lib\ext\access-bridge-64.jar
                D:\jdk1.8.0_121\jre\lib\ext\cldrdata.jar
                D:\jdk1.8.0_121\jre\lib\ext\dnsns.jar
                D:\jdk1.8.0_121\jre\lib\ext\jaccess.jar
                D:\jdk1.8.0_121\jre\lib\ext\jfxrt.jar
                D:\jdk1.8.0_121\jre\lib\ext\localedata.jar
                D:\jdk1.8.0_121\jre\lib\ext\meta-index
                D:\jdk1.8.0_121\jre\lib\ext\nashorn.jar
                D:\jdk1.8.0_121\jre\lib\ext\sunec.jar
                D:\jdk1.8.0_121\jre\lib\ext\sunjce_provider.jar
                D:\jdk1.8.0_121\jre\lib\ext\sunmscapi.jar
                D:\jdk1.8.0_121\jre\lib\ext\sunpkcs11.jar
                D:\jdk1.8.0_121\jre\lib\ext\zipfs.jar
              - C:\Windows\Sun\Java\lib\ext\
              - 如果用户创建了xxx.jar放在jre/lib/ext目录下，也会被扩展类加载器加载
            通过系统属性查看: System.getProperty("java.ext.dirs")
            是否继承java.lang.ClassLoader: 继承
            父类加载器: 引导类加载器
          系统类加载器(Application Class Loader)（Java语言实现）:
            功能: Java语言编写，sun.misc.Launcher$AppClassLoader@18b4aac2
            加载位置:
              - 由-classpath指定
              - java -classpath xx1.jar;xx2.jar com.test.Test
            通过系统属性查看: System.getProperty("java.class.path")
            是否继承java.lang.ClassLoader: 继承
            父类加载器: 扩展类加载器
          自定义类加载器(Custom Class Loader)（Java语言实现）:
            功能:
              - 实现同一个class文件不同加载器加载
              - 实现动态加载类
              - 可以对class做加密处理
            加载位置:
              - 可以通过网络
              - 可以通过磁盤
            是否继承java.lang.ClassLoader: 继承
            父类加载器: 系統类加载器
      双亲委派机制:
        功能:
          - loadClass() -> findClass() -> defineClass()
          - loadClass()方法实现了双亲委派机制，loadClass()调用了findClass()，而findClass()又调用了defineClass()
          - 直接实现defineClass()可以实现破双亲委派机制操作。
          - 类加载器用来把类加载到JVM中，从JDK1.2版本开始，类在加载环节中使用了双亲委派机制，这种机制能有效的保护了Java平台的安全。
          - 如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，则成功返回，只有父类加载器无法完成此加载任务时，才给子类加载器去加载。
        详细过程:
          - 当程序需要加载类时，先由系统类加载器进行加载，系统类加载器首先会判断是否加载过，如果有加载过，则直接返回。
          - 如果没加载过，则交由扩展类加载器去加载，扩展类加载器也会判断是否已经加载过，如果有加载过，则直接返回。
          - 如果没有加载过，则交由引导类加载去加载，引导类加载器也会判断是否已经加载过，如果有加载过，则直接返回。
          - 如果引导类加载器也没加载过，则引导类加载器会判断是否属于自己加载的，如果属于，则加载后直接返回。
          - 如果不属于，则返回给扩展类加载器，扩展类加载器会判断是否属于自己加载的，如果属于，则加载后直接返回。
          - 如果不属于，则返回给系统类加载器，系统类加载器会判断是否属于自己加载的，如果属于，则加载后直接返回。
          - 如果不属于，则抛异常。
        当破坏了双亲委派机制的时候能否篡改核心API?:
          - 不可以的，不管使用还是不使用双亲委派机制的loadClass()方法，最终还是需要通过defineClass()来进行类加载，所以在defineClass()方法中的preDefineClass()方法会进行校验，保护了核心API的篡改。
        优点:
          - 避免类的重复加载，确保一个类在全局JVM中只有一份。
          - Java类虽则它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关系可以避免重复加载，当父类加载器已经加载了，子类加载器就没有必要重新在此加载。
          - 节省了内存空间。
          - 保护程序的安全性，防止核心API被随意篡改。
        缺点:
          - 检查类是否加载的委托过程是单向的，这个方式虽然从结构上比较清晰，使各个类加载器的职责非常明确，但是同时会带来一个问题，父类加载器无法访问子类加载所加载的类。
      打破坏双亲委派机制:
        - 重写ClassLoader的findClass()方法
        - "
          使用OSGI框架，实现热部署，热替换
            IMB公司主导的JSR-291(即OSGI R4.2)实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块都有一个自己的类加载器(SOGI中称为Bundle)，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉，以实现代码的热替换。
            在OSGI环境下，类加载不在使用双亲委派机制推荐的树状结构，而是进一步发展为更加复杂的网状结构。
            当收到类加载器请求时，OSGI将按照以下顺序进行类搜索和加载。
            1.将以java.*开头的类，委派给父类加载器加载。
            2.否则，将委派列表名单内的类，委派给父类加载器加载。
            3.否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。
            4.否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。
            5.否则，查找是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。
            6.否则，查找Dynamic Import列表的Bundle，委派给对应的Bundle的类加载器加载。
            7.否则，类查找失败。
            说明:只有开有亮点仍然符合双亲委派机制，其余的类查找都是在平级的类加载器中进行的。
            小结:这里，我们使用了【被破坏】这个词来形容上述不符合双亲委派机制的行为，但这里的【被破坏】并不一定是带有贬义的，只要有明确的目的和充分的理由，突破旧有的原则无疑是一种创新。
        "
      沙箱安装机制:
        功能:
          - 保证程序安全，保护Java原生的JDK代码
          - Java把安全模型的核心就是Java沙箱。什么是沙箱？沙箱是一个限制程序运行的环境。
          - 沙箱机制就是将Java代码限定在JVM特定的运行范围中，并且严格限制代码对本地系统资源访问。通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。
          - 沙箱主要限制系统资源访问，那系统资源包括(CPU、内存。文件系统。网络)，不同级别的沙箱对这些资源的访问权限的可以不一样。
          - 所有的Java程序运行都可以指定沙箱，可以定制安全策略。
        JDK1.0时期:
          - 在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信任的。
          - 对于受信任的本地代码，可以党文一切本地资源。而不受信任的远程代码需要运行在沙箱环境中进行隔离运行。
        JDK1.1时期:
          - JDK1.0中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时，就无法实现。
          - 因此在后续的Java1.1版本中，针对安全机制做了改进，增加了安全策略。允许用户指定远程代码对本地资源的访问权限。
        JDK1.2时期:
          - 在JDK1.2版本中，在次进行改进安全机制，增加了代码签名。
          - 不论本地代码或者是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。
        JDK1.6时期:
          - 当前最新的安全机制实现，则引入了域(Domain)的概念
          - 虚拟机会吧所有代码加载到不同的系统域和应用域。
          - 系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。
          - 虚拟机中不同的受保护域，对应不一样的权限。存在不同于中的类文件就具有的当前与的全部权限。
      自定义类加载器好处:
        隔离加载类:
          - 在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。
          - 比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。
          - 比如：Tomcat这类Web应用服务器，内部自定义了好几种类加载器，用于隔离同一个Web应用服务器上的不同应用程序。
        修改类加载的方式:
          - 类的加载模型并非强制，除Bootstrap外，其它的加载器并非一定要引入，或者根据实际情况在某个时间点按需进行动态加载。
        扩展加载源:
          - 比如从数据库、网络、甚至是电视机机顶盒进行加载。
        防止源代码泄漏:
          - 姐啊把代码容易被反编译和篡改，可以进行编译加密。那么类加载也需要自定义还原加密的字节码。
        常见场景:
          - 实现类似进程内隔离，类加载器实际上用做不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是JavaEE、OSGI、JPMS等框架。
          - 应用需要从不同是数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自动操作字节码，动态修改或者生成类型(符合JVM规范的二进制数据)。
  2链接阶段:
    校验环节:
      功能:
        - 验证环节主要就是保证加载的字节码合法、合理并符合JVM规范。
        - 格式校验会和加载阶段一起执行，验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。
        - 语义校验、字节码校验、符号引用校验将会在方法区中进行校验。
      格式校验:
        - 是否以0xCAFEBABE开头，主版本和次版本是否在当前Java虚拟机的支持范围内，数据中每个项是否拥有正确的长度。
      语义校验:
        - 是否所有的类都有父类(除Object)
        - 被定义为final的方法或者类，是否有被别的类进行重写或者继承等错误操作。
        - 某个类实现了接口或者继承了抽象类，是否有实现了抽象方法。
        - 类里面的方法重写是否遵从Java规范。
      字节码校验:
        - 在字节的执行过程中，是否会挑战到一条不存在的指令。
        - 函数的调用是否传递了正确类型的参数。
        - 变量的复制是不是给了正确的数据类型等。
        - 栈映射帧(StackMapTable)就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确是数据类型。
      符号引用校验:
        - Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。所以JVM会检查这些符号引用对应的方法和类是否存在。
        - 此校验需要到解析环节才会执行
    准备环节:
      功能:
        - 准备环节不会为实例变量分配内存，类变量类常量会分配在方法区中，而实例变量和实例常量会随着对象一起分配到Java堆中。
        - 如果该类变量或类常量没有在clinit方法中进行赋值，那么就是在链接阶段的准备环节进行了赋值了。
        - "
          为类变量分配内存，并且赋默认值
            原始代码 static String str = 'hello';                     准备环节 static String str = null;
            原始代码 static int i = 100;                              准备环节 static int i = 0;
            原始代码 static String str = new String('hello');         准备环节 static String str = null;
        "
        - "
          为类常量(基本数据类型，String类型,通过字面量方式赋值)分配内存，并且赋值
            原始代码 final static int i = 100;        准备环节 final static int i = 100
            原始代码 final static String str = '123'; 准备环节 final static String str = '123'
        "
    解析环节:
      功能:
        - 将类，接口，字段和方法的符号引用转换为直接引用。
        - 符号引用就是一些字面量引用，和虚拟机的内部数据结构和内存布局无关。
        - 比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用，但是在程序实际运行时，只有符号引用是不够的，当xxx()方法被调用时，需要明确知道改方法的内存地址。
        - 以方法调用为例，JVM为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法时，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。通过解析操作，符号引用就可以转化为目标方法在类中方法表中的位置，从而使得方法被成功调用。
        - 所谓的解析环节就是将符号引用转化为直接引用，也就是得到类、字段、方法在内存中的指针或者偏移量。因此，如果直接引用存在，那么久肯定系统中存在该类、方法或者字段。如果只存在符号引用，就不能确定JVM中一定存在该结构。
      执行顺序:
        - 在Java虚拟机规范并没有明确要求解析环节一定要按照顺序执行。在hotspot中，解析环节往往会在JVM执行完初始化之后在执行。
  3初始化阶段:
    功能:
      - 为类变量和类常量赋值
      - 初始化阶段的重要工作就是执行类的clinit()方法。
      - clinit()方法是由类变量，类常量的赋值语句以及静态代码块合并产生的。
      - 在加载一个类的时候，JVM总数会试图加载该类的父类，因为父类的clinit方法总是在子类的clinit方法之前执行。
      - "
          执行clinit方法，为类变量或者类常量，并且赋值
            原始代码 static String str = 'hello';                     初始化阶段 static String str = 'hello';
            原始代码 static int i = 100;                              初始化阶段 static int i = 100;
            原始代码 static String str = new String('hello');         初始化阶段 static String str = new String('hello');
            原始代码 final static Integer i = new Integer(100);       初始化阶段 final static Integer i = new Integer(100);
            原始代码 final static Integer i = 100;                    初始化阶段 final static Integer i = 100;
            原始代码 final static String str = new String('hello');   初始化阶段 final static String str = new String('hello');
      "
    clinit方法线程安全:
      - 对于clinit方法的调用，也就是类的初始化，JVM会在内部确保其多线程环境中的安全性。
      - JVM会保证一个类的clinit方法在多线程环境中被正确的加锁，同步，如果多个线程同时去初始化一个类，那么只会有一个线程区执行这个类的clinit方法，其他线程都需要阻塞等待。
      - 正是因为clinit是一个同步方法，因此，如果一个类的clinit方法中有耗时很长的操作，就可能造成多个线程阻塞，或者引发死锁问题。
      - clinit方法从字节码角度看，是看不到同步标识的，JVM在运行期间隐式去上锁的。
      - clinit方法只允许执行一次。如果之前的线程成功加载了类，则等在队列中的线程就没机会在此执行clinit方法了。那么，当需要使用这个类的时候， JVM就会直接返回给它已经准备好的信息。
    类的主动与被动使用:
      功能:
        - 类的主动使用会调用clinit()方法，类的被动使用不会调用clinit()方法。
      主动场景:
        - new对象方式(非数组)、反序列化方式、反射方式、克隆方式
        - 调用类的静态的方法
        - 调用类的(普通类，抽象类，接口类)类变量或者类常量(除开基本数据类型，String类型,通过字面量方式赋值)
        - 当初始化子类时，如果父类还没进行初始化，则需要先触发父类的初始化。
              如果初始化子类，该子类实现的接口并不会初始化。
                如果该接口定义了default方法，那么会初始化。
              如果初始化接口，它的父接口也不会初始化。
        - 当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法)，虚拟机会先初始化这个类
        - 当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。(涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类)
      被动场景:
        - 通过数组定义类引用，不会触发此类的初始化(new数组方式)
        - 子类调用父类的类变量时候，子类不会初始化
        - 如果初始化子类，该子类实现的接口并不会初始化。
        - 如果初始化接口，它的父接口也不会初始化。
        - 调用该类的类常量(基本数据类型，String类型,通过字面量方式赋值)时候，不会初始化该类
        - 调用ClassLoader类的loadClass()方法加载一个类。
  4类使用:
    - "
      获得类模版实例
        Class.forName('com.Hello')
        Hello.class
        new Hello().getClass()
    "
    - "
      通过类模版实例new对象4种方式
        Class.forName('com.Hello').newInstance() 显示加载类模版实例，在new对象
        Hello.class.newInstance(); 显示加载类模版实例，在new对象
        new Hello().getClass().newInstance() 显示加载类模版实例，在new对象
        new com.Hello()，隐式加载类模版实例，在new对象
    "
  5类卸载:
    - 类卸载一般指的是方法区的类模版卸载
    - "
      类模版的卸载需要把类模版实例卸载
          类模版实例卸载
            类模版实例的变量断开
            类模版实例new出来的对象实例断开
                new出来的对象实例需要把变量断开
            类模版实例类加载器断开
                类加载器需要把变量断开
                类加载器关联

    "
