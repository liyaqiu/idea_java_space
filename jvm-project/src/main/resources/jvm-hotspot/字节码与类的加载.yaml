字节码概述:
  字节码文件的生成:
    - 想要让一个Java程序正确的运行在JVM中，Java源码就必须要被编译为复合的JVM规范的字节码。
    - 前端编译器主要任务就是负责将复合Java语言规范的Java代码转换为复合JVM规范的字节码文件。
    - javac是一个能够将Java源代码编译为字节码的前端编译器。
    - Javac编译器在将Java源码编译为一个有效的字节码文件过程中经历了4个步骤，分别是词法解析，语法解析，语义解析，生成字节码。
  前端编译器:
    - javac，全量式前端编译器
    - idea默认用javac，全量式前端编译器
    - eclipse默认用ECJ，增量式前端编译器
  透过字节码指令看代码细节:
    - "
    int x = 128;
    Integer y = 128;
      装箱 Integer.valueOf(new Integer(128))
      拆箱 Integer.intValue(128)
    基本数据类型和引用数据类型不能作比较
    System.out.println(x==y);
    "
  字节码文件里面是什么?: 源代码经过前端编译器(javac)编译之后便会生成一个字节码文件，字节码是一种二进制文件，它的内容是JVM的指令，而不像C，C++经由编译器直接生成机器码。

字节码文件:
  字节码指令:
    - Java虚拟机的指令由一个字节长度的，代表着某种特定的操作含义的操作码，以及跟随其后的0个或多个代表此操作所需的参数的操作数所构成。
    - 特殊指令 = 操作码(astore_0)
    - 普通指令 = 操作码+操作数(astore 5)
  字节码本质:
    - 任何一个Class文件都对应着唯一一个类或接口的定义信息。
    - 字节码文件中存放着二进制流，单位为(byte)
    - 字节码可以以磁盘形式存储，也可以通过网络进行传输
  字节码格式:
    - Class的结构不像XML等描述语言，由于它没有任何分隔符号。所以在其中的数据项，无论是字节顺序还是数量，都被严格限定的，哪个字节代表什么含义，长度是什么，先后顺序如何，都不允许被改变。
    - Class文件格式采用一种类似于C语言结构体的方式进行数据存储，这种结构只有两种数据类型，无符号数和表。
        无符号数
          无符号数属于基本的数据类型，以u1,u2,u4,u8来分别代表1字节，2字节，4字节，8字节的无符号数
          无符号数可以用来描述数字，索引引用，数量值或者按照UTF-8编码构成字符串值
        表
          表是由多个无符号数或者其它表作为数据项构成的复合数据类型，所以表都习惯性的以【_info】结尾。
          表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。
          由于表没有固定长度，所以通常会在其前面加上个数说明
  字节码文件结构:
    功能:
      - Class文件的结构并不是一成不变的，随着Java虚拟机的不断发展，总是不可避免的会对Class文件结构做出一些调整(增加字节码指令)，但是基本结构和框架是非常稳定的。
    官方结构:
      - "
      ClassFile {
          u4             magic;
          u2             minor_version;
          u2             major_version;
          u2             constant_pool_count;
          cp_info        constant_pool[constant_pool_count-1];
          u2             access_flags;
          u2             this_class;
          u2             super_class;
          u2             interfaces_count;
          u2             interfaces[interfaces_count];
          u2             fields_count;
          field_info     fields[fields_count];
          u2             methods_count;
          method_info    methods[methods_count];
          u2             attributes_count;
          attribute_info attributes[attributes_count];
      }
      "
    魔术:
      - "u4 magic;"
      - 每个Class文件开头的4个字节的无符号整数成为魔术
      - 它的唯一最庸是确定这个文件是否为一个能背虚拟机接受的合法Class文件。
      - 魔术的固定值为0xCAFEBABE，不会改变
      - 如果一个Class文件不以0xCAFEBABE开头，虚拟机在进行文件校验的时候就会抛异常
      - 使用魔术而不是扩展名进行识别主要是机遇安全方面考虑，因为文件扩展名可以随时更改。
    版本:
      功能:
        - 主版本和次版本功能构成了class文件的版本号。例如jdk8(对应的是52.0，52代表主版本，0代表次版本)
        - Java的主版本号是从45开始。
        - 不同版本的Java编译器编译的Class文件对应的版本是不一样的。目前，高版本的Java虚拟机可以执行由低版本编译器生成的Class文件。
        - 低版本的Java虚拟机不能运行高版本编译器生成的Class文件，否则JVM会抛异常(UnsupportedClassVersionError)
      次要版本: "u2 minor_version;"
      主要版本: "u2 major_version;"
    常量池:
      常量池计数器:
        - "u2 constant_pool_count;"
        - 由于常量池的数据项不固定，所以需要放置2个字节来表示常量池数据项的个数。
        - 常量池计数器的值从1开始，表示常量池中有多少项常量。
        - 即constant_pool_count = 13，表示常量池中真实只存在12项数据(2-13)。第1项是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达，【不引用任何一个常量池项】的含义。
      常量池表:
        功能:
          - "cp_info constant_pool[constant_pool_count-1];"
          - 常量池是Class文件中内存最丰富的区域之一。
          - 常量池对于Class文件中的字段和方法解析也有着重要的作用。
          - 随着Java虚拟机的不断发展，常量池的内容也逐渐丰富。可以说，常量池是整个Class文件的基石。
          - 常量池中的每个数据项，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。
          - 常量池主要存放两大类常量，【字面量】和【符号引用】。
          - 它包含了Class文件结构及子结构中引用的虽有字符串常量，类，接口名，字段名和其他常量。
          - 常量池中的每一项都具备相同的特征，第一个字节作为类型标记，用于确定该项的格式。
          - "
                常量	                      标志              描述
            CONSTANT_Class	               7            类或接口的符号引用
            CONSTANT_Fieldref	           9            字段的符号引用
            CONSTANT_Methodref	           10           类中方法的符号引用
            CONSTANT_InterfaceMethodref	   11           接口中方法的符号引用
            CONSTANT_String	               8            字符串类型字面量
            CONSTANT_Integer	           3            整形字面量
            CONSTANT_Float	               4            浮点型字面量
            CONSTANT_Long	               5            长整型字面量
            CONSTANT_Double	               6            双精度浮点型字面量
            CONSTANT_NameAndType	       12           字段或方法的符号引用
            CONSTANT_Utf8	               1            UTF-8编码的字符串
            CONSTANT_MethodHandle	       15           表示方法句柄
            CONSTANT_MethodType	           16           标识方法类型
            CONSTANT_InvokeDynamic	       18           表示一个动态方法调用点
          "
          - 虚拟机在加载Class文件时才会进行动态链接，也就是说，Class文件中不会保存各个方法和字段的最终内存布局信息，因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。
          - 当虚拟机运行时，需要从常量池获得对应的符号引用，在类加载过程中【链接阶段中的解析环节】将其替换为直接引用，并翻译到具体内存地址中。
          - 这里说明下符号引用和直接引用的区别与关联
              符号引用
                符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能具体定位到目标即可。
                符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。
              直接引用
                直接引用可以是直接指向目标的指针，相对偏移量或是一个能简介定位目标的句柄。
                直接引用是与虚拟机实现的内存布局相关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。
                如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。
        字面量:
          - 变量的值
          - String a = "hello" 字面量为hello
          - final String a = "hello" 字面量为hello
          - final static int a = 100 字面量为100
          - final static int a = 1000 字面量为1000
        符号引用:
          功能:
            - 类和接口的全限定名
            - 字段的名称和描述符
            - 方法的名称和描述符
          全限定名: com/zms/Test 这个就是类的全限定名，仅仅把包名的点"."换成斜杠"/"，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个";"表示全限定名的结束
          描述符:
            - 描述符的作用是用来描述字段的数据类型，方法的参数列表(包括数量，类型，顺序)和返回值。
            - 根据描述符规则
            - "
              B 基本数据类型byte
              C 基本数据类型char
              D 基本数据类型double
              F 基本数据类型float
              I 基本数据类型int
              J 基本数据类型long
              S 基本数据类型short
              Z 基本数据类型boolean
              V 无返回值类型 void
              L 引用类型 String,Object
              [ 数据类型，多为数组用 [，[[，[[[
            "
    访问标识: "u2 access_flags"
    当前类: "u2 this_class;"
    父类: "u2 super_class;"
    接口数组: "
      u2 interfaces_count;
      u2 interfaces[interfaces_count];
    "
    字段数组: "
      u2 fields_count;
      field_info fields[fields_count];
    "
    方法数组: "
      u2 methods_count;
      method_info methods[methods_count];
    "
    属性数组: "
      u2 attributes_count;
      attribute_info attributes[attributes_count];
    "
使用javap命令解析Class文件:
  javap的用法:
  使用举例:
  总结: