官方文档: https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-6.html#jvms-6.5.astore_n
字节码指令格式:
  - Java字节码对于虚拟机，就好像汇编语言对于计算机，属于基本执行指令。
  - Java虚拟机的指令，由一个字节长度的代表着某种特定操作含义的数字(称为操作码)，以及跟随其后的0个或多个代表此操作所需的参数(称为操作数)而构成。
  - 由于限制了Java虚拟机操作码的长度为1个字节(0-255)，这意味这jvm指令集的操作码总数不能超过256个。
  - Java虚拟机的指令由一个字节长度的，代表着某种特定的操作含义的操作码，以及跟随其后的0个或多个代表此操作所需的参数的操作数所构成。
  - 特殊指令 = 操作码(1字节)(astore_0)
  - 普通指令 = 操作码(1字节)+操作数(2个字节)(astore 5)
  - 从不同维度看指令 astore_0 = 75 (0x4b)
        从操作码层面看 astore_0
        从字节码10进制看 75
        从字节码十六进制层面看 0x4b
执行引擎执行字节码的伪代码: "
    do{
        程序计数器+1;
        根据程序计数器的位置，从字节码流中取出操作码;
        if(字节码存在操作数)从字节码流中取出操作数;
        执行操作码所定义的操作;
    }while(字节码长度>0);
  "
实际类型于操作码类型转换关系:
  - boolean byte char short = int
  - int = int
  - float = float
  - long = long
  - double = double
操作码:
  入栈与出栈操作码:
    局部变量表入栈:
      - iload 4 将局部变量表中索引为4的int型的值压入操作数栈
      - lload 4 将局部变量表中索引为4的long型的值压入操作数栈
      - fload 4 将局部变量表中索引为4的float型的值压入操作数栈
      - dload 4 将局部变量表中索引为4的double型的值压入操作数栈
      - aload 4 将局部变量表中索引为4的引用类型的值压入操作数栈
      - xload_0,xload_1,xload_2,xload_3
    常量入栈:
      const:
        - iconst_m1 将int型常量-1压入操作数栈
        - iconst_0 将int型常量0压入操作数栈
        - iconst_1 将int型常量1压入操作数栈
        - iconst_2 将int型常量2压入操作数栈
        - iconst_3 将int型常量3压入操作数栈
        - iconst_4 将int型常量4压入操作数栈
        - iconst_5 将int型常量5压入操作数栈
        - lconst_0 将long型常量0压入操作数栈
        - lconst_1 将long整型常量1压入操作数栈
        - fconst_0 将float型常量0压入操作数栈
        - fconst_1 将float型常量1压入操作数栈
        - fconst_2 将float型常量2压入操作数栈
        - dconst_0 将double型常量0压入操作数栈
        - dconst_1 将double型常量1压入操作数栈
        - aconst_null 将引用类型常量null压入操作数栈
      push:
        - bipush (-128~127) 将int型-128~127常量压入操作数栈
        - sipush (-32768~32767) 将int型-32768~32767常量压入操作数栈
      ldc(从运行时常量池压栈):
        - ldc/ldc_w int(>32768) 将int型32768常量压入操作数栈
        - ldc/ldc_w float 将float型的值常量压入操作数栈
        - ldc/ldc_w String 将引用类型的值常量压入操作数栈
        - ldc/ldc_w，当常量池索引≤256的时候用ldc(1字节索引)，当常量池索引>256的时候用ldc_w(2字节索引)
        - ldc2_w long 将long型的值常量压入操作数栈
        - ldc2_w double 将double型的值常量压入操作数栈
    出栈到局部变量表:
      - istore 4 将操作数栈的栈顶int型的值弹出，并存储到局部变量表索引为4的位置
      - lstore 4 将操作数栈的栈顶long型的值弹出，并存储到局部变量表索引为4的位置
      - fstore 4 将操作数栈的栈顶float型的值弹出，并存储到局部变量表索引为4的位置
      - dstore 4 将操作数栈的栈顶double型的值弹出，并存储到局部变量表索引为4的位置
      - astore 4 将操作数栈的栈顶引用类型的值弹出，并存储到局部变量表索引为4的位置
      - xstore_0,xstore_1,xstore_2,xstore_3
  算术操作码:
    加法(add):
      - iadd 将操作数栈中的2个int型数据弹出，进行相加，将结果压回栈
      - fadd 将操作数栈中的2个float型数据弹出，进行相加，将结果压回栈
      - ladd 将操作数栈中的2个long型数据弹出，进行相加，将结果压回栈
      - dadd 将操作数栈中的2个double型数据弹出，进行相加，将结果压回栈
    减法(subtract):
      - isub 将操作数栈中的2个int型数据弹出，进行相减，将结果压回栈
      - fsub 将操作数栈中的2个float型数据弹出，进行相减，将结果压回栈
      - lsub 将操作数栈中的2个long型数据弹出，进行相减，将结果压回栈
      - dsub 将操作数栈中的2个double型数据弹出，进行相减，将结果压回栈
    乘法(multiply):
      - imul 将操作数栈中的2个int型数据弹出，进行相乘，将结果压回栈
      - fmul 将操作数栈中的2个float型数据弹出，进行相乘，将结果压回栈
      - lmul 将操作数栈中的2个long型数据弹出，进行相乘，将结果压回栈
      - dmul 将操作数栈中的2个double型数据弹出，进行相乘，将结果压回栈
    除法(divide):
      - idiv 将操作数栈中的2个int型数据弹出，进行相除，将结果压回栈
      - fdiv 将操作数栈中的2个float型数据弹出，进行相除，将结果压回栈
      - ldiv 将操作数栈中的2个long型数据弹出，进行相除，将结果压回栈
      - ddiv 将操作数栈中的2个double型数据弹出，进行相除，将结果压回栈
    取余(remainder):
      - irem 将操作数栈中的2个int型数据弹出，进行取余，将结果压回栈
      - frem 将操作数栈中的2个float型数据弹出，进行取余，将结果压回栈
      - lrem 将操作数栈中的2个long型数据弹出，进行取余，将结果压回栈
      - drem 将操作数栈中的2个double型数据弹出，进行取余，将结果压回栈
    取反(negation):
      - ineg 将操作数栈中的1个int型数据弹出，进行取反，将结果压回栈
      - fneg 将操作数栈中的1个float型数据弹出，进行取反，将结果压回栈
      - lneg 将操作数栈中的1个long型数据弹出，进行取反，将结果压回栈
      - dneg 将操作数栈中的1个double型数据弹出，进行取反，将结果压回栈
      - int i = -100; int b = -i;
    自增(increment):
      - iinc 将局部变量表第n个索引的数值加1
      - int i = 10; i++; 只有这个才使用 iinc
      - float i = 10; i++; 这个不使用
    位移:
      - ishl
      - ishr
      - iushr
      - lshl
      - lshr
      - lushr
    位或:
      - ior
      - lor
    位与:
      - iand 将操作数栈中的2个int型数据弹出，进行位与，将结果压回栈
      - land 将操作数栈中的2个long型数据弹出，进行位与，将结果压回栈
    位异或:
      - ixor 将操作数栈中的2个int型数据弹出，进行位异或，将结果压回栈
      - lxor 将操作数栈中的2个log型数据弹出，进行位异或，将结果压回栈
  类型转换操作码:
    基本数据类型转换:
      宽化类型转换(精度丢失):
        - i2l 将操作数栈中的int取出来，转化为long类型，在压回操作数栈
        - i2f 将操作数栈中的int取出来，转化为float类型，在压回操作数栈
        - i2d 将操作数栈中的int取出来，转化为double类型，在压回操作数栈
        - l2f 将操作数栈中的long取出来，转化为float类型，在压回操作数栈
        - l2d 将操作数栈中的long取出来，转化为double类型，在压回操作数栈
        - f2d 将操作数栈中的float取出来，转化为double类型，在压回操作数栈
      窄化类型转换(精度丢失):
        - i2b 将操作数栈中的int取出来，转化为byte类型，在压回操作数栈
        - i2c 将操作数栈中的int取出来，转化为char类型，在压回操作数栈
        - i2s 将操作数栈中的int取出来，转化为short类型，在压回操作数栈
        - l2i 将操作数栈中的long取出来，转化为int类型，在压回操作数栈
        - f2i 将操作数栈中的float取出来，转化为int类型，在压回操作数栈
        - f2l 将操作数栈中的float取出来，转化为long类型，在压回操作数栈
        - d2i 将操作数栈中的double取出来，转化为int类型，在压回操作数栈
        - d2l 将操作数栈中的double取出来，转化为long类型，在压回操作数栈
        - d2f 将操作数栈中的double取出来，转化为float类型，在压回操作数栈
    引用类型转换:
      - checkcast 将操作数栈1个元素(对象实例引用)弹出，强制转换，如果可以将转换后的对象引用重新压入操作数栈，如果不可以抛(ClassCastException)
  对象创建与访问操作码:
    对象创建:
      - new 在堆空间创建一个对象实例，并且把对象实例引用压入操作数栈
    类变量:
      - getstatic 将(类变量值/引用)压入操作数栈
      - putstatic 将1个元素(常量值)弹出操作数栈，并且赋值给类变量
    实例变量:
      - getfield 将1个元素(对象实例引用)弹出操作数栈，通过对象实例引用获取到实例变量，并且将(实例变量值/引用)压入操作数栈
      - putfield 将2个元素(对象实例引用/常量值)弹出操作数栈，通过对象实例引用获取到实例变量，并且将常量值赋值给实例变量。
    数组相关:
      数组创建:
        - newarray 将1个元素(数组大小常量)弹出操作数栈，在堆空间创建一个基本类型数组对象实例，并且把基本类型数组对象实例引用压入操作数栈
        - anewarray 将1个元素(数组大小常量)弹出操作数栈，在堆空间创建一个引用类型数组对象实例，并且把引用类型数组对象实例引用压入操作数栈
        - multianewarray 将N个元素(数组大小常量)弹出操作数栈，在堆空间创建一个多维数组对象实例，并且把多维数组对象实例引用压入操作数栈
      数组获取操作:
        - baload 将2个元素(数组索引值/数组引用)弹出操作数栈，并且通过数组索引值和数组引用获取到具体值，并将具体值压入到操作数栈 (byte/boolean)
        - caload 将2个元素(数组索引值/数组引用)弹出操作数栈，并且通过数组索引值和数组引用获取到具体值，并将具体值压入到操作数栈 (char)
        - saload 将2个元素(数组索引值/数组引用)弹出操作数栈，并且通过数组索引值和数组引用获取到具体值，并将具体值压入到操作数栈 (short)
        - iaload 将2个元素(数组索引值/数组引用)弹出操作数栈，并且通过数组索引值和数组引用获取到具体值，并将具体值压入到操作数栈 (int)
        - laload 将2个元素(数组索引值/数组引用)弹出操作数栈，并且通过数组索引值和数组引用获取到具体值，并将具体值压入到操作数栈 (long)
        - faload 将2个元素(数组索引值/数组引用)弹出操作数栈，并且通过数组索引值和数组引用获取到具体值，并将具体值压入到操作数栈 (float)
        - daload 将2个元素(数组索引值/数组引用)弹出操作数栈，并且通过数组索引值和数组引用获取到具体值，并将具体值压入到操作数栈 (double)
        - aaload 将2个元素(数组索引值/数组引用)弹出操作数栈，并且通过数组索引值和数组引用获取到具体值，并将具体值压入到操作数栈 (引用类型)
      数组赋值操作:
        - bastore 将3个元素(具体值/数组索引值/数组引用)弹出操作数栈，并且对堆空间的数组(byte/boolean)赋值
        - castore 将3个元素(具体值/数组索引值/数组引用)弹出操作数栈，并且对堆空间的数组(char)赋值
        - sastore 将3个元素(具体值/数组索引值/数组引用)弹出操作数栈，并且对堆空间的数组(short)赋值
        - iastore 将3个元素(具体值/数组索引值/数组引用)弹出操作数栈，并且对堆空间的数组(int)赋值
        - lastore 将3个元素(具体值/数组索引值/数组引用)弹出操作数栈，并且对堆空间的数组(long)赋值
        - fastore 将3个元素(具体值/数组索引值/数组引用)弹出操作数栈，并且对堆空间的数组(float)赋值
        - dastore 将3个元素(具体值/数组索引值/数组引用)弹出操作数栈，并且对堆空间的数组(double)赋值
        - aastore 将3个元素(具体值/数组索引值/数组引用)弹出操作数栈，并且对堆空间的数组(引用类型)赋值
      数组长度:
        - arraylength 将1个元素(数组引用)弹出操作数栈，通过数组引用获取到数组长度的具体值，并且将具体值压到操作数栈
    类型检查:
      - instanceof 将1个元素(对象实例引用)弹出操作数栈，判断其是否属于该类型，并且将结果(0/1,true/false)压入操作数栈
  方法调用与返回操作码:
    方法调用:
      invokestatic:
        - 静态方法
        - "
          将N个元素(N个参数值)弹出操作数栈，创建一个新的栈帧。
              正常情况下
                如果有返回值,并且把返回值压入操作数栈，继续往下执行
                如果没有返回值,继续往下执行
              异常情况下
                清空操作数栈，并且把返回值(异常对象引用)压入操作数栈
                  如果有捕获异常，根据异常表进行偏移量跳转，并且继续执行
                  如果没有捕获异常，停止往下执行，并且把当前栈顶元素(引用类型)弹出，返回给调用者
        "
      invokespecial:
        - 构造方法（<init>），私有方法，父类方法
        - "
          将N个元素(N个参数值)弹出操作数栈，创建一个新的栈帧。
              正常情况下
                如果有返回值,并且把返回值压入操作数栈，继续往下执行
                如果没有返回值,继续往下执行
              异常情况下
                清空操作数栈，并且把返回值(异常对象引用)压入操作数栈
                  如果有捕获异常，根据异常表进行偏移量跳转，并且继续执行
                  如果没有捕获异常，停止往下执行，并且把当前栈顶元素(引用类型)弹出，返回给调用者
        "
      invokevirtual:
        - 公共方法，重写公共方法
        - "
          将N个元素(N个参数值)弹出操作数栈，创建一个新的栈帧。
              正常情况下
                如果有返回值,并且把返回值压入操作数栈，继续往下执行
                如果没有返回值,继续往下执行
              异常情况下
                清空操作数栈，并且把返回值(异常对象引用)压入操作数栈
                  如果有捕获异常，根据异常表进行偏移量跳转，并且继续执行
                  如果没有捕获异常，停止往下执行，并且把当前栈顶元素(引用类型)弹出，返回给调用者
        "
      invokeinterface:
        - 接口方法
        - "
          将N个元素(N个参数值)弹出操作数栈，创建一个新的栈帧。
              正常情况下
                如果有返回值,并且把返回值压入操作数栈，继续往下执行
                如果没有返回值,继续往下执行
              异常情况下
                清空操作数栈，并且把返回值(异常对象引用)压入操作数栈
                  如果有捕获异常，根据异常表进行偏移量跳转，并且继续执行
                  如果没有捕获异常，停止往下执行，并且把当前栈顶元素(引用类型)弹出，返回给调用者
        "
      invokedynamic:
        - jdk1.8 动态解析出需要调用的方法，然后执行,具体代表lambda
    方法返回:
      - ireturn 将1个元素(boolean/byte/char/short/int类型数据)弹出操作数栈，将数据返回给调用者操作数栈
      - lreturn 将1个元素(long类型数据)弹出操作数栈，将数据返回给调用者操作数栈
      - freturn 将1个元素(float类型数据)弹出操作数栈，将数据返回给调用者操作数栈
      - dreturn 将1个元素(double类型数据)弹出操作数栈，将数据返回给调用者操作数栈
      - areturn 将1个元素(引用类型数据)弹出操作数栈，将引用返回给调用者操作数栈
      - return
  操作数栈管理操作码:
    弹出:
      - pop 将1个深度弹出操作数栈
      - pop2 将2个深度弹出操作数栈
    复制:
      - dup 复制1个深度到操作数栈栈顶
      - dup_x1 复制1个深度到操作数栈，从上往下数，第2的下面
      - dup_x2 复制2个深度到操作数栈，从上往下数，第3的下面
      - dup2 复制2个深度到操作数栈栈顶
      - dup2_x1 复制2个深度到操作数栈，从上往下数，第3的下面
      - dup2_x2 复制2个深度到操作数栈，从上往下数，第4的下面
    交换:
      - swap 将操作数栈最顶的2个深度做位置交换
    特殊指令:
      - nop 是一个非常特殊的指令，它的16进制表示0x00，和汇编语言中nop一样，它表示什么都不做。这条指令一般可用于调试、占位等。
  比较-条件-跳转操作码:
    比较:
      - lcmp  将操作数栈中2个元素(long型数据)弹出，将2个数值进行比较，将结果压回栈
      - fcmpg 将操作数栈中2个元素(float型数据)弹出，将2个数值进行比较，将结果压回栈
      - fcmpl 将操作数栈中2个元素(float型数据)弹出，将2个数值进行比较，将结果压回栈
      - dcmpg 将操作数栈中2个元素(double型数据)弹出，将2个数值进行比较，将结果压回栈
      - dcmpl 将操作数栈中2个元素(double型数据)弹出，将2个数值进行比较，将结果压回栈
      - 正常情况,v1 v2压栈，取出v1 v2，如果v1<v2将-1结果压回栈，如果v1=v2将0结果压回栈，如果v1>v2将1结果压回栈
      - 遇到NaN(not a number),fcmpg压入1，fcmpl压入-1
    条件跳转:
      - ifeq 将操作数栈中1个元素(boolean/byte/char/short/int型数据)弹出，与0比较，如果【等于0】，则根据偏移量进行跳转，接着往下执行，相反，则往下执行。
      - ifne 将操作数栈中1个元素(boolean/byte/char/short/int型数据)弹出，与0比较，如果【不等于0】，则根据偏移量进行跳转，接着往下执行，相反，则往下执行。
      - iflt 将操作数栈中1个元素(boolean/byte/char/short/int型数据)弹出，与0比较，如果【小于】0，则根据偏移量进行跳转，接着往下执行，相反，则往下执行。
      - ifle 将操作数栈中1个元素(boolean/byte/char/short/int型数据)弹出，与0比较，如果【小于等于】0，则根据偏移量进行跳转，接着往下执行，相反，则往下执行。
      - ifgt 将操作数栈中1个元素(boolean/byte/char/short/int型数据)弹出，与0比较，如果【大于】0，则根据偏移量进行跳转，接着往下执行，相反，则往下执行。
      - ifge 将操作数栈中1个元素(boolean/byte/char/short/int型数据)弹出，与0比较，如果【大于等于】0，则根据偏移量进行跳转，接着往下执行，相反，则往下执行。
      - ifnull 将操作数栈中1个元素(引用型数据)弹出，与null比较，如果【等于】null，则根据偏移量进行跳转，接着往下执行，相反，则往下执行。
      - ifnonnull 将操作数栈中1个元素(引用型数据)弹出，与null比较，如果【不等于】null，则根据偏移量进行跳转，接着往下执行，相反，则往下执行。
    比较条件跳转:
      - if_icmpeq 将操作数栈2个元素(boolean/byte/char/short/int型数据)弹出，将2个数值进行比较，如果v1【等于】v2，则根据偏移量进行跳转，接着往下执行，相反，则往下执行。
      - if_icmpne 将操作数栈2个元素(boolean/byte/char/short/int型数据)弹出，将2个数值进行比较，如果v1【不等于】v2，则根据偏移量进行跳转，接着往下执行，相反，则往下执行。
      - if_icmplt 将操作数栈2个元素(boolean/byte/char/short/int型数据)弹出，将2个数值进行比较，如果v1【小于】v2，则根据偏移量进行跳转，接着往下执行，相反，则往下执行。
      - if_icmple 将操作数栈2个元素(boolean/byte/char/short/int型数据)弹出，将2个数值进行比较，如果v1【小于等于】v2，则根据偏移量进行跳转，接着往下执行，相反，则往下执行。
      - if_icmpgt 将操作数栈2个元素(boolean/byte/char/short/int型数据)弹出，将2个数值进行比较，如果v1【大于】v2，则根据偏移量进行跳转，接着往下执行，相反，则往下执行。
      - if_icmpge 将操作数栈2个元素(boolean/byte/char/short/int型数据)弹出，将2个数值进行比较，如果v1【大于等于】v2，则根据偏移量进行跳转，接着往下执行，相反，则往下执行。
      - if_acmpeq 将操作数栈2个元素(引用型数据型数据)弹出，将2个引用进行比较，如果v1【等于】v2，则根据偏移量进行跳转，接着往下执行，相反，则往下执行。
      - if_acmpne 将操作数栈2个元素(引用型数据型数据)弹出，将2个引用进行比较，如果v1【不等于】v2，则根据偏移量进行跳转，接着往下执行，相反，则往下执行。
    多条件跳转:
      - tableswitch 将操作数栈1个元素(char/byte/short/int)弹出，进行循环遍历比较，当某一个条件成立时，则根据偏移量进行跳转，接着往下执行。
      - lookupswitch 将操作数栈1个元素(char/byte/short/int)弹出，进行循环遍历比较，当某一个条件成立时，则根据偏移量进行跳转，接着往下执行。
      - jdk7新特性，利用String的hashcode来做switch
    强制跳转:
      - goto 接收2个字节(65536行代码)操作数进行偏移量跳转
      - goto_w 接收4个字节(大于65536行代码)操作数进行偏移量跳转
      - jsr 主要用于try-catch-finally语句，已经被废弃
      - jsr_w 主要用于try-catch-finally语句，已经被废弃
      - ret 主要用于try-catch-finally语句，已经被废弃
  异常操作码:
    异常抛出:
      - athrow 将操作数栈1个元素(引用类型)弹出，停止往下执行，将引用返回给调用者操作数栈
    异常表:
      - 早起使用jsr、jsr_w、ret操作码，现在已经被弃用。
      - 如果一个方法定义了一个try-catch或者try-finally的异常处理，就会创建一个异常表。当发生异时，由异常表进行处理。
      - synchronized (new Object()) 同步关键字也会创建异常表
  同步控制操作码:
    方法同步:
      - "
        方法级同步：是隐式同步，即无序通过字节码指令来通知，它实现在方法调用和返回操作之中。
        虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标识得知一个方法是否声明为同步方法。
        当调用方法时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标识是否设置。
            如果设置了，执行线程将先持有同步锁，然后执行方法，最后在方法结束时，释放同步锁(无论是否正常执行完)。
            在方法执行期间，执行线程持有了同步锁，其他任何线程都无法在获取到同一个锁。
            如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放。
        隐式同步是没有monitorenter和monitorexit进行同步区控制，这是因为对于同步方法而言，当虚拟机通过方法的访问标识判断是否是一个同步方法时，会自动在方法调用前进行加锁，当同步方法执行完毕之后，不管方法是否正常结束，虚拟机都会是释放这个锁。
        因此，多余同步方法而言，monitorenter和monitorexit指令是隐式存在的，并未直接出现在字节码中。
      "
    同步代码块:
      - "
        同步一段指令集序列：通常是由Java中的synchronized语句块来表示，jvm的指令集有monitorenter和monitorexit两条指令来支持synchronized关键字的语义。
        当一个线程进入同步代码块时，它使用mointorenter指令请求进入，如果当前对象的监视器计数器为0，则它会被允许进入，若为1，则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行阻等待，直到对象的监视器计数器为0时，才被云溪进入同步块。
        当线程退出同步块时，需要使用monitorexit声明退出。在Java虚拟机中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态。
        指令monitorenter和monitorexit在执行时，都需要在操作数栈顶压入对象，之后monitorenter和monitorexit的锁定和释放都是针对这个对象的监视器进行的。
      "
      - monitorenter 将操作数栈1个元素(锁对象引用)弹出，更改锁状态(把0改为1)
      - monitorexit 将操作数栈1个元素(锁对象引用)弹出，更改锁状态(把1改为0)

