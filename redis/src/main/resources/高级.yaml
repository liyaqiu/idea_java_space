常用命令:
  命令网址:
    - https://try.redis.io/
    - http://doc.redisfans.com/
    - http://www.redis.cn/commands.html
    - https://redis.io/commands/
  命令禁用或改名: "
    rename-command KEYS ''
    rename-command FLUSHDB ''
    rename-command FLUSHALL ''
  "
  命令:
    基本命令: "
      帮助文档 
        help [@string | @list | @hash | @Set | Sorted-Set]
      查询所有
        KEY keys *
      查看key数据类型 
        TYPE k1
      根据参数名查看配置
        CONFIG GET [dir|dbfilename|参数名]
      清空当前数据库所有数据
        FLUSHDB
      情况所有数据库所有数据
        FLUSHALL
      查看某一个库下面的数据总量
        DBSIZE
      删除
        DEL k1 (同步)
        UNLINK k1 (异步)
  "
    遍历命令: "
      0为游标号，根据返回的游标继续往下执行，可以查找所有类型的key
        SCAN 0 MATCH * COUNT 2 
      只对某一个Set类型的值进行查找，0为游标号，根据返回的游标继续往下执行
        SSCAN s1 0 MATCH * count 2
      只对某一个Hash类型的值进行查找，0为游标号，根据返回的游标继续往下执行
        HSCAN h1 0 MATCH * COUNT 2
      只对某一个Sort-Set类型的值进行查找，0为游标号，根据返回的游标继续往下执行
        ZSCAN z1 0 MATCH *  COUNT 2
    "
bigkey:
  概述: 大于10kb或者大于5000个元素
  查找bigkey: "
    查找bigkey
      redis-cli -h 192.168.88.11  -a 123456 -p 7771 -n 1 --bigkeys
    统计bigkey占用字节数
      redis-cli -h 192.168.88.11  -a 123456 -p 7771 -n 1 MEMORY USAGE k1
  "
  bigkey删除:
    概述:
      - 字符串可以使用del或者unlink删除
      - 其他类型则使用sscan hscan zscan进行渐进性删除(先把内容情况，在使用del进行删除)
  惰性删除(异步处理): "
    lazyfree-lazy-eviction no
    lazyfree-lazy-expire no
    lazyfree-lazy-server-del yes 更改后del编译异步删除
    replica-lazy-flush yes
    lazyfree-lazy-user-del yes
  "
双写一致性:
  概述:
    - 先写MYSQL，给redis缓存设置过期时间，可以保证最终一致性
    - "
      我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。
      也就是说如果数据库写入成哥，缓存更新失败，那么只要达到过期时间，则后面的读请求自然会从数据库
      中读取最新值然后回填redis缓存，达到双写最终一致性。
    "
  方案1:
    读策略: 双检锁实现读操作同步
    写策略: 先更新mysql，在删除redis（会读到一部分没更新前的数据）
  方案2: 利用canal来监听binlog（会读到一部分没更新前的数据，实时性较高）
布隆过滤器(bitmap):
  概述:
    - 布隆过滤器实际上是一个很长的二进制位数组，利用N个hash函数做值(key)的运算，得出的hash值存储于二进制位数组中
    - 用redis的bitmap来实现布隆过滤器，因为bitmap用位存储，所以占用空间较小
    - 一般情况下，布隆过滤器不允许删，会出现误删(hash冲突导致的每个位可能存在多条记录)
  hash冲突: "
    Aa 和 BB hash值为2112
    柳柴 和 柴柕 hash值为851553
  "
  结论:
    - 当集合中有，可能有(hash冲突导致的)
    - 当集合中无，一定无
  案例:
    - 判断某个网址是否在黑名单
    - 判断某个用户是否在，如果存在则可以进一步跑逻辑程序，否则直接返回
    - 可以解决缓存透传问题
  缺点: 布隆过滤器预热(初始化布隆过滤器麻烦)
缓存穿透:
  概述:
    - "
      一般情况下，先查询缓存redis是否有该记录，缓存中没有时，在查询数据库。
      当数据库也不存在该记录时，每次查询都要访问数据库，这就是缓存穿透。
      
      缓存穿透带解决的问题是，当有大量请求查询数据库不存在的记录时，就会给数据库带来压力，甚至会拖垮数据库
    "
  解决缓存穿透: 利用布隆过滤器
  产生原因: 恶意攻击
缓存击穿:
  概述: "
    大量的请求同时查询一个热点key时，此时这个热点key正在做数据切换，就会导致大量的请求都请求到数据库上
  "
  解决方案1(推荐): "
      可以利用A和B两个缓存，做到无缝切换热点key数据
              查询，先A后B
              删除，先B后A
    "
  解决方案2: 使用双检锁实现，降低MYSQL查询频率
  产生原因: 热点key失效